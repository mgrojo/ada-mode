;;; Wisi grammar for Ada
;;
;; Copyright (C) 2012 - 2016 Free Software Foundation, Inc.
;;
;; Author: Stephen Leake <stephe-leake@stephe-leake.org>
;; Maintainer: Stephen Leake <stephe-leake@stephe-leake.org>
;; Created: Sept 2012
;; Keywords: syntax
;;
;; This file is part of GNU Emacs.
;;
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;
;;; Commentary:
;;
;; This is a wisi grammar file for the Ada language. It is derived
;; from the 2012 Ada Reference Manual (ARM), which is available as
;; (info "(aarm2012)") or at
;; http://www.ada-auth.org/standards/ada12.html, under the license in
;; ada_license.text.
;;
;; see wisi.el for discussion of using the wisi parser for an
;; indentation engine.

;;; Prologue
%{
;; Copyright (C) 2013 - 2015 Free Software Foundation, Inc.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
%}

;; Declarations

;; token declarations

;; Ada keywords (ARM 2.9) and operators (info "(aarm2012)2.9" "*info AARM*")

%keyword ABS "abs"
%keyword ACCEPT "accept"
%keyword ABORT "abort"
%keyword ABSTRACT "abstract"
%keyword ACCESS "access"
%keyword ALIASED "aliased"
%keyword ALL "all"
%keyword AND "and"
%keyword ARRAY "array"
%keyword AT "at"
%keyword BEGIN "begin"
%keyword BODY "body"
%keyword CASE "case"
%keyword CONSTANT "constant"
%keyword DECLARE "declare"
%keyword DELAY "delay"
%keyword DELTA "delta"
%keyword DIGITS "digits"
%keyword DO "do"
%keyword ELSE "else"
%keyword ELSIF "elsif"
%keyword END "end"
%keyword ENTRY "entry"
%keyword EXCEPTION "exception"
%keyword EXIT "exit"
%keyword FOR "for"
%keyword FUNCTION "function"
%keyword GENERIC "generic"
%keyword GOTO "goto"
%keyword IF "if"
%keyword IN "in"
%keyword INTERFACE "interface"
%keyword IS "is"
%keyword LEFT_PAREN "("
%keyword LIMITED "limited"
%keyword LOOP "loop"
%keyword MOD "mod"
%keyword NEW "new"
%keyword NOT "not"
%keyword NULL "null"
%keyword OF "of"
%keyword OR "or"
%keyword OTHERS "others"
%keyword OUT "out"
%keyword OVERRIDING "overriding"
%keyword PACKAGE "package"
%keyword PRAGMA "pragma"
%keyword PRIVATE "private"
%keyword PROCEDURE "procedure"
%keyword PROTECTED "protected"
%keyword RAISE "raise"
%keyword RANGE "range"
%keyword RECORD "record"
%keyword REM "rem"
%keyword RENAMES "renames"
%keyword REQUEUE "requeue"
%keyword RETURN "return"
%keyword REVERSE "reverse"
%keyword RIGHT_PAREN ")"
%keyword SEPARATE "separate"
%keyword SELECT "select"
%keyword SOME "some"
%keyword SUBTYPE "subtype"
%keyword SYNCHRONIZED "synchronized"
%keyword TAGGED "tagged"
%keyword TASK "task"
%keyword TERMINATE "terminate"
%keyword THEN "then"
%keyword TYPE "type"
%keyword UNTIL "until"
%keyword USE "use"
%keyword WHEN "when"
%keyword WHILE "while"
%keyword WITH "with"
%keyword XOR "xor"

;; all tokens that consist of characters with punctuation syntax
%token <punctuation> AMPERSAND "&"
%token <punctuation> BAR "|"
%token <punctuation> BOX "<>"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUAL ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> DOT_DOT ".."
%token <punctuation> EQUAL "="
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> GREATER ">"
%token <punctuation> GREATER_EQUAL ">="
%token <punctuation> GREATER_GREATER ">>"
%token <punctuation> LESS "<"
%token <punctuation> LESS_EQUAL "<="
%token <punctuation> LESS_LESS "<<"
%token <punctuation> MINUS "-"
%token <punctuation> PLUS "+"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> SLASH_EQUAL "/="
%token <punctuation> STAR "*"
%token <punctuation> STAR_STAR "**"
%token <punctuation> TICK "'"

;; We don't need numeric_literal for indentation, but we do need it for face.
;; Must be before IDENTIFIER; otherwise recognized as an identifier
%token <number> NUMERIC_LITERAL ada-wisi-number-p

;; whitespace, comment not seen by wisi lexer, but are needed by Ada lexer
%token <whitespace> WHITESPACE ""
%token <line_comment> COMMENT "--"
%token <symbol> IDENTIFIER
%token <string-double> STRING_LITERAL
%token <string-single> CHARACTER_LITERAL

%start compilation_unit_list

;; known conflicts that are resolved by generalized LALR parser
%conflict REDUCE/REDUCE in state abstract_limited_opt, abstract_limited_synchronized_opt on token NEW
%conflict REDUCE/REDUCE in state abstract_limited_synchronized_opt, abstract_limited_opt on token NEW
%conflict REDUCE/REDUCE in state association_opt, expression_opt on token COMMA
%conflict REDUCE/REDUCE in state association_opt, expression_opt on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state choice_relation, relation on token AND
%conflict REDUCE/REDUCE in state choice_relation, relation on token OR
%conflict REDUCE/REDUCE in state choice_relation, relation on token XOR
%conflict REDUCE/REDUCE in state constraint_opt, and_interface_list_opt on token WITH
%conflict REDUCE/REDUCE in state expression_opt, association_opt on token COMMA
%conflict REDUCE/REDUCE in state expression_opt, association_opt on token IS
%conflict REDUCE/REDUCE in state expression_opt, association_opt on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state expression_opt, association_opt on token SEMICOLON
%conflict REDUCE/REDUCE in state identifier_list, name on token COMMA
%conflict REDUCE/REDUCE in state name, direct_name on token USE
%conflict REDUCE/REDUCE in state primary, subtype_indication on token COMMA
%conflict REDUCE/REDUCE in state primary, subtype_indication on token EQUAL_GREATER
%conflict REDUCE/REDUCE in state primary, subtype_indication on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state range_list, discrete_subtype_definition on token COMMA
%conflict REDUCE/REDUCE in state range_list, discrete_subtype_definition on token RIGHT_PAREN
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token ABORT
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token ACCEPT
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token BEGIN
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token CASE
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token CHARACTER_LITERAL
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token DECLARE
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token DELAY
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token EXIT
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token FOR
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token GOTO
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token IDENTIFIER
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token IF
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token LOOP
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token NULL
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token PRAGMA
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token RAISE
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token REQUEUE
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token RETURN
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token SELECT
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token STRING_LITERAL
%conflict REDUCE/REDUCE in state sequence_of_statements, label_opt on token WHILE
%conflict SHIFT/REDUCE in state actual_parameter_part, actual_parameter_part_opt on token LEFT_PAREN
%conflict SHIFT/REDUCE in state actual_parameter_part, attribute_designator on token LEFT_PAREN
%conflict SHIFT/REDUCE in state aspect_clause, name on token USE
%conflict SHIFT/REDUCE in state association_opt, name on token EQUAL_GREATER
%conflict SHIFT/REDUCE in state attribute_reference, attribute_designator on token TICK
%conflict SHIFT/REDUCE in state declaration, aliased_opt on token CONSTANT
%conflict SHIFT/REDUCE in state expression_function_declaration, subprogram_specification on token IS
%conflict SHIFT/REDUCE in state formal_derived_type_definition, formal_derived_type_definition on token WITH
%conflict SHIFT/REDUCE in state generic_instantiation, aspect_specification_opt on token IS
%conflict SHIFT/REDUCE in state generic_instantiation, parameter_profile_opt on token IS
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part on token FUNCTION
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part on token PACKAGE
%conflict SHIFT/REDUCE in state generic_renaming_declaration, generic_formal_part on token PROCEDURE
%conflict SHIFT/REDUCE in state label_opt, label_opt on token IDENTIFIER
%conflict SHIFT/REDUCE in state null_exclusion_opt, mode_opt on token NOT
%conflict SHIFT/REDUCE in state null_procedure_declaration, subprogram_specification on token IS
%conflict SHIFT/REDUCE in state object_renaming_declaration, identifier_list on token COLON
%conflict SHIFT/REDUCE in state package_body_stub, aspect_specification_opt on token IS
%conflict SHIFT/REDUCE in state protected_body_stub, aspect_specification_opt on token IS
%conflict SHIFT/REDUCE in state raise_expression, raise_expression on token WITH
%conflict SHIFT/REDUCE in state relation_and_list, expression on token AND
%conflict SHIFT/REDUCE in state relation_and_then_list, expression on token AND
%conflict SHIFT/REDUCE in state relation_or_else_list, expression on token OR
%conflict SHIFT/REDUCE in state relation_or_list, expression on token OR
%conflict SHIFT/REDUCE in state relation_xor_list, expression on token XOR
%conflict SHIFT/REDUCE in state selected_component, attribute_designator on token DOT
%conflict SHIFT/REDUCE in state simple_return_statement, expression_opt on token SEMICOLON
%conflict SHIFT/REDUCE in state subprogram_body_stub, aspect_specification_opt on token IS
%conflict SHIFT/REDUCE in state task_body_stub, aspect_specification_opt on token IS

%%
;;;; grammar rules
;;
;; The actions cache information in keywords that are significant for
;; indentation and motion.
;;
;; BNF copied from:
;;
;; (info "(aarm2012)Annex P" "*info Annex P*")
;; file:///C:/Projects/arm_info/org.adaic.arm_form/build/html/aarm2012/AA-P.html
;;
;; but listed in alphabetical order. Repeating constructs are
;; implemented with extra productions. Optional constructs are
;; implemented by repeated productions. Most names are simplified to
;; just "name".
;;
;; BNF not copied until part of it is encountered in a test,
;; part not needed left commented out.

abstract_limited_synchronized_opt
  : ;; empty
  | ABSTRACT LIMITED
  | ABSTRACT SYNCHRONIZED
  | ABSTRACT
  | LIMITED
  | SYNCHRONIZED
  ;

abstract_limited_opt
  : ;; empty
  | ABSTRACT LIMITED
  | LIMITED
  | ABSTRACT
  ;

abstract_tagged_limited_opt
  : ;; empty
  | ABSTRACT TAGGED LIMITED
  | ABSTRACT TAGGED
  | TAGGED LIMITED
  | TAGGED
  | LIMITED
  ;

abstract_subprogram_declaration
  : overriding_indicator_opt subprogram_specification IS ABSTRACT aspect_specification_opt SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-other 6 statement-end])
  ;

accept_statement
  : ACCEPT IDENTIFIER actual_parameter_part_opt parameter_profile_opt DO handled_sequence_of_statements END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 2 name-paren 5 block-middle 7 block-end 9 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 2 4)
      (wisi-containing-action 5 6)
      (wisi-motion-action [1 5 [6 block-middle EXCEPTION block-middle WHEN]])
      (wisi-face-action [2 font-lock-function-name-face 8 font-lock-function-name-face]))
  | ACCEPT IDENTIFIER actual_parameter_part_opt parameter_profile_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name-paren 5 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 2 4)
      (wisi-face-action [2 font-lock-function-name-face]))
  ;

access_definition ;; same as access_type_definition for our purposes
  : null_exclusion_opt ACCESS general_access_modifier_opt name
    (wisi-face-action [4 font-lock-type-face])
  | null_exclusion_opt ACCESS protected_opt PROCEDURE parameter_profile_opt
    (progn
      (wisi-statement-action [4 name-paren])
      (wisi-containing-action 4 5))
  | null_exclusion_opt ACCESS protected_opt FUNCTION parameter_and_result_profile
    (progn
      (wisi-statement-action [4 name-paren])
      (wisi-containing-action 4 5)
      (wisi-motion-action [4 [5 return-with-params RETURN return-without-params RETURN]]))
  ;

actual_parameter_part
  : LEFT_PAREN association_list RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

actual_parameter_part_opt
  : ;; empty
  | actual_parameter_part
  ;

aggregate
  : LEFT_PAREN association_list RIGHT_PAREN ;; record_aggregate, named_array_aggregate, positional_array_aggregate
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  | LEFT_PAREN expression_opt WITH association_list RIGHT_PAREN ;; extension_aggregate
    (progn
      (wisi-statement-action [1 open-paren 3 statement-other 5 close-paren])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 4))
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  | LEFT_PAREN expression_opt WITH NULL RECORD RIGHT_PAREN ;; extension_aggregate with null record
    (progn
      (wisi-statement-action [1 open-paren 3 statement-other 6 close-paren])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3))
  | LEFT_PAREN NULL RECORD RIGHT_PAREN
    (wisi-statement-action [1 open-paren 4 close-paren])
  ;

aliased_opt
  : ;; empty
  | ALIASED
  ;

and_interface_list_opt
  : ;; empty
  | AND interface_list
  ;

array_type_definition
  : ARRAY LEFT_PAREN index_subtype_definition_list RIGHT_PAREN OF component_definition
 ;; unconstrained_array_definition
    (progn
      (wisi-statement-action [2 open-paren 4 close-paren 5 statement-other])
      (wisi-containing-action 2 3)
      (wisi-containing-action 5 6))
  | ARRAY LEFT_PAREN discrete_subtype_definition_list RIGHT_PAREN OF component_definition
 ;; constrained_array_definition
    (progn
      (wisi-statement-action [2 open-paren 4 close-paren 5 statement-other])
      (wisi-containing-action 2 3)
      (wisi-containing-action 5 6))
  ;

aspect_clause
  : FOR attribute_reference USE expression_opt SEMICOLON ;; attribute_definition_clause
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4))
  | enumeration_representation_clause
  | record_representation_clause
  | at_clause
  ;

;; aspect_mark ::= aspect_identifier[Class]

;; aspect_specification ::=
;;   with aspect_mark [=> aspect_definition] {,
;;        aspect_mark [=> aspect_definition] }
aspect_specification_opt
  : ;; empty
  | WITH association_list ;; overkill, but simpler.
    (progn
      (wisi-statement-action [1 statement-other])
      (wisi-containing-action 1 2))
  ;

assignment_statement
  : name COLON_EQUAL expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 4 statement-end])
      (wisi-containing-action 2 3))
  ;

association_opt
  : ;; empty
  | CHARACTER_LITERAL EQUAL_GREATER expression_opt ;; part of selector_name that does not overlap name
  | CHARACTER_LITERAL EQUAL_GREATER BOX ;; from formal_package_association_list
  | discrete_choice_list EQUAL_GREATER expression_opt
    (progn
      (wisi-statement-action [2 statement-other])
      (wisi-containing-action 2 3)) ;; for indenting aspects
  | discrete_choice_list EQUAL_GREATER BOX
  | expression_opt
  ;

association_list
  : association_opt
  | association_list COMMA association_opt
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
 ;; FIXME: do this here
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))

  ;

asynchronous_select
  : SELECT triggering_alternative THEN ABORT sequence_of_statements_opt END SELECT SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 4 statement-other 6 block-end 8 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 5))
  ;

at_clause
  : FOR direct_name USE AT expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 4 statement-other 6 statement-end])
      (wisi-containing-action 4 5))
  ;

attribute_reference : name TICK attribute_designator ;

attribute_designator
;; IDENTIFIER LEFT_PAREN expression RIGHT_PAREN is redundant with name
  : name
  | ACCESS
  | DELTA
  | DIGITS
  | MOD
  ;

;; basic_declarative_item merged into declaration
;; basic_declaration merged into declaration

binary_adding_operator : PLUS | MINUS | AMPERSAND ; ;; + | - | &

block_statement
  : DECLARE declarative_part_opt BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
 ;; label_opt covered by statement; no face for label names
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 3 [4 block-middle EXCEPTION block-middle WHEN] 5]))
  | BEGIN handled_sequence_of_statements END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-end 5 statement-end])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 [2 block-middle EXCEPTION block-middle WHEN] 3]))
  ;

body : proper_body | body_stub ;

body_stub : subprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub ;

case_expression
  : CASE expression_opt IS case_expression_alternative_list
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4))
  ;

case_expression_alternative
  : WHEN discrete_choice_list EQUAL_GREATER expression_opt
    (progn
      (wisi-statement-action [1 block-middle 3 statement-other])
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 4))
  ;

case_expression_alternative_list
  : case_expression_alternative
  | case_expression_alternative_list COMMA case_expression_alternative
    (progn
      (wisi-statement-action [2 list-break]))
  ;

case_statement
  : CASE expression_opt IS case_statement_alternative_list END CASE SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 [4 block-middle WHEN] 5]))
  ;

case_statement_alternative
  : WHEN discrete_choice_list EQUAL_GREATER sequence_of_statements_opt
    (progn
      (wisi-statement-action [1 block-middle 3 statement-other])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 4))
  ;

;; We dont allow an empty list here; that leads to parallel parser
;; explosion in nested case statements. Note that ada-skel-case
;; inserts an empty when =>
case_statement_alternative_list
  : case_statement_alternative
  | case_statement_alternative_list case_statement_alternative
  ;

choice_expression
  : choice_relation
  | choice_relation_and_list
  | choice_relation_or_list
  | choice_relation_xor_list
  | choice_relation_and_then_list
  | choice_relation_or_else_list
  ;

choice_relation_and_list
  : choice_relation AND choice_relation
  | choice_relation_and_list AND choice_relation
  ;

choice_relation_or_list
  : choice_relation OR choice_relation
  | choice_relation_or_list OR choice_relation
  ;

choice_relation_xor_list
  : choice_relation XOR choice_relation
  | choice_relation_xor_list XOR choice_relation
  ;

choice_relation_and_then_list
  : choice_relation AND THEN choice_relation
  | choice_relation_and_then_list AND THEN choice_relation
  ;

choice_relation_or_else_list
  : choice_relation OR ELSE choice_relation
  | choice_relation_or_else_list OR ELSE choice_relation
  ;

choice_relation
  : simple_expression relational_operator simple_expression
  | simple_expression
  ;

;; since we allow multiple compilation units in one parse, and dont
;; require a library_item in order to be user friendly, we dont need
;; a context_clause, since a list of context_items is just a
;; compilation_unit_list. Since context_item includes pragma, this
;; also allows a pragma following a compilation_unit.
compilation_unit
  : context_item
  | library_item
  | subunit
  ;

compilation_unit_list
  : compilation_unit
  | compilation_unit_list compilation_unit
  ;

component_clause
  : IDENTIFIER AT simple_expression RANGE simple_expression DOT_DOT simple_expression SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 4 statement-other 6 statement-other 8 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 6 7))
  ;

component_clause_list
  : component_clause
  | component_clause_list component_clause
  ;

component_declaration
  : identifier_list COLON component_definition COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 4 statement-other 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 4 6))
  | identifier_list COLON component_definition aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 5 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 2 4))
  ;

component_definition
  : ALIASED subtype_indication
  | subtype_indication
  | ALIASED access_definition
  | access_definition
  ;

component_item
  : component_declaration
  | aspect_clause
  ;

component_list
  : component_item
  | component_list component_item
  | component_list variant_part
  | variant_part
  | NULL SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  ;

component_list_opt
  : ;; empty
  | component_list
  ;

compound_statement
  : if_statement
  | case_statement
  | loop_statement
  | block_statement
  | extended_return_statement
  | accept_statement
  | select_statement
  ;

conditional_entry_call
  : SELECT entry_call_alternative ELSE sequence_of_statements_opt END SELECT SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4))
  ;

conditional_quantified_expression
  : if_expression
  | case_expression
  | quantified_expression
  ;

constant_opt
  : ;; empty
  | CONSTANT
  ;

constraint
  : RANGE range ;; range_constraint
 ;; | digits_constraint
 ;; | delta_constraint
  | index_constraint
 ;; | discriminant_constraint
  ;

constraint_opt
  : ;; empty
  | constraint
  ;

context_item : pragma | with_clause | use_clause;

declaration
  : abstract_subprogram_declaration
  | aspect_clause
  | body
  | entry_declaration
  | exception_declaration
  | expression_function_declaration
  | generic_declaration
  | generic_instantiation
  | null_procedure_declaration
  | identifier_list COLON CONSTANT COLON_EQUAL expression_opt SEMICOLON ;; number_declaration
    (progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 1 5))
  | object_declaration
  | package_declaration
  | pragma ;; not a declaration in ARM, but it must be in the grammar
  | renaming_declaration
  | subprogram_declaration
  | subtype_declaration
  | type_declaration
  | use_clause
  ;

declarations
  : declaration
  | declarations declaration
  ;

declarative_part_opt
  : ;; empty
  | declarations
  ;

;; declarative_item merged into declaration

delay_alternative : delay_statement sequence_of_statements_opt ;

delay_statement
  : DELAY UNTIL expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-containing-action 1 3))
  | DELAY expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-containing-action 1 2))
  ;

derived_type_definition
  : abstract_limited_opt NEW name and_interface_list_opt WITH record_definition
    (progn
      (wisi-statement-action [5 statement-other])
      (wisi-face-action [3 font-lock-type-face]))
  | abstract_limited_opt NEW name constraint_opt
    (wisi-face-action [3 font-lock-type-face])
  ;

direct_name
  : IDENTIFIER
  | STRING_LITERAL ;; operator_symbol
  ;

direct_name_opt
  : ;; empty
  | direct_name
  ;

discrete_choice
  : choice_expression ;; includes name
  | NOT NULL name ;; from subytpe_indication, excluding constructs covered by name
  | range
  | OTHERS
  ;

discrete_choice_list
  : ;; empty for skeleton indentation
  | discrete_choice
  | discrete_choice_list BAR discrete_choice
  ;

 ;; discrete_range is the same as discrete_subtype_definition

 ;; discrete_range_list is the same as discrete_subtype_definition_list

discrete_subtype_definition : subtype_indication | range ;

discrete_subtype_definition_list
  : discrete_subtype_definition
  | discrete_subtype_definition_list COMMA discrete_subtype_definition
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

discriminant_part_opt
  : ;; empty
  | LEFT_PAREN BOX RIGHT_PAREN ;; (<>) unknown_discriminant_part
  | LEFT_PAREN discriminant_specification_list RIGHT_PAREN;; known_discriminant_part
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

discriminant_specification_opt
  : ;; empty
  | identifier_list COLON null_exclusion_opt_name_type COLON_EQUAL expression_opt
  | identifier_list COLON null_exclusion_opt_name_type
  | identifier_list COLON access_definition COLON_EQUAL expression_opt
  | identifier_list COLON access_definition
  ;

discriminant_specification_list
  : discriminant_specification_opt
  | discriminant_specification_list SEMICOLON discriminant_specification_opt
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

elsif_expression_item
  : ELSIF expression_opt THEN expression_opt
    (progn
      (wisi-statement-action [1 statement-other 3 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4))
 ;; motion set in if_expression
  ;

elsif_expression_list
  : elsif_expression_item
  | elsif_expression_list elsif_expression_item
  ;

elsif_statement_item
  : ELSIF expression_opt THEN sequence_of_statements_opt
    (progn
      (wisi-statement-action [1 statement-other 3 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4))
 ;; motion set in if_statement
  ;

elsif_statement_list
  : elsif_statement_item
  | elsif_statement_list elsif_statement_item
  ;

entry_body
  : ENTRY IDENTIFIER entry_body_formal_part WHEN expression_opt IS declarative_part_opt BEGIN
    handled_sequence_of_statements END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 4 statement-other 6 block-middle 8 block-middle 10 block-end
                             12 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 6 7)
      (wisi-containing-action 8 9)
      (wisi-motion-action [1 4 6 8 10])
      (wisi-face-action [2 font-lock-function-name-face 11 font-lock-function-name-face ]))
  ;

entry_body_formal_part
  : LEFT_PAREN FOR IDENTIFIER IN discrete_subtype_definition RIGHT_PAREN parameter_profile_opt
    (progn
      (wisi-statement-action [1 open-paren 6 close-paren])
      (wisi-containing-action 1 4))
  | parameter_profile_opt
  ;

entry_call_alternative
  : procedure_call_statement sequence_of_statements_opt
  | name sequence_of_statements_opt ;; entry_call_statement
  ;

entry_declaration
  : overriding_indicator_opt ENTRY IDENTIFIER LEFT_PAREN discrete_subtype_definition RIGHT_PAREN
    parameter_profile_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 4 open-paren 6 close-paren 8 statement-end])
      (wisi-containing-action 2 4)
      (wisi-containing-action 4 5)
      (wisi-containing-action 2 6)
      (wisi-containing-action 2 7)
      (wisi-face-action [3 font-lock-function-name-face]))
  | overriding_indicator_opt ENTRY IDENTIFIER parameter_profile_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 6 statement-end])
      (wisi-containing-action 2 4)
      (wisi-containing-action 2 5)
      (wisi-face-action [3 font-lock-function-name-face]))
  ;

enumeration_literal ;; enumeration_literal_specification
  : IDENTIFIER
  | CHARACTER_LITERAL
  ;

enumeration_literal_list
  : enumeration_literal
  | enumeration_literal_list COMMA enumeration_literal
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

enumeration_representation_clause
  : FOR name USE aggregate SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4)
      (wisi-face-action [2 font-lock-type-face]))
  ;

enumeration_type_definition
  : LEFT_PAREN enumeration_literal_list RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

exception_choice : name | OTHERS ;

exception_choice_list
  : exception_choice
  | exception_choice_list BAR exception_choice
  ;

;; leaving out [aspect_specification]
exception_declaration
  : identifier_list COLON EXCEPTION SEMICOLON
    (wisi-statement-action [1 statement-start 4 statement-end])
  ;

exception_handler
  : WHEN IDENTIFIER COLON exception_choice_list EQUAL_GREATER sequence_of_statements_opt
    (progn
      (wisi-statement-action [1 block-middle 5 statement-other])
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 5)
      (wisi-containing-action 5 6))
  | WHEN exception_choice_list EQUAL_GREATER sequence_of_statements_opt
    (progn
      (wisi-statement-action [1 block-middle 3 statement-other])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 4))
  ;

exception_handler_list
  : exception_handler
  | exception_handler_list exception_handler
  ;

exception_handler_list_opt
  : ;; empty for user friendly
  | exception_handler_list
  ;

exit_statement
  : EXIT identifier_opt WHEN expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4))
  | EXIT identifier_opt SEMICOLON
    (wisi-statement-action [1 statement-start 3 statement-end])
  ;

expression
  : relation
  | relation_and_list
  | relation_and_then_list
  | relation_or_list
  | relation_or_else_list
  | relation_xor_list
  ;

expression_opt
  : ;; empty for user friendly
  | expression
    (wisi-statement-action [1 expression-start])
    (wisi-containing-action 1 1)
  ;

expression_function_declaration
  : overriding_indicator_opt function_specification IS paren_expression aspect_specification_opt SEMICOLON
 ;; IS does not start a block, so it is not "block-middle".
 ;;
 ;; We override the cache on "function_specification", so
 ;; wisi-statement-action will handle an empty
 ;; "overriding_indicator_opt" correctly. FIXME: should not have to do
 ;; this, but it is also done in other grammar statements.
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 3 statement-other 6 statement-end])
      (wisi-containing-action 3 4)
      (wisi-containing-action 2 5))
  ;

extended_return_object_declaration
  : IDENTIFIER COLON aliased_opt constant_opt return_subtype_indication COLON_EQUAL expression_opt
    (progn
      (wisi-statement-action [1 statement-start 6 statement-other])
      (wisi-containing-action 6 7))
  | IDENTIFIER COLON aliased_opt constant_opt return_subtype_indication
  ;

extended_return_object_declaration_opt
  : ;; empty
  | extended_return_object_declaration
  ;

extended_return_statement
  : RETURN extended_return_object_declaration_opt DO handled_sequence_of_statements END RETURN SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 3 5]))
  | RETURN extended_return_object_declaration SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end]))
  ;

;; designator is merged with name

factor
  : primary STAR_STAR primary
  | primary
  | ABS primary
  | NOT primary
  ;

formal_object_declaration
  : identifier_list COLON mode_opt null_exclusion_opt name COLON_EQUAL expression_opt aspect_specification_opt
    SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 6 statement-other 9 statement-end])
      (wisi-containing-action 6 7)
      (wisi-containing-action 6 8)
      (wisi-face-action [5 font-lock-type-face]))
  | identifier_list COLON mode_opt null_exclusion_opt name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 5 6)
      (wisi-face-action [5 font-lock-type-face]))
  | identifier_list COLON mode_opt access_definition COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-other 8 statement-end])
      (wisi-containing-action 5 6)
      (wisi-containing-action 5 7))
  | identifier_list COLON mode_opt access_definition aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 4 5))
  ;

formal_part
  : LEFT_PAREN parameter_specification_list RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

formal_subprogram_declaration
  : WITH subprogram_specification IS subprogram_default aspect_specification_opt SEMICOLON
 ;; formal_concrete_subprogram_declaration
    (progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 5))
  | WITH subprogram_specification aspect_specification_opt SEMICOLON ;; formal_concrete_subprogram_declaration
    (progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3))
  | WITH subprogram_specification IS ABSTRACT subprogram_default aspect_specification_opt SEMICOLON
 ;; formal_abstract_subprogram_declaration
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 6))
  | WITH subprogram_specification IS ABSTRACT aspect_specification_opt SEMICOLON
 ;; formal_abstract_subprogram_declaration
    (progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 5))
  ;

formal_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS formal_type_definition aspect_specification_opt SEMICOLON
 ;; formal_complete_type_declaration
    (progn
      (wisi-statement-action [1 statement-start 4 statement-other 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 4 6)
      (wisi-face-action [2 font-lock-type-face]))
  | TYPE IDENTIFIER discriminant_part_opt IS TAGGED aspect_specification_opt SEMICOLON
 ;; formal_incomplete_type_declaration
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 6)
      (wisi-face-action [2 font-lock-type-face]))
  | TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 2 4)
      (wisi-face-action [2 font-lock-type-face]))
  ;

formal_type_definition
  : abstract_tagged_limited_opt PRIVATE ;; formal_private_type_definition
  | formal_derived_type_definition
  | LEFT_PAREN BOX RIGHT_PAREN ;; formal_discrete_type_definition
  | RANGE BOX ;; formal_signed_integer_type_definition
  | MOD BOX ;; formal_modular_type_definition
  | DIGITS BOX ;; formal_floating_point_definition
  | DELTA BOX ;; formal_ordinary_fixed_point_definition
  | DELTA BOX DIGITS BOX ;; formal_decimal_fixed_point_definition
  | array_type_definition ;; formal_array_type_definition
  | access_definition ;; access_type_definition, formal_access_type_definition
  | interface_type_definition ;; formal_interface_type_definition
  ;

;; formal_derived_type_definition ::=
;;   [abstract] [limited | synchronized] new subtype_mark [[and interface_list]with private]
formal_derived_type_definition
  : abstract_limited_synchronized_opt NEW name and_interface_list_opt WITH PRIVATE
    (wisi-face-action [3 font-lock-type-face])
  | abstract_limited_synchronized_opt NEW name and_interface_list_opt
    (wisi-face-action [3 font-lock-type-face])
  ;

formal_package_declaration
  : WITH PACKAGE name IS NEW name formal_package_actual_part aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-other 6 name 7 statement-other 8 statement-other 9 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 5 6)
      (wisi-containing-action 6 7)
      (wisi-containing-action 6 8)
      (wisi-face-action [3 font-lock-function-name-face 6 font-lock-function-name-face]))
  ;

formal_package_actual_part
  : LEFT_PAREN BOX RIGHT_PAREN ;; (<>)
  | ;; empty generic actual part

 ;; | LEFT_PAREN association_list RIGHT_PAREN
 ;; covered by name <empty formal_package_actual_part) in formal_package_declaration
 ;; covers others => <>
  ;

;; formal_package_association_list is merged into association_list to avoid reduce/reduce conflict

full_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS type_definition aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 statement-other 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 4 6)
      (wisi-face-action [2 font-lock-type-face]))
  | task_type_declaration
  | protected_type_declaration
  ;

function_specification
  : FUNCTION name parameter_and_result_profile
    (progn
      (wisi-statement-action [1 statement-other 2 name])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-motion-action [1 [3 return-with-params RETURN return-without-params RETURN]])
      (wisi-face-action [2 font-lock-function-name-face]))
  ;

general_access_modifier_opt
  : ;; empty
  | ALL
  | CONSTANT
  ;

;; generic_actual_part is not needed; see generic_instantiation

;; generic_association is merged into association

generic_declaration
  : generic_subprogram_declaration
  | generic_package_declaration
  ;

generic_formal_part
  : GENERIC generic_formal_parameter_declarations
    (progn
      (wisi-statement-action [1 block-start])
      (wisi-containing-action 1 2))
  | GENERIC
    (wisi-statement-action [1 block-start])
  ;

generic_formal_parameter_declarations
  : generic_formal_parameter_declaration
  | generic_formal_parameter_declarations generic_formal_parameter_declaration
  ;

generic_formal_parameter_declaration
  : formal_object_declaration
  | formal_type_declaration
  | formal_subprogram_declaration
  | formal_package_declaration
  | pragma
  | use_clause
  ;

generic_instantiation
 ;; name generic_actual_part is included in name as a function call
  : PACKAGE name IS NEW name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 statement-other 7 statement-end])
      (wisi-containing-action 4 5)
      (wisi-containing-action 5 6)
      (wisi-face-action [2 font-lock-function-name-face 5 font-lock-function-name-face]))
  | overriding_indicator_opt PROCEDURE name IS NEW name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 3 name 5 statement-other 8 statement-end])
      (wisi-containing-action 5 6)
      (wisi-containing-action 6 7)
      (wisi-face-action [3 font-lock-function-name-face 6 font-lock-function-name-face]))
  | overriding_indicator_opt FUNCTION name IS NEW name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 3 name 5 statement-other 8 statement-end])
      (wisi-containing-action 5 6)
      (wisi-containing-action 6 7)
      (wisi-face-action [3 font-lock-function-name-face 6 font-lock-function-name-face]))
  ;

generic_package_declaration
  : generic_formal_part package_specification SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 2 block-middle 3 statement-end])
      (wisi-motion-action [1 2]))
  ;

generic_renaming_declaration
 ;; keyword following generic is marked statement-other to support this indentation:
 ;;
 ;; generic
 ;; package foo renames
 ;;   bar;
 ;;
  : GENERIC PACKAGE name RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 3 name 4 statement-other 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-function-name-face 5 font-lock-function-name-face]))
  | GENERIC PROCEDURE name RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 3 name 4 statement-other 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-function-name-face 5 font-lock-function-name-face]))
  | GENERIC FUNCTION name RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 3 name 4 statement-other 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-function-name-face 5 font-lock-function-name-face]))
  ;

generic_subprogram_declaration
  : generic_formal_part subprogram_specification aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 2 block-middle 4 statement-end])
      (wisi-containing-action 2 3)
      (wisi-motion-action [1 2]))
  ;

goto_label
  : LESS_LESS IDENTIFIER GREATER_GREATER
    (wisi-face-action [2 font-lock-constant-face])
  ;

handled_sequence_of_statements
  : sequence_of_statements_opt EXCEPTION exception_handler_list_opt
    (progn
      (wisi-statement-action [2 block-middle])
      (wisi-containing-action 2 3))
  | sequence_of_statements_opt
  ;

identifier_list
  : IDENTIFIER
  | identifier_list COMMA IDENTIFIER
  ;

identifier_opt
  : ;; empty
  | IDENTIFIER
  ;

if_expression
  : IF expression_opt THEN expression_opt elsif_expression_list ELSE expression_opt
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 6 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 7)
      (wisi-motion-action [1 3 [5 statement-other ELSIF block-middle THEN] 6]))
  | IF expression_opt THEN expression_opt elsif_expression_list
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 3 5)
      (wisi-motion-action [1 3 [5 statement-other ELSIF block-middle THEN]]))
  | IF expression_opt THEN expression_opt ELSE expression_opt
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 5 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 5 6)
      (wisi-motion-action [1 3 5]))
  | IF expression_opt THEN expression_opt
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 3]))
  ;

if_statement
  : IF expression_opt THEN sequence_of_statements_opt elsif_statement_list ELSE sequence_of_statements_opt END IF SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 6 block-middle 8 block-end 10 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 7)
      (wisi-motion-action [1 3 [5 statement-other ELSIF block-middle THEN] 6 8]))
  | IF expression_opt THEN sequence_of_statements_opt elsif_statement_list END IF SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 6 block-end 8 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 3 5)
      (wisi-motion-action [1 3 [5 statement-other ELSIF block-middle THEN] 6]))
  | IF expression_opt THEN sequence_of_statements_opt ELSE sequence_of_statements_opt END IF SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 5 block-middle 7 block-end 9 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-containing-action 5 6)
      (wisi-motion-action [1 3 5 7]))
  | IF expression_opt THEN sequence_of_statements_opt END IF SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 3 5]))
  ;

incomplete_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS TAGGED SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 6 statement-end])
      (wisi-containing-action 1 3)
      (wisi-face-action [2 font-lock-type-face]))
  | TYPE IDENTIFIER discriminant_part_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 3 statement-end])
      (wisi-face-action [2 font-lock-type-face]))
  ;

index_constraint
  : LEFT_PAREN discrete_subtype_definition_list RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

index_subtype_definition : name RANGE BOX ;

index_subtype_definition_list
  : index_subtype_definition
  | index_subtype_definition_list COMMA index_subtype_definition
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

interface_list
  : name
    (wisi-face-action [1 font-lock-type-face])
  | interface_list AND name
    (wisi-face-action [3 font-lock-type-face])
  ;

interface_type_definition
  : LIMITED INTERFACE AND interface_list
  | TASK INTERFACE AND interface_list
  | PROTECTED INTERFACE AND interface_list
  | SYNCHRONIZED INTERFACE AND interface_list
  | LIMITED INTERFACE
  | TASK INTERFACE
  | PROTECTED INTERFACE
  | SYNCHRONIZED INTERFACE
  | INTERFACE
;

iteration_scheme
  : WHILE expression_opt
    (progn
      (wisi-statement-action [1 statement-start])
      (wisi-containing-action 1 2))
  | FOR iterator_specification_opt
    (progn
      (wisi-statement-action [1 statement-start])
      (wisi-containing-action 1 2))
  ;

iterator_specification
 ;; also loop_parameter_specification, to avoid redundancy bewteen
 ;; iterator_specification_opt and loop_parameter_specification_opt
 ;;
  : IDENTIFIER IN REVERSE discrete_subtype_definition
  | IDENTIFIER IN discrete_subtype_definition
  | IDENTIFIER COLON subtype_indication OF REVERSE name
  | IDENTIFIER COLON subtype_indication OF name
  | IDENTIFIER OF REVERSE name
  | IDENTIFIER OF name
  ;

iterator_specification_opt
  : ;; empty
  | iterator_specification
  ;

label_opt
 ;; goto and block/loop labels merged into label_opt because
 ;; indentation code treats them equally.

  : ;; empty
  | goto_label
    (wisi-statement-action [1 label])
  | IDENTIFIER COLON ;; on blocks, loops
    (wisi-statement-action [1 label])
  ;

library_item
  : PRIVATE library_unit_declaration
  | library_unit_declaration
  | subprogram_body ;; library_unit_body
  | package_body ;; library_unit_body
 ;; | PRIVATE library_unit_renaming_declaration
  | library_unit_renaming_declaration
  ;

library_unit_declaration
  : subprogram_declaration
  | package_declaration
  | generic_declaration
  | generic_instantiation
  ;

library_unit_renaming_declaration
  : package_renaming_declaration
  | generic_renaming_declaration
  | subprogram_renaming_declaration
  ;

loop_statement
  : iteration_scheme LOOP sequence_of_statements_opt END LOOP identifier_opt SEMICOLON
 ;; label_opt included in statement
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 4 block-end 7 statement-end])
      (wisi-containing-action 2 3)
      (wisi-motion-action [1 2 4]))
  | LOOP sequence_of_statements_opt END LOOP identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-end 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 3]))
  ;

membership_choice_list
  : membership_choice
  | membership_choice_list BAR membership_choice
  ;

membership_choice
  : simple_expression
 ;; ARM has choice_expression here, but that leads to a shift/reduce conflict, because of the following productions:
 ;; membership_choice_list => membership_choice => choice_expression => choice_relation_and_list
 ;; relation => simple_expression IN choice_relation_and_list
 ;; thus choice_relation_and_list AND could be followed by relation (=> reduce) or choice_relation (=> shift)
 ;; This only occurs in legal Ada in expressions such as True in 1 and 3; not useful, so we leave it out.
  | range
 ;;  | name ;; subtype_mark - covered by simple_expression
  ;

mod_clause_opt
  : ;; empty
  | AT MOD expression_opt SEMICOLON
  ;

mode_opt
  : ;; empty
  | IN
  | IN OUT
  | OUT
  ;

multiplying_operator : STAR | SLASH | MOD | REM ; ;; * | / | mod | rem

name_list
  : name
  | name_list COMMA name
    (progn
      (wisi-statement-action [2 statement-other])
      (wisi-containing-action 2 3))
  ;

name
  : IDENTIFIER ;; from direct_name
    (wisi-statement-action [1 name])

  | CHARACTER_LITERAL ;; only in an expression, so no type or function-name face

 ;; | explicit_dereference
 ;; | indexed_component

 ;; ARM has name ( discrete_subtype_definition ) here, but that's
 ;; partly redundant with name actual_parameter_part; this is the
 ;; part that is not redundant.
  | name LEFT_PAREN range_list RIGHT_PAREN ;; slice or constraint
    (progn
      (wisi-statement-action [1 name-paren 2 open-paren 4 close-paren])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3))
  | selected_component
  | attribute_reference ;; starts with name
  | name actual_parameter_part
 ;; type_conversion, function_call, procedure call, generic instantiation.
    (progn
      (wisi-statement-action [1 name-paren])
      (wisi-containing-action 1 2))
  | qualified_expression ;; starts with name
  ;; | generalized_reference
  ;; | generalized_indexing
  | STRING_LITERAL ;; operator_symbol, designator
  ;

name_opt
  : ;; empty
  | name
  ;

null_exclusion_opt
  : ;; empty
  | NOT NULL
  ;

;; use _only_ to avoid a conflict between name and null_exclusion_opt; name must be a type
null_exclusion_opt_name_type
  : IDENTIFIER
    (wisi-face-action [1 font-lock-type-face])
  | selected_component
    (wisi-face-action [1 font-lock-type-face])
  | NOT NULL IDENTIFIER
    (wisi-face-action [3 font-lock-type-face])
  | NOT NULL selected_component
    (wisi-face-action [3 font-lock-type-face])
  ;

null_procedure_declaration
  : overriding_indicator_opt procedure_specification IS NULL aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 3 statement-other 6 statement-end])
      (wisi-containing-action 2 5))
  ;

object_declaration
  : identifier_list COLON aliased_opt constant_opt subtype_indication COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 6 statement-other 9 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 6 7)
      (wisi-containing-action 1 8))
  | identifier_list COLON aliased_opt constant_opt subtype_indication aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 7 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 1 6))

  | identifier_list COLON aliased_opt constant_opt access_definition COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 6 statement-other 9 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 6 7)
      (wisi-containing-action 1 8))
  | identifier_list COLON aliased_opt constant_opt access_definition aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 7 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 1 6))
  | identifier_list COLON aliased_opt constant_opt array_type_definition COLON_EQUAL expression_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 6 statement-other 9 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 6 7)
      (wisi-containing-action 1 8))
  | identifier_list COLON aliased_opt constant_opt array_type_definition aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 7 statement-end])
      (wisi-containing-action 2 5)
      (wisi-containing-action 1 6))
  | single_task_declaration
  | single_protected_declaration
  ;

object_renaming_declaration
  : IDENTIFIER COLON null_exclusion_opt name RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-other 8 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 6)
      (wisi-face-action [4 font-lock-type-face]))
  | IDENTIFIER COLON access_definition RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 4 statement-other 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 1 5)
      (wisi-containing-action 1 6))
  | IDENTIFIER COLON EXCEPTION RENAMES name aspect_specification_opt SEMICOLON ;; exception_renaming_declaration
    (progn
      (wisi-statement-action [1 statement-start 4 statement-other 7 statement-end])
      (wisi-containing-action 1 5)
      (wisi-containing-action 1 6))
  ;

;; operator_symbol is STRING_LITERAL, in name

overriding_indicator_opt
  : NOT OVERRIDING
    (wisi-statement-action [1 statement-start 2 statement-other])
  | OVERRIDING
    (wisi-statement-action [1 statement-start])
  | ;; empty - following keyword is statement-start
  ;

package_body
  : PACKAGE BODY name aspect_specification_opt IS declarative_part_opt BEGIN
    handled_sequence_of_statements END name_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 name 5 block-middle 7 block-middle
                                9 block-end 11 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 1 4)
      (wisi-containing-action 5 6)
      (wisi-containing-action 7 8)
      (wisi-containing-action 9 10)
      (wisi-motion-action [1 5 7 [8 block-middle EXCEPTION block-middle WHEN] 9])
      (wisi-face-action [3 font-lock-function-name-face 10 font-lock-function-name-face]))
  | PACKAGE BODY name aspect_specification_opt IS declarative_part_opt END name_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 name 5 block-middle 7 block-end 9 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 1 4)
      (wisi-containing-action 5 6)
      (wisi-containing-action 7 8)
      (wisi-motion-action [1 5 7])
      (wisi-face-action [3 font-lock-function-name-face 8 font-lock-function-name-face]))
  ;

package_body_stub
  : PACKAGE BODY name IS SEPARATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-function-name-face]))
  ;

package_declaration
  : package_specification SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  ;

package_renaming_declaration
  : PACKAGE name RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 3 statement-other 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 5)
      (wisi-face-action [2 font-lock-function-name-face 4 font-lock-function-name-face]))
  ;

package_specification
  : PACKAGE name aspect_specification_opt IS declarative_part_opt PRIVATE declarative_part_opt END name_opt
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-start 6 block-middle 8 block-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 6 7)
      (wisi-motion-action [1 4 6 8])
      (wisi-face-action [2 font-lock-function-name-face 9 font-lock-function-name-face]))
  | PACKAGE name aspect_specification_opt IS declarative_part_opt END name_opt
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-start 6 block-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 5)
      (wisi-motion-action [1 4 6])
      (wisi-face-action [2 font-lock-function-name-face 7 font-lock-function-name-face]))
  ;

parameter_and_result_profile
  : formal_part RETURN null_exclusion_opt name_opt
    (progn
      (wisi-statement-action [2 return-with-params]);; for ada-indent-return
      (wisi-containing-action 2 4)
      (wisi-face-action [4 font-lock-type-face]))
  | RETURN null_exclusion_opt name_opt
    (progn
      (wisi-statement-action [1 return-without-params])
      (wisi-face-action [3 font-lock-type-face]))
  | formal_part RETURN access_definition
    (progn
      (wisi-statement-action [2 return-with-params])
      (wisi-containing-action 2 3))
  | RETURN access_definition
    (progn
      (wisi-statement-action [1 return-without-params])
      (wisi-containing-action 1 2))
  ;

 ;; parameter_association is merged into association
 ;; parameter_association_list is merged into association_list

parameter_profile_opt
  : ;; empty
  | formal_part
  ;

parameter_specification
  : identifier_list COLON aliased_opt mode_opt null_exclusion_opt name COLON_EQUAL expression_opt
    (wisi-face-action [6 font-lock-type-face])
  | identifier_list COLON aliased_opt mode_opt null_exclusion_opt name
    (wisi-face-action [6 font-lock-type-face])
  | identifier_list COLON aliased_opt access_definition COLON_EQUAL expression_opt
  | identifier_list COLON aliased_opt access_definition
  ;

parameter_specification_list
  : parameter_specification
  | parameter_specification_list SEMICOLON parameter_specification
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

paren_expression
  : LEFT_PAREN expression_opt RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

pragma
  : PRAGMA IDENTIFIER LEFT_PAREN association_list RIGHT_PAREN SEMICOLON
 ;; ARM has 'pragma_argument_association'; this is a superset, and reduces redundancy
    (progn
      (wisi-statement-action [1 statement-start 3 open-paren 5 close-paren 6 statement-end])
      (wisi-containing-action 3 4)
      (wisi-face-action [2 font-lock-function-name-face]))
 ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | PRAGMA IDENTIFIER LEFT_PAREN conditional_quantified_expression RIGHT_PAREN SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 open-paren 5 close-paren 6 statement-end])
      (wisi-containing-action 3 4)
      (wisi-face-action [2 font-lock-function-name-face]))
  | PRAGMA IDENTIFIER SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-action [2 font-lock-function-name-face]))
  ;

;; prefix is name

primary
  : NUMERIC_LITERAL
    (wisi-face-action [1 font-lock-constant-face])
  | NULL
 ;; | STRING_LITERAL in name
  | aggregate
  | name
  | NEW name
 ;; allocator, leaving out subpool_specification. Valid overrides occur when 'name' is a
 ;; qualified_expression or selected_component.
    (wisi-face-action [2 font-lock-type-face] t)
 ;; | LEFT_PAREN expression RIGHT_PAREN ;; covered by aggregate
 ;; | LEFT_PAREN conditional_quantified_expression RIGHT_PAREN ; covered by aggregate
  ;

private_extension_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS abstract_limited_synchronized_opt NEW subtype_indication
    and_interface_list_opt WITH PRIVATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 statement-other 6 statement-other 12 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 6 7)
      (wisi-containing-action 6 8)
      (wisi-containing-action 4 11)
      (wisi-face-action [2 font-lock-type-face]))
  ;

private_type_declaration
  : TYPE IDENTIFIER discriminant_part_opt IS abstract_tagged_limited_opt PRIVATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 statement-other 8 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 4 7)
      (wisi-face-action [2 font-lock-type-face]))
  ;

procedure_call_statement
  : name SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  ;

procedure_specification
  : PROCEDURE name parameter_profile_opt
    (progn
      (wisi-statement-action [1 statement-other])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-face-action [2 font-lock-function-name-face]))
  ;

proper_body
  : subprogram_body
  | package_body
  | task_body
  | protected_body
  ;

protected_body
  : PROTECTED BODY IDENTIFIER aspect_specification_opt IS protected_operation_item_list_opt END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 name 5 block-middle 7 block-end 9 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 1 4)
      (wisi-containing-action 5 6)
      (wisi-motion-action [1 5 7])
      (wisi-face-action [3 font-lock-type-face 8 font-lock-type-face]))
  ;

protected_body_stub
  : PROTECTED BODY IDENTIFIER IS SEPARATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 1 3)
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-type-face]))
  ;

protected_definition
  : declarative_part_opt PRIVATE declarative_part_opt END identifier_opt
    (progn
      (wisi-statement-action [2 block-middle 4 block-end])
      (wisi-containing-action 2 3)
      (wisi-face-action [5 font-lock-type-face]))
  | declarative_part_opt END identifier_opt
    (progn
      (wisi-statement-action [2 block-end])
      (wisi-face-action [3 font-lock-type-face]))
  ;

protected_operation_item
  : subprogram_declaration
  | subprogram_body
  | entry_body
  | expression_function_declaration
  | null_procedure_declaration
  | aspect_clause
  ;

protected_operation_item_list
  : protected_operation_item
  | protected_operation_item_list protected_operation_item
  ;

protected_operation_item_list_opt
  : ;; empty
  | protected_operation_item_list
  ;

protected_opt
  : ;; empty
  | PROTECTED
  ;

protected_type_declaration
  : PROTECTED TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS NEW interface_list WITH
    protected_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 6 block-middle 9 block-middle 11 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 10)
      (wisi-face-action [3 font-lock-type-face]))
  | PROTECTED TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS protected_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 6 block-middle 8 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 7)
      (wisi-face-action [3 font-lock-type-face]))
  ;

;; protected_operation_declaration merged into declaration

qualified_expression
  : name TICK aggregate
    (progn
      (wisi-statement-action [1 statement-other])
      (wisi-containing-action 1 3)
      (wisi-face-action [1 font-lock-type-face]))
  ;

quantified_expression
  : FOR quantifier iterator_specification EQUAL_GREATER expression_opt
    (progn
      (wisi-statement-action [1 expression-start])
      (wisi-containing-action 1 5))
  ;

quantifier : ALL | SOME ;

;; http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ai12s/ai12-0022-1.txt?rev=1.13
;; adds raise_expression
raise_expression
  : RAISE name
  | RAISE name WITH expression_opt
  ;

raise_statement
  : RAISE SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  | RAISE name WITH expression_opt SEMICOLON
 ;; no need to tag WITH; that just confuses the indentation logic
    (progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 4))
  | RAISE name SEMICOLON
    (wisi-statement-action [1 statement-start 3 statement-end])
  ;

range
  : name TICK RANGE LEFT_PAREN expression_opt RIGHT_PAREN ;; range_attribute_reference
    (progn
      (wisi-statement-action [4 open-paren 6 close-paren])
      (wisi-containing-action 4 5))
  | name TICK RANGE ;; range_attribute_reference
  | simple_expression DOT_DOT simple_expression
  ;

range_list
  : range
  | range_list COMMA range
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

real_range_specification_opt
  : ;; empty
  | RANGE simple_expression DOT_DOT simple_expression
  ;

record_definition
  : RECORD component_list_opt END RECORD
    (progn
      (wisi-statement-action [1 block-start 3 block-end])
      (wisi-containing-action 1 2))
  | NULL RECORD
  ;

record_representation_clause
  : FOR name USE record_rep SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4)
      (wisi-face-action [2 font-lock-type-face]))
  ;

record_rep
  : RECORD mod_clause_opt component_clause_list END RECORD
 ;; split from record_representation_clause to get containing right.
    (progn
      (wisi-statement-action [1 block-start 4 block-end])
      (wisi-containing-action 1 3))
  ;

record_type_definition
  : abstract_tagged_limited_opt record_definition
  ;

relation_and_list
  : relation AND relation
  | relation_and_list AND relation
  ;

relation_and_then_list
  : relation AND THEN relation
  | relation_and_then_list AND THEN relation
  ;

relation_or_list
  : relation OR relation
  | relation_or_list OR relation
  ;

relation_or_else_list
  : relation OR ELSE relation
  | relation_or_else_list OR ELSE relation
  ;

relation_xor_list
  : relation XOR relation
  | relation_xor_list XOR relation
  ;

;; http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ai12s/ai12-0022-1.txt?rev=1.13
;; adds raise_expression
relation
  : simple_expression
  | simple_expression relational_operator simple_expression
  | simple_expression NOT IN membership_choice_list
  | simple_expression IN membership_choice_list
  | raise_expression
  ;

relational_operator
  : EQUAL | SLASH_EQUAL | LESS | LESS_EQUAL | GREATER | GREATER_EQUAL ;
  ;;  =   | /=          | <    |  <=        | >       | >=

renaming_declaration
  : object_renaming_declaration ;; includes exception_renaming_declaration
  | package_renaming_declaration
  | subprogram_renaming_declaration
  | generic_renaming_declaration
  ;

requeue_statement
  : REQUEUE name WITH ABORT SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 5 statement-end])
      (wisi-containing-action 1 2))
  | REQUEUE name SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 3 statement-end])
      (wisi-containing-action 1 2))
  ;

return_subtype_indication
  : subtype_indication
  | access_definition
  ;

selected_component
  : name DOT IDENTIFIER
    (wisi-extend-action 1 3)
  | name DOT CHARACTER_LITERAL

  | name DOT STRING_LITERAL
 ;; operator_symbol. STRING_LITERAL has text property 'face
 ;; 'font-lock-string-face set by something else (not
 ;; ada-mode-font-lock-keywords); this grammar gives it
 ;; 'font-lock-face 'font-lock-function-name-face. 'face wins, which
 ;; is the result we want.

  | name DOT ALL
 ;; explicit_dereference. Similarly here; ada-mode-font-lock-keywords
 ;; gives ALL 'face 'font-lock-keyword-face, this grammar gives it
 ;; 'font-lock-function-name-face.
  ;

;; selector_name - IDENTIFIER, STRING_LITERAL overlap name; CHARACTER_LITERAL used separately
;;  : IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL ; ;; operator_symbol

selective_accept
  : SELECT select_alternative_list_opt ELSE sequence_of_statements_opt END SELECT SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 7 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4)
      (wisi-motion-action [1 [2 block-middle OR] 3 5]))
  | SELECT select_alternative_list_opt END SELECT SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-end 5 statement-end])
      (wisi-containing-action 1 2)
      (wisi-motion-action [1 [2 block-middle OR] 3]))
  ;

select_alternative
 ;; we can't use guard_opt here because when present a guard is a
 ;; block-start, but when absent there is no block-start
  : WHEN expression_opt EQUAL_GREATER accept_statement sequence_of_statements_opt ;; guard accept_alternative
    (progn
      (wisi-statement-action [1 block-start 3 statement-other])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-containing-action 1 4)
      (wisi-containing-action 1 5))
  | accept_statement sequence_of_statements_opt ;; accept_alternative
  | WHEN expression_opt EQUAL_GREATER delay_alternative
    (progn
      (wisi-statement-action [1 block-start])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4))
  | delay_alternative
  | WHEN expression_opt EQUAL_GREATER TERMINATE SEMICOLON ;; terminate_alternative
    (progn
      (wisi-statement-action [1 block-start 4 statement-start 5 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4))
  | TERMINATE SEMICOLON ;; terminate_alternative
    (wisi-statement-action [1 statement-start 2 statement-end])
  ;

select_alternative_list
  : select_alternative
  | select_alternative_list OR select_alternative
    (wisi-statement-action [2 block-middle])
  ;

select_alternative_list_opt
  : ;; empty
  | select_alternative_list
  ;

select_statement
  : selective_accept
  | timed_entry_call
  | conditional_entry_call
  | asynchronous_select
  ;

sequence_of_statements
  : statement
  | sequence_of_statements statement
  | sequence_of_statements goto_label ;; ignoring list of labels
  ;

;; Wherever the ARM requires a sequence_of_statements, we allow
;; nothing; this simplifies indenting skeletons (see ada-skel), and is
;; more user-friendly for indenting while editing.
sequence_of_statements_opt
  : ;; empty
  | sequence_of_statements
  ;

simple_expression
  : unary_adding_operator term_list
  | term_list
  ;

simple_return_statement
  : RETURN SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  | RETURN expression_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-containing-action 1 2))
  ;

simple_statement
  : NULL SEMICOLON;; null_statement
    (wisi-statement-action [1 statement-start 2 statement-end])
  | assignment_statement
  | exit_statement
  | GOTO IDENTIFIER SEMICOLON ;; goto_statement
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-face-action [2 font-lock-constant-face]))
  | procedure_call_statement
  | simple_return_statement
 ;; | entry_call_statement ; covered by procedure_call_statement
  | requeue_statement
  | delay_statement
  | ABORT name SEMICOLON ;; abort_statement; ignoring list of tasks
    (wisi-statement-action [1 statement-start 3 statement-end])
  | raise_statement
  ;; | code_statement
  | pragma
  ;

single_protected_declaration
  : PROTECTED IDENTIFIER aspect_specification_opt IS NEW interface_list WITH protected_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-middle 7 block-middle 9 statement-end])
      (wisi-motion-action [1 4 [8 block-middle PRIVATE block-end END]])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 6)
      (wisi-containing-action 7 8)
      (wisi-face-action [2 font-lock-type-face]))
  | PROTECTED IDENTIFIER aspect_specification_opt IS protected_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-middle 6 statement-end])
      (wisi-motion-action [1 4 [5 block-middle PRIVATE block-end END]])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 5)
      (wisi-face-action [2 font-lock-type-face]))
;

single_task_declaration
  : TASK IDENTIFIER aspect_specification_opt IS NEW interface_list WITH task_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-middle 7 block-middle 9 statement-end])
      (wisi-motion-action [1 4 [8 block-middle PRIVATE block-end END]])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 6)
      (wisi-containing-action 7 8)
      (wisi-face-action [2 font-lock-type-face]))
  | TASK IDENTIFIER aspect_specification_opt IS task_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 block-middle 6 statement-end])
      (wisi-motion-action [1 4 [5 block-middle PRIVATE block-end END]])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 5)
      (wisi-face-action [2 font-lock-type-face]))
  | TASK IDENTIFIER aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 4 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 3)
      (wisi-face-action [2 font-lock-type-face]))
  ;

;; ignoring list of labels on one statement
statement
  : label_opt simple_statement
    (wisi-statement-action [2 statement-start])
  | label_opt compound_statement
    (wisi-statement-action [2 statement-start])
  ;

subprogram_body
  : overriding_indicator_opt subprogram_specification aspect_specification_opt IS declarative_part_opt BEGIN
    handled_sequence_of_statements END name_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 4 block-middle 6 block-middle 8 block-end 10 statement-end])
      (wisi-containing-action 2 3)
      (wisi-containing-action 4 5)
      (wisi-containing-action 6 7)
      (wisi-motion-action [1 2 4 6 8])
      (wisi-face-action [9 font-lock-function-name-face]))
  ;

subprogram_body_stub
  : overriding_indicator_opt subprogram_specification IS SEPARATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 6 statement-end])
      (wisi-containing-action 2 5))
  ;

subprogram_declaration
  : overriding_indicator_opt subprogram_specification aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 4 statement-end])
      (wisi-containing-action 2 3))
  ;

subprogram_default
  : name
    (wisi-face-action [1 font-lock-function-name-face])
  | BOX
  | NULL ;

subprogram_renaming_declaration
  : overriding_indicator_opt subprogram_specification RENAMES name aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 block-middle 3 statement-other 6 statement-end])
      (wisi-containing-action 2 5)
      (wisi-face-action [4 font-lock-function-name-face]))
  ;

subprogram_specification
  : procedure_specification
  | function_specification
  ;

subtype_declaration
  : SUBTYPE IDENTIFIER IS subtype_indication aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 name 3 statement-other 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 2 3)
      (wisi-containing-action 3 4)
      (wisi-containing-action 3 5)
      (wisi-face-action [2 font-lock-type-face]))
  ;

subtype_indication
  : NOT NULL name constraint
    (progn
      (wisi-containing-action 3 4)
      (wisi-face-action [3 font-lock-type-face]))
  | NOT NULL name
    (wisi-face-action [3 font-lock-type-face])
  | name constraint
    (progn
      (wisi-containing-action 1 2)
      (wisi-face-action [1 font-lock-type-face]))
  | name
    (wisi-face-action [1 font-lock-type-face])
  ;

;; subtype_mark replaced by name

subunit
  : SEPARATE LEFT_PAREN name RIGHT_PAREN proper_body
    (progn
      (wisi-statement-action [1 block-start 2 open-paren 4 close-paren 5 block-middle])
      (wisi-containing-action 1 5)
      (wisi-containing-action 2 3))
  ;

task_body
  : TASK BODY IDENTIFIER aspect_specification_opt IS declarative_part_opt BEGIN handled_sequence_of_statements END
    identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 5 block-start 7 block-middle 9 block-end 11 statement-end])
      (wisi-containing-action 3 4)
      (wisi-containing-action 5 6)
      (wisi-containing-action 7 8)
      (wisi-motion-action [1 5 7 9])
      (wisi-face-action [3 font-lock-type-face 10 font-lock-type-face]))
  ;

task_body_stub
  : TASK BODY IDENTIFIER IS SEPARATE aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-containing-action 3 6)
      (wisi-face-action [3 font-lock-type-face]))
  ;

task_definition
  : declarative_part_opt PRIVATE declarative_part_opt END identifier_opt
    (progn
      (wisi-statement-action [2 block-middle 4 block-end])
      (wisi-containing-action 2 3)
      (wisi-face-action [5 font-lock-type-face]))
  | declarative_part_opt END identifier_opt
    (progn
      (wisi-statement-action [2 block-end])
      (wisi-face-action [3 font-lock-type-face]))
  ;

;; task_item replaced by declaration

task_type_declaration
  : TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS NEW interface_list WITH task_definition
    SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 6 block-middle 9 block-middle 11 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 10)
      (wisi-face-action [3 font-lock-type-face]))
  | TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt IS task_definition SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 6 block-middle 8 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 3 5)
      (wisi-containing-action 6 7)
      (wisi-face-action [3 font-lock-type-face]))
  | TASK TYPE IDENTIFIER discriminant_part_opt aspect_specification_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 name 6 statement-end])
      (wisi-containing-action 1 4)
      (wisi-containing-action 3 5)
      (wisi-face-action [3 font-lock-type-face]))
  ;

term
  : factor
  | term multiplying_operator factor
  ;

term_list
  : term
  | term_list binary_adding_operator term
  ;

timed_entry_call
  : SELECT entry_call_alternative OR delay_alternative END SELECT SEMICOLON
    (progn
      (wisi-statement-action [1 block-start 3 block-middle 5 block-end 6 statement-end])
      (wisi-containing-action 1 2)
      (wisi-containing-action 3 4))
  ;

triggering_alternative
  : procedure_call_statement sequence_of_statements_opt
  | name sequence_of_statements_opt ;; entry_call_statement
  | delay_statement sequence_of_statements_opt
  ;

type_declaration
  : full_type_declaration
  | incomplete_type_declaration
  | private_type_declaration
  | private_extension_declaration
  ;

type_definition
  : enumeration_type_definition
  | RANGE simple_expression DOT_DOT simple_expression ;; integer_type_definition
  | MOD expression_opt
  | DIGITS expression_opt real_range_specification_opt ;; real_type_definition, floating_point_type_definition
  | DELTA expression_opt real_range_specification_opt ;; ordinary_fixed_point_definition
  | DELTA expression_opt DIGITS expression_opt real_range_specification_opt ;; decimal_fixed_point_definition
  | array_type_definition
  | record_type_definition
  | access_definition ;; access_type_definition
  | derived_type_definition
  | interface_type_definition
  ;

variant_part
  : CASE direct_name_opt IS variant_list END CASE SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-start 5 block-end 7 statement-end])
      (wisi-containing-action 3 4))
  ;

variant_list
  : variant
  | variant_list variant
  ;

variant
  : WHEN discrete_choice_list EQUAL_GREATER component_list_opt
    (progn
      (wisi-statement-action [1 block-middle])
      (wisi-containing-action 1 2)
      (wisi-containing-action 1 4))
  ;

unary_adding_operator : PLUS | MINUS ; ;; + | -

use_clause
  : USE name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-containing-action 1 2)
      (wisi-face-list-action [2 font-lock-function-name-face]))
  | USE ALL TYPE name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 4)
      (wisi-face-list-action [4 font-lock-type-face]))
  | USE TYPE name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-containing-action 1 3)
      (wisi-face-list-action [3 font-lock-type-face]))
  ;

with_clause
  : LIMITED PRIVATE WITH name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4)
      (wisi-face-list-action [4 font-lock-function-name-face]))
  | LIMITED WITH name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 4 statement-end])
      (wisi-containing-action 2 3)
      (wisi-face-list-action [3 font-lock-function-name-face]))
  | PRIVATE WITH name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 2 statement-other 4 statement-end])
      (wisi-containing-action 2 3)
      (wisi-face-list-action [3 font-lock-function-name-face]))
  | WITH name_list SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-containing-action 1 2)
      (wisi-face-list-action [2 font-lock-function-name-face]))
  ;

%%

;; Local Variables:
;; eval: (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
;; End:
;;; end of file
