;;; WisiToken grammar for Ada -*- wisi-partial-parse-threshold: 30000 wisi-process-time-out: 30.0 wisi-branched-tree-limit: 2000 -*-
;;
;; Author: Stephen Leake <stephe-leake@stephe-leake.org>
;; Maintainer: Stephen Leake <stephe-leake@stephe-leake.org>
;; Created: Sept 2012
;; Keywords: syntax
;;
;;  Copied from Ada Language Reference Manual Annex P
;;  (http://www.ada-auth.org/standards/ada2x.html), minimal changes
;;  made to conform with WisiToken requirements.

;;  Changes from Annex P:
;;
;;  for WisiToken:
;;
;;  - add single quotes around literal tokens, operators and reserved words, digits.
;;
;;  - delete italics part of token names
;;
;;  - eliminate many redundancies which cause parse conflicts
;;
;;  - replace low level lexical productions with regular expression tokens.
;;
;;  - use nonterminal "tick" for '''.

;; The programs 'annex_p_to_wy.adb' translates the text of ARM Annex P
;; to a WisiToken .wy file, and 'compare_annex_p.adb' compares that
;; with this file. Nonterminals that are changed in this file from ARM
;; Annex P have comments explaining how. Some comments are recognized
;; by 'compare_annex_p.adb' to help with the comparison; see the code
;; for more detail.

%meta_syntax EBNF

%code copyright_license %{
;;  Copyright (C) 2013 - 2020 Free Software Foundation, Inc.

;;  This program is free software; you can redistribute it and/or
;;  modify it under the terms of the GNU General Public License as
;;  published by the Free Software Foundation; either version 3, or (at
;;  your option) any later version.
;;
;;  This software is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;  General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
}%

%code actions spec post
%{
   Partial_Parse_Active    : Boolean := False;
   Partial_Parse_Byte_Goal : WisiToken.Buffer_Pos := WisiToken.Buffer_Pos'Last;
}%

%generate LALR Ada_Emacs re2c Process
%generate LR1 Ada_Emacs text_rep re2c Process

%lr1_hash_table_size 124_087

;; The addition of declare_expression caused a massive increase in recursion
%partial_recursion
%case_insensitive
%start compilation

%token <left-paren>  LEFT_PAREN  "("
%token <right-paren> RIGHT_PAREN ")"
%token <left-paren>  LEFT_SQUARE_BRACKET  "["
%token <right-paren> RIGHT_SQUARE_BRACKET "]"

%token <punctuation> AMPERSAND "&"
%token <punctuation> AT_SIGN "@"
%token <punctuation> BAR "|"
%token <punctuation> BOX "<>"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUAL ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> DOT_DOT ".."
%token <punctuation> EQUAL "="
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> GREATER ">"
%token <punctuation> GREATER_EQUAL ">="
%token <punctuation> GREATER_GREATER ">>"
%token <punctuation> LESS "<"
%token <punctuation> LESS_EQUAL "<="
%token <punctuation> LESS_LESS "<<"
%token <punctuation> MINUS "-"
%token <punctuation> PLUS "+"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> SLASH_EQUAL "/="
%token <punctuation> STAR "*"
%token <punctuation> STAR_STAR "**"

;; Support GNAT character coding in names and character and string
;; literals (see test/non_ascii.ads)
%if lexer = re2c
%lexer_regexp GNAT_Char_Coding %[ ("[\""[0-9A-Fa-f]+"\"]") ]%
%elsif lexer = tree_sitter
%lexer_regexp GNAT_Char_Coding %[ (\["[0-9A-Fa-f]+"\]) ]%
%end if

%if lexer = re2c
;; re2c lookahead regular expression; this is not a character literal.
;; re2c does not allow combining | with /, so we need three tokens for
;; this (sigh). See wisitoken test character_literal.wy for rationale
;; behind this design.
%token <punctuation> TICK_1 "'"

%token <regexp> TICK_2
    %[ "'" / "('"([\x20-\U0010FFFF]|GNAT_Char_Coding)"'" ]%
  "'"
tick : TICK_1 | TICK_2 ;

%elsif lexer = tree_sitter
;; FIXME:
;; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet Negative lookahead assertion:
%token <punctuation> tick "'"
%end if

;; This regexp allows a lot of things that are not Ada numeric
;; literals, but it's faster than a strictly conforming regexp. For
;; non-based literals, force a trailing integer so (1..Length) is
;; parsed correctly.
%if lexer = re2c
%token <regexp> NUMERIC_LITERAL
    %[ ([0-9])|([0-9][0-9eE._-]*[0-9])|([0-9]+"#"[0-9a-fA-F._-]+"#") ]%
  "1234567890"

%elsif lexer = tree_sitter
%token <regexp> NUMERIC_LITERAL
    %[ ([0-9])|([0-9][0-9eE._-]*[0-9])|([0-9]+#[0-9a-fA-F._-]+#) ]%
  "1234567890"
%end if

;; non_grammar are not seen by the elisp lexer, but are needed by the re2c lexer
%non_grammar <non-reporting> WHITESPACE %[ [ \t]+ ]%

;; handle DOS or Unix newline
%non_grammar <new-line> NEW_LINE %[ [\x0a]|[\x0d][\x0a] ]%

;; Treat Ada comments, gnatprep preprocessor lines, and skeleton
;; placeholders as comments. Also terminate placeholder on newline,
;; EOF, to handle missing }. x04 is EOF.
%if lexer = re2c
%non_grammar <comment> COMMENT %[ (("--"|"#if"|"#elsif"|"#else"|"#end")[^\n\x04]*)|("{"[^}\n\x04]*) ]%

%elsif lexer = tree_sitter
%non_grammar <comment> COMMENT %[ ((--|#if|#elsif|#else|#end)[^\n\x04]*)|({[^}\n\x04]*) ]%
%end if

%if lexer = re2c
;; '$' for gnatprep symbols.
%token <symbol> IDENTIFIER
    %[ ([$a-zA-Z\x80-\U0010FFFF]|GNAT_Char_Coding)([0-9a-zA-Z_\x80-\U0010FFFF]|GNAT_Char_Coding)* ]%
  "A_Bogus_Identifier"

;; \x22 is "
%token <string-double> STRING_LITERAL
    %[ (["]([\x20-\x21\x23-\U0010FFFF]|GNAT_Char_Coding)*["])+ ]% '""'

%token <string-single> CHARACTER_LITERAL %[ "'"([\x20-\U0010FFFF]|GNAT_Char_Coding)"'" ]% "' '"

%elsif lexer = tree_sitter
;; FIXME: limited by JavaScript and tree-sitter; see tree-sitter
;; github issue #621.
;;
;; FIXME: need pi, GNAT_Char_Coding for parsing ada-mode tests.
;; Leaving out pi for now to get byte_pos = char_pos.
%token <symbol> IDENTIFIER %[ [$a-zA-Z][Ï€0-9a-zA-Z_]* ]%
%token <string-double> STRING_LITERAL %[ ("[\x20-\x21\x23-\x7F]*")+ ]%
%token <string-single> CHARACTER_LITERAL %[ '[\x20-\x21\x23-\x7F]' ]%
%end if

%elisp_face font-lock-constant-face
%elisp_face font-lock-function-name-face
%elisp_face font-lock-type-face
%elisp_face nil

%elisp_indent ada-indent-aggregate Ada_Indent_Aggregate
%elisp_indent ada-indent-renames Ada_Indent_Renames_0
%elisp_indent ada-indent-return Ada_Indent_Return_0
%elisp_indent ada-indent-record Ada_Indent_Record_0
%elisp_indent "ada-indent-record*" Ada_Indent_Record_1
%elisp_indent ada-indent-anchored-expression Ada_Indent_Anchored_Expression

;; Set McKenzie error recovery costs.
;;
;; We assume the user is typing new code more often than deleting or
;; changing old. Minimal_Complete reduces cost for insert, so the
;; default cost for insert, delete is the same. Often insert requires
;; push_back first, to get the parser in the right state, so push_back
;; is cheaper.
;;
;; We need a balance between Minimal_Complete and other solutions; if
;; Minimal_Complete is too cheap, it will complete the entire
;; compilation_Unit before the error point, when doing something else
;; at some point is better (see test/ada_mode-recover_29.adb, _15,
;; _24). On the other hand, doing lots of Minimal_Complete is very
;; common when writing new code (see test/ada_mode-recover_10.adb,
;; _error_during_resume_01). So we reduce the cost of inserting 'end
;; ;'.
;;
;; test/ada_mode-recover_change_name.adb needs 'ignore check fail' cost 2
;;
;; Default cost for insert, delete, push back/undo_reduce, ignore check fail.
%mckenzie_cost_default 4 4 2 2
%mckenzie_minimal_complete_cost_delta -3

;; END is cheaper, because it always requires at least one other
;; keyword to follow.
%mckenzie_cost_insert END 3

;; This cost is applied once, independent of token count.
%mckenzie_cost_matching_begin 3

;; Prefer doing more work at the current error point over moving
;; forward to a new one; there is normally only one real error point.
;; But not too much; test/ada_mode-recover_partial_02_lr1.adb requires
;; cost 2.
%mckenzie_cost_fast_forward 2

;; Handle converting 'if' to 'case' (and vice-versa), since that is a
;; common operation. See test/ada_mode-recover_29.adb. This also makes
;; inserting 'end if;' free; that's used a lot. But this defeats
;; Forbid_Minimal_Complete; see
;; test/ada_mode-recover_constant_as_statement_1.adb.
%mckenzie_cost_insert CASE 2
%mckenzie_cost_insert IF 2

;; Prefer undo_reduce over push_back; consider the code:
;;
;; loop
;;    if then
;;       statement;
;;    -- missing 'end if;'
;; end loop;
;; -- ^ error here
;;
;; Error recovery will insert 'end if;', after push_back or
;; undo_reduce of the handled_sequence_of_statements including
;; 'statement'. If it uses push_back, then 'end if;' is before
;; 'statement'; if undo_reduce, after, which is the desired result.
%mckenzie_cost_undo_reduce handled_sequence_of_statements 0
%mckenzie_cost_undo_reduce sequence_of_statements 0
%mckenzie_cost_undo_reduce sequence_of_statements 0
%mckenzie_cost_undo_reduce declarative_part 0

;; Missing or extra closing paren are common; missing handled by
;; Minimal_Complete.
%mckenzie_cost_delete RIGHT_PAREN 1

;; test/ada_mode-recover_partial_02_lr1.adb requires 45_000; wisitoken got 30% faster
%mckenzie_enqueue_limit 58_000

;; 4 required for test/ada_mode-recover_match_names.adb.
%mckenzie_check_limit 4

;; After finding 1 solution, only check 100 more before giving up.
;; Reduces solution time on complex errors.
%mckenzie_check_delta_limit 100

%end_names_optional_option End_Names_Optional

%conflict REDUCE defining_identifier_list | REDUCE IDENTIFIER_COMMA_list on token COMMA (472)
%conflict REDUCE defining_identifier_list | REDUCE direct_name on token COMMA
%conflict REDUCE direct_name | REDUCE selector_name on token BAR
%conflict REDUCE direct_name | REDUCE selector_name on token EQUAL_GREATER
%conflict REDUCE discrete_choice | REDUCE component_choice_list on token EQUAL_GREATER
%conflict REDUCE discriminant_association | REDUCE explicit_actual_parameter on token COMMA
%conflict REDUCE explicit_actual_parameter | REDUCE explicit_generic_actual_parameter on token COMMA
%conflict REDUCE explicit_actual_parameter | REDUCE explicit_generic_actual_parameter on token RIGHT_PAREN
%conflict REDUCE iterator_parameter_association | REDUCE parameter_association_list on token COMMA
%conflict REDUCE iterator_parameter_association | REDUCE parameter_association_list on token RIGHT_PAREN
%conflict REDUCE name | REDUCE selector_name on token BAR
%conflict REDUCE name | REDUCE selector_name on token EQUAL_GREATER
%conflict REDUCE primary | REDUCE global_aspect_definition on token COMMA
%conflict REDUCE primary | REDUCE global_aspect_definition on token IS
%conflict REDUCE primary | REDUCE global_aspect_definition on token SEMICOLON
%conflict REDUCE primary | REDUCE global_aspect_definition on token WHEN
%conflict REDUCE subtype_indication | REDUCE iterator_specification on token EQUAL_GREATER
%conflict REDUCE subtype_indication | REDUCE iterator_specification on token LOOP
%conflict REDUCE subtype_indication | REDUCE iterator_specification on token USE
%conflict REDUCE subtype_indication | REDUCE primary on token BAR
%conflict REDUCE subtype_indication | REDUCE primary on token COMMA
%conflict REDUCE subtype_indication | REDUCE primary on token EQUAL_GREATER
%conflict SHIFT at_clause | REDUCE name on token USE
%conflict SHIFT attribute_definition_clause | REDUCE attribute_reference on token USE
%conflict SHIFT attribute_designator | REDUCE attribute_designator on token LEFT_PAREN
%conflict SHIFT binary_adding_operator | REDUCE simple_expression on token AMPERSAND
%conflict SHIFT binary_adding_operator | REDUCE simple_expression on token MINUS
%conflict SHIFT binary_adding_operator | REDUCE simple_expression on token PLUS
%conflict SHIFT digits_constraint | REDUCE subtype_indication on token DIGITS
%conflict SHIFT dispatching_operation_set | REDUCE extended_global_aspect_element on token COMMA
%conflict SHIFT expression_function_declaration | REDUCE record_component_association on token RIGHT_PAREN
%conflict SHIFT expression_function_declaration | REDUCE subprogram_specification on token IS
%conflict SHIFT factor | REDUCE factor on token STAR_STAR
%conflict SHIFT formal_derived_type_definition | REDUCE formal_derived_type_definition on token WITH
%conflict SHIFT full_type_declaration | REDUCE discriminant_part on token IS
%conflict SHIFT generic_instantiation | REDUCE parameter_profile on token IS
%conflict SHIFT generic_renaming_declaration | REDUCE generic_formal_part on token FUNCTION
%conflict SHIFT generic_renaming_declaration | REDUCE generic_formal_part on token PACKAGE
%conflict SHIFT generic_renaming_declaration | REDUCE generic_formal_part on token PROCEDURE
%conflict SHIFT global_set | REDUCE formal_parameter_set on token COMMA
%conflict SHIFT global_set | REDUCE global_aspect_element on token COMMA
%conflict SHIFT iterator_filter | REDUCE subtype_indication on token WHEN
%conflict SHIFT null_exclusion | REDUCE mode on token NOT
%conflict SHIFT null_procedure_declaration | REDUCE subprogram_specification on token IS
%conflict SHIFT object_renaming_declaration | REDUCE defining_identifier_list on token COLON
%conflict SHIFT object_renaming_declaration | REDUCE defining_identifier_list | REDUCE direct_name on token COLON
%conflict SHIFT package_body_stub | REDUCE direct_name on token IS
%conflict SHIFT parameter_association | REDUCE selector_name_list on token EQUAL_GREATER
%conflict SHIFT positional_array_aggregate | REDUCE expression_list on token COMMA
%conflict SHIFT positional_array_aggregate | REDUCE record_component_association | REDUCE expression_list on token COMMA
%conflict SHIFT pragma_argument_association | REDUCE aspect_mark on token EQUAL_GREATER
%conflict SHIFT primary | REDUCE record_component_association on token RIGHT_PAREN
%conflict SHIFT qualified_expression | REDUCE record_component_association on token RIGHT_PAREN
%conflict SHIFT raise_expression | REDUCE raise_expression on token WITH
%conflict SHIFT range_constraint | REDUCE delta_constraint on token RANGE
%conflict SHIFT range_constraint | REDUCE digits_constraint on token RANGE
%conflict SHIFT range_constraint | REDUCE subtype_indication on token RANGE
%conflict SHIFT record_extension_part | REDUCE derived_type_definition on token WITH
%conflict SHIFT tick | REDUCE direct_name on token TICK_1
%conflict SHIFT tick | REDUCE direct_name on token TICK_2
%conflict SHIFT type_conversion | REDUCE discriminant_association | REDUCE explicit_actual_parameter on token RIGHT_PAREN
%conflict SHIFT type_conversion | REDUCE explicit_actual_parameter on token RIGHT_PAREN
%conflict SHIFT type_conversion | REDUCE explicit_actual_parameter | REDUCE explicit_generic_actual_parameter on token RIGHT_PAREN
%conflict SHIFT type_conversion | REDUCE subtype_indication | REDUCE primary on token RIGHT_PAREN
%conflict SHIFT value_sequence | REDUCE array_component_association on token RIGHT_SQUARE_BRACKET (392)

%if parser in LALR | LR1
%conflict REDUCE formal_package_association | REDUCE generic_association_COMMA_list on token COMMA
%conflict REDUCE formal_package_association | REDUCE generic_association_COMMA_list on token RIGHT_PAREN
%conflict SHIFT multiplying_operator | REDUCE term_binary_adding_operator_list on token MOD
%conflict SHIFT multiplying_operator | REDUCE term_binary_adding_operator_list on token REM
%conflict SHIFT multiplying_operator | REDUCE term_binary_adding_operator_list on token SLASH
%conflict SHIFT multiplying_operator | REDUCE term_binary_adding_operator_list on token STAR
%conflict SHIFT slice | REDUCE discrete_range_list on token RIGHT_PAREN
%conflict SHIFT AND_choice_relation_list | REDUCE relation on token AND
%conflict SHIFT OR_choice_relation_list | REDUCE relation on token OR
%conflict SHIFT XOR_choice_relation_list | REDUCE relation on token XOR

%elsif parser = LALR
%conflict REDUCE subtype_indication | REDUCE primary on token RIGHT_PAREN

%elsif parser = Tree_Sitter
%conflict defining_identifier_list direct_name object_renaming_declaration exception_renaming_declaration
%conflict defining_identifier_list object_renaming_declaration exception_renaming_declaration
%conflict procedure_specification generic_instantiation
%conflict choice_expression relation
%conflict expression_list
%conflict attribute_designator reduction_attribute_designator
%conflict direct_name aspect_mark
%conflict derived_type_definition private_extension_declaration
%conflict component_list
%conflict simple_expression
%conflict term
%conflict subtype_indication
%conflict derived_type_definition
%conflict index_constraint slice
%conflict formal_parameter_set
%conflict dispatching_operation_set
%conflict global_set
%conflict digits_constraint
%conflict delta_constraint
%conflict subtype_indication primary type_conversion dispatching_operation_specifier
%conflict generic_actual_part formal_package_association
%end if

;;; grammar rules

pragma_g ::=
    'pragma' IDENTIFIER ['(' pragma_argument_association {',' pragma_argument_association} ')'] ';'

pragma_argument_association ::=
  ;; [ IDENTIFIER '=>' ] name ;; redundant with expression
    [IDENTIFIER '=>'] expression
  ;; aspect_mark '=>' name ;; redundant with expression
  | aspect_mark '=>'  expression

basic_declaration
  : type_declaration
  | subtype_declaration
  | object_declaration
  | number_declaration
  | subprogram_declaration
  | abstract_subprogram_declaration
  | null_procedure_declaration
  | expression_function_declaration
  | package_declaration
  | renaming_declaration
  | exception_declaration
  | generic_declaration
  | generic_instantiation
  ;

;; defining_identifier ;;:redundant with IDENTIFIER
;; ::= IDENTIFIER

type_declaration ::=  full_type_declaration
  | incomplete_type_declaration
  | private_type_declaration
  | private_extension_declaration

full_type_declaration
  : 'type' IDENTIFIER [known_discriminant_part] 'is' type_definition [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])

        ;; Indentation of comment after 'is' is
        ;; ada-indent-record-rel-type if type_definition is a record.
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken
                                 [ada-indent-broken (ada-indent-record* 'TYPE 5 ada-indent-broken)]
                                 (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                                 nil ada-indent-broken]))%
  | task_type_declaration
  | protected_type_declaration
  ;

type_definition ::=
    enumeration_type_definition
  | integer_type_definition
  | real_type_definition
  | array_type_definition
  | record_type_definition
  | access_type_definition
  | derived_type_definition
  | interface_type_definition

subtype_declaration ::=
    'subtype' IDENTIFIER 'is' subtype_indication [aspect_specification]';'

subtype_indication
  : [null_exclusion] name [constraint]
    %((wisi-face-apply-action [2 font-lock-function-name-face font-lock-type-face]))%
  ;

;; subtype_mark ::= name

constraint ::= scalar_constraint | composite_constraint

scalar_constraint ::= range_constraint | digits_constraint | delta_constraint

composite_constraint ::=
    index_constraint | discriminant_constraint

object_declaration
  : defining_identifier_list ':' ['aliased'] ['constant'] subtype_indication [':=' expression]
    [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                               ada-indent-broken
                               (wisi-anchored%- 6 ada-indent-broken)
                               ada-indent-broken ada-indent-broken]))%
  | defining_identifier_list ':' ['aliased'] ['constant'] access_definition [':=' expression]
    [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                               ada-indent-broken
                               (wisi-anchored% 6 ada-indent-broken)
                               ada-indent-broken ada-indent-broken]))%
  | defining_identifier_list ':' ['aliased'] ['constant'] array_type_definition [':=' expression]
      [aspect_specification]';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                               ada-indent-broken
                               (wisi-anchored% 6 ada-indent-broken)
                               ada-indent-broken ada-indent-broken]))%
  | single_task_declaration
  | single_protected_declaration

defining_identifier_list
  : IDENTIFIER
    %((wisi-name-action 1))%
  | defining_identifier_list ',' IDENTIFIER
    %((wisi-name-action 3)
        (wisi-indent-action [nil nil ada-indent-broken]))%
  ;

number_declaration
  : defining_identifier_list ':' 'constant' ':=' expression ';'
    %((wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-indent-action [(wisi-hanging nil ada-indent-broken) ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-anchored% 4 ada-indent-broken) ada-indent-broken]))%
  ;

derived_type_definition
  : ['abstract'] ['limited'] 'new' subtype_indication [['and' interface_list] record_extension_part] ;

range_constraint ::= 'range' range_g

range_g ::=
    range_attribute_reference
  | simple_expression '..' simple_expression
  ;

enumeration_literal_list ;;:new for action
  : enumeration_literal_specification {',' enumeration_literal_specification} ;

enumeration_type_definition
  : '(' enumeration_literal_list ')'
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

enumeration_literal_specification : IDENTIFIER | CHARACTER_LITERAL ;

;; defining_character_literal ::= CHARACTER_LITERAL

integer_type_definition : signed_integer_type_definition | modular_type_definition ;

signed_integer_type_definition ::= 'range' simple_expression  '..'  simple_expression

modular_type_definition ::= 'mod' expression

real_type_definition ::=
    floating_point_definition | fixed_point_definition

floating_point_definition ::= 'digits' expression [real_range_specification]

real_range_specification ::= 'range' simple_expression '..' simple_expression

fixed_point_definition ::= ordinary_fixed_point_definition |
    decimal_fixed_point_definition

ordinary_fixed_point_definition ::= 'delta' expression real_range_specification

decimal_fixed_point_definition ::= 'delta' expression 'digits' expression [real_range_specification]

digits_constraint ::= 'digits' simple_expression [range_constraint]

array_type_definition ::=
    unconstrained_array_definition | constrained_array_definition

index_subtype_definition_list : index_subtype_definition {',' index_subtype_definition} ;

unconstrained_array_definition
  : 'array' '(' index_subtype_definition_list ')' 'of' component_definition
    %((wisi-indent-action [nil nil (wisi-anchored 2 1) (wisi-anchored 2 0) nil nil]))%
  ;

index_subtype_definition : name 'range' '<>' ;

discrete_subtype_definition_list : discrete_subtype_definition {',' discrete_subtype_definition} ;

constrained_array_definition
  : 'array' '(' discrete_subtype_definition_list ')' 'of' component_definition
    %((wisi-indent-action [nil nil (wisi-anchored 2 1) (wisi-anchored 2 0) nil nil]))%
  ;

discrete_subtype_definition ::= subtype_indication | range_g

component_definition ::=
    ['aliased'] subtype_indication
  | ['aliased'] access_definition

discrete_range_list ;;:new for action
  : discrete_range {',' discrete_range} ;

index_constraint
  : '(' discrete_range_list ')'
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

discrete_range ::= subtype_indication | range_g

discriminant_part : unknown_discriminant_part | known_discriminant_part ;

unknown_discriminant_part : '(' '<>' ')' ;

discriminant_specification_list ;;:new for action
  : discriminant_specification {';' discriminant_specification} ;

known_discriminant_part
  : '(' discriminant_specification_list ')'
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

discriminant_specification
  : defining_identifier_list ':' [null_exclusion] name [':=' default_expression]
    %((wisi-face-apply-action [4 font-lock-function-name-face font-lock-type-face]))%
  | defining_identifier_list ':' access_definition [':=' default_expression]
  ;

default_expression ::= expression

discriminant_constraint ::= '(' discriminant_association {',' discriminant_association} ')'

selector_name_list ;;:new for action
  : selector_name {'|' selector_name} ;

discriminant_association
  : [selector_name_list '=>'] expression
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           (ada-indent-anchored-expression 2)]))%
  ;

record_type_definition ::= [['abstract'] 'tagged'] ['limited'] record_definition

record_definition ::=
    'record' component_list 'end' 'record' [IDENTIFIER]
  | 'null' 'record'

component_list
  : component_item {component_item}
  | {component_item} variant_part
  |  'null' ';'
    %((wisi-statement-action [1 statement-start 2 statement-end]))%
  ;

component_item ::= component_declaration | aspect_clause

component_declaration
  : defining_identifier_list ':' component_definition [':=' default_expression] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-anchored% 4 ada-indent-broken)
                               ada-indent-broken ada-indent-broken]))%
  ;

variant_part ::= 'case' direct_name 'is' variant {variant} 'end' 'case' ';'

variant ::= 'when' discrete_choice_list '=>' component_list

discrete_choice_list ::= discrete_choice {'|' discrete_choice}

discrete_choice ::= choice_expression | subtype_indication | range_g | 'others'

record_extension_part
  : 'with' record_definition
    ;; comment after 'with' same as 'record'
    %((wisi-indent-action [[nil (ada-indent-record* 'TYPE 6 0)] nil]))%
  ;

abstract_subprogram_declaration
  : [overriding_indicator] subprogram_specification 'is' 'abstract' [aspect_specification] ';'
    %((wisi-statement-action [statement-start statement-override statement-end])
(wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

interface_type_definition ::=
    ['limited' | 'task' | 'protected' | 'synchronized'] 'interface' ['and' interface_list]

interface_list
  : name ;;:new for action
    %((wisi-face-apply-action [1 font-lock-function-name-face font-lock-type-face]))%
  | interface_list AND name ;;:new for action
    %((wisi-face-apply-action [3 font-lock-function-name-face font-lock-type-face]))%
  ;

access_type_definition ::=
    [null_exclusion] access_to_object_definition
  | [null_exclusion] access_to_subprogram_definition

access_to_object_definition ::= 'access' [general_access_modifier] subtype_indication

general_access_modifier ::= 'all' | 'constant'

access_to_subprogram_definition ::=
    'access' ['protected'] 'procedure' parameter_profile
  | 'access' ['protected'] 'function'  parameter_and_result_profile

null_exclusion ::= 'not' 'null'

access_definition
  : [null_exclusion] 'access' ['constant'] name
    %((wisi-face-apply-action [4 font-lock-function-name-face font-lock-type-face]))%

  | [null_exclusion] 'access' ['protected'] 'procedure' parameter_profile
    ;; test/ada_mode-nominal.ads
    ;; type Procedure_Access_Type_8 is access
    ;;   protected procedure
    ;;     (A_Param : out Integer);
    %((wisi-indent-action [nil nil nil nil (wisi-anchored%- 4 ada-indent-broken)]))%

  | [null_exclusion] 'access' ['protected'] 'function' parameter_and_result_profile
    ;; test/ada_mode-nominal.ads
    ;; type Procedure_Access_Type_8 is access
    ;;   protected procedure
    ;;     (A_Param : out Integer);
    %((wisi-indent-action [nil nil nil nil (wisi-anchored%- 4 ada-indent-broken)]))%
  ;

incomplete_type_declaration
  : 'type' IDENTIFIER [discriminant_part] ['is' 'tagged'] ';'
    %((wisi-statement-action [1 statement-start 6 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 nil font-lock-type-face])
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                                 ada-indent-broken]))%

  ;

;; pragma_g is not a 'declarative_item' in ARM, but it must be in the
;; grammar. We don't include it in 'declaration_item', to avoid conflicts
;; with 'pragma_g' in statements via compilation_unit.
declarative_item_list ;;:new for pragma_g
  : pragma_g
  | declarative_item
  | declarative_item_list declarative_item
  | declarative_item_list pragma_g
  ;

declarative_part ::= declarative_item_list

declarative_item : basic_declarative_item | proper_body | body_stub ;

basic_declarative_item : basic_declaration | aspect_clause | use_clause ;

;; body  ;;:inlined
;; ::= proper_body | body_stub

proper_body ::=
    subprogram_body | package_body | task_body | protected_body

name
  : direct_name
    %()%
    %((wisi-propagate-name 1))%

  | explicit_dereference
  ;; indexed_component ;; redundant with 'name actual_parameter_part'
  | slice

  | selected_component
    %()%
    %((wisi-propagate-name 1))%

  | attribute_reference
  | type_conversion
  | function_call
  | CHARACTER_LITERAL
  | qualified_expression
  ;; name ;; redundant - inlined generalized_reference
  ;; generalized_indexing ;; redundant with function_call
  | target_name

direct_name
  : IDENTIFIER
    ;; marking this for possible later face-apply, to prevent applying
    ;; face to the aggregate of an allocator, and other similar cases.
    ;; test/ada_mode-nominal.adb
    ;;    Object_3 : access Record_Type_3 := new Record_Type_3 (...)
    %((wisi-face-mark-action [1 suffix]))%
    %((wisi-propagate-name 1))%

  | STRING_LITERAL
    %()%
    %((wisi-propagate-name 1))%
  ;

;;:deleted prefix ::= name | implicit_dereference ;; inlined in 'name'

explicit_dereference ::= name '.' 'all'

  ;; implicit_dereference ::= name ;; only used in 'prefix'

  ;; indexed_component ::= name '(' expression {',' expression} ')' redundant with function_call

slice ::= name '(' discrete_range ')'

selected_component ::= name  '.'  selector_name

selector_name ::= IDENTIFIER | CHARACTER_LITERAL | STRING_LITERAL

attribute_reference ::= name tick attribute_designator | reduction_attribute_reference

attribute_designator ::=
    IDENTIFIER ['(' expression ')']
  | 'access'
  | 'delta'
  | 'digits'
  | 'mod'

range_attribute_reference ::= name tick range_attribute_designator

range_attribute_designator ::= 'range' ['(' expression ')']

  ;; generalized_reference ::= name  ;; inlined to name

  ;; generalized_indexing ::= name actual_parameter_part - redundant with function_call

aggregate ::=
    record_aggregate
  | extension_aggregate
  | array_aggregate
  | delta_aggregate
  ;; container_aggregate ;; redundant with array_aggregate

  ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | '(' conditional_expression ')' ;; new
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  | '(' quantified_expression ')' ;; new
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

record_aggregate
  : '(' record_component_association_list ')'
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

record_component_association_list ::=
    record_component_association {',' record_component_association}
  | 'null' 'record'

record_component_association ::=
    [component_choice_list '=>'] expression
  | component_choice_list '=>' '<>'

component_choice_list ::= selector_name {'|' selector_name} | 'others'

extension_aggregate
  : '(' expression 'with' record_component_association_list ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                           (wisi-anchored 1 0)]))%
  ;

;; ancestor_part ::= expression | name ;; inlined to 'expression'

array_aggregate ::= positional_array_aggregate | null_array_aggregate | named_array_aggregate

expression_list ;; new to support actions
  : expression {',' expression} ;

positional_array_aggregate
;; There must be at least two items in a positional aggregate with parens.
  : '(' expression ','  expression_list ')'
    %((wisi-indent-action [nil
                           (ada-indent-anchored-expression 1)
                           nil
                           [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                           (wisi-anchored 1 0)]))%
  | '(' expression_list ',' 'others' '=>' expression ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 ada-indent-broken)
                           (ada-indent-anchored-expression 1)
                           (wisi-anchored 1 0)]))%
  | '(' expression_list ',' 'others' '=>' '<>' ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           nil
                           (wisi-anchored 1 1)
                           nil
                           nil
                           (wisi-anchored 1 0)]))%
  | '[' expression_list [','  'others'  '=>'  expression] ']'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 ada-indent-broken)
                           (ada-indent-anchored-expression 1)
                           (wisi-anchored 1 0)]))%
  | '[' expression_list ','  'others'  '=>'   '<>' ']'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           nil
                           (wisi-anchored 1 1)
                           nil
                           nil
                           (wisi-anchored 1 0)]))%
  ;

null_array_aggregate ::= '[' ']'

named_array_aggregate
  : '(' array_component_association_list ')'
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  | '[' array_component_association_list ']'
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

array_component_association_list ::= array_component_association { ','  array_component_association}

array_component_association
  : discrete_choice_list '=>' expression
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           (ada-indent-anchored-expression 2)]))%
  | discrete_choice_list '=>' '<>'
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           ada-indent-broken]))%
  ;; iterated_component_association ;;:deleted
  | iterated_element_association ;;:new: superset of iterated_component_association
  ;

;; iterated_component_association ;;:deleted; subset of iterated_element_association
;;   : 'for' IDENTIFIER 'in' discrete_choice_list '=>' expression
;;     %((wisi-indent-action [nil
;;                            ada-indent-broken
;;                            ada-indent-broken
;;                            (wisi-hanging nil ada-indent-broken)
;;                            ada-indent-broken
;;                            (ada-indent-anchored-expression 2)]))%

;;   | 'for' iterator_specification '=>' expression
;;     %((wisi-indent-action [nil
;;                            ada-indent-broken
;;                            ada-indent-broken
;;                            (ada-indent-anchored-expression 2)]))%
;;   ;

delta_aggregate ::= record_delta_aggregate | array_delta_aggregate

record_delta_aggregate
  : '(' expression 'with' 'delta' record_component_association_list ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                           (wisi-anchored 1 0)]))%
  ;

array_delta_aggregate
  : '(' expression 'with' 'delta' array_component_association_list ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                           (wisi-anchored 1 0)]))%

  | '[' expression 'with' 'delta' array_component_association_list ']'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 1)
                           [(wisi-anchored 1 1) (wisi-anchored 1 1)]
                           (wisi-anchored 1 0)]))%
  ;

;; container_aggregate ::= ;; deleted; subset of array_aggregate except for iterated_element_association
;;     null_array_aggregate
;;   | positional_container_aggregate
;;   | named_container_aggregate

;; null_container_aggregate ::= '[' ']' ;; inlined to "null_array_aggregate"

;; positional_container_aggregate ::= '[' expression {','  expression} ']' ;; deleted; only used in container_aggregate

;; named_container_aggregate ::= '[' container_element_association_list ']' ;; deleted; only used in container_aggregate

;; container_element_association_list ::= container_element_association { ','  container_element_association} ;; deleted; only used in container_aggregate

;; container_element_association ::= ;; deleted; only used in container_aggregate
;;     key_choice_list  '=>'  expression
;;   | key_choice_list  '=>'   '<>'
;;   | iterated_element_association

;; key_choice_list ::= key_choice {'|' key_choice} ;; deleted; only used in container_aggregate

;; key_choice ::= expression | discrete_range ;; deleted; only used in container_aggregate

iterated_element_association ::=
    'for' loop_parameter_specification ['use' expression] '=>' expression
  | 'for' iterator_specification ['use' expression] '=>'  expression

expression ::=
    relation ;; new to reduce conflicts
  | relation {'and' relation}-        ;; extra -
  | relation {'and' 'then' relation}- ;; extra -
  | relation {'or' relation}-         ;; extra -
  | relation {'or' 'else' relation}-  ;; extra -
  | relation {'xor' relation}-        ;; extra -

choice_expression ::=
    choice_relation ;; new to reduce conflicts
  | choice_relation {'and' choice_relation}-        ;; extra -
  | choice_relation {'or' choice_relation}-         ;; extra -
  | choice_relation {'xor' choice_relation}-        ;; extra -
  | choice_relation {'and' 'then' choice_relation}- ;; extra -
  | choice_relation {'or' 'else' choice_relation}-  ;; extra -

choice_relation ::= simple_expression [relational_operator simple_expression]

relation ::=
  ;; simple_expression [ relational_operator simple_expression ] ;; redundant with choice_relation
    choice_relation ;; new
  | simple_expression ['not'] 'in' membership_choice_list
  | raise_expression

membership_choice_list ::= membership_choice {'|' membership_choice}

membership_choice ::=
    simple_expression
  | range_g
  ;; name ;; redundant - from inlined subtype_mark, redundant with name in simple_expression

simple_expression ::= [unary_adding_operator] term {binary_adding_operator term}

term ::= factor {multiplying_operator factor}

factor ::= primary ['**' primary] | 'abs' primary | 'not' primary

primary ::=
    NUMERIC_LITERAL
  | 'null'
  ;; STRING_LITERAL ;; redundant with name
  | aggregate
  | name
  | allocator
  | '(' expression ')' ;; FIXME: redundant with positional_aggregate? that requires two elements.
  ;; '(' conditional_expression ')' ;;:redundant with aggregate
  ;; '(' quantified_expression ')' ;;:redundant with aggregate
  | '(' declare_expression ')'

  ;; logical_operator ::= 'and' | 'or' | 'xor' ;; not used in the grammar

relational_operator ::= '=' | '/=' | '<' | '<=' | '>' | '>='

binary_adding_operator ::= '+' | '-' | '&'

unary_adding_operator ::= '+' | '-'

multiplying_operator ::=  '*' | '/' | 'mod' | 'rem'

  ;; highest_precedence_operator ::= '**' | 'abs' | 'not' ;; not used in the grammar

conditional_expression ::= if_expression | case_expression

elsif_expression_item ;;:new for action
  : 'elsif' condition 'then' expression
    %((wisi-statement-action [1 motion 3 motion])
      (wisi-motion-action [1 3])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent]))%
  ;

elsif_expression_list ;;:new for action
  : elsif_expression_item
  | elsif_expression_list elsif_expression_item
    %((wisi-motion-action [1 2]))%
  ;

if_expression
  : 'if' condition 'then' expression elsif_expression_list ['else' expression]
    %((wisi-statement-action [1 motion 3 motion 6 motion])
      (wisi-motion-action [1 3 5 6])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil ada-indent nil nil ada-indent]))%
  ;

condition ::= expression ;

case_expression_alternative_list ;;:new for action
  : case_expression_alternative
  | case_expression_alternative_list ',' case_expression_alternative
    %((wisi-motion-action [1 3]))%
  ;

case_expression
  : 'case' expression 'is' case_expression_alternative_list
    %((wisi-statement-action [1 motion])
      (wisi-motion-action [1 4])
      (wisi-indent-action [nil ada-indent-broken nil ada-indent-when]))%
  ;

case_expression_alternative
  : 'when' discrete_choice_list '=>' expression
    ;; test/ada_mode-conditional_expressions.adb
    ;; when A =>
    ;;    J = 4
    ;;      or else M, --  test case from Piotr Trojanek
    %((wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken
                               (wisi-hanging (wisi-anchored% 1 ada-indent)
                                             (wisi-anchored% 1 (+ ada-indent ada-indent-broken)))]))%
  ;

quantified_expression ::=
    'for' quantifier loop_parameter_specification '=>' predicate
  | 'for' quantifier iterator_specification '=>' predicate

quantifier ::= 'all' | 'some'

predicate ::= expression

declare_expression
  : 'declare' {declare_item} 'begin' expression
    %((wisi-indent-action [nil ada-indent nil ada-indent]))%
  ;

declare_item ::= object_declaration | object_renaming_declaration

reduction_attribute_reference ::=
    value_sequence tick reduction_attribute_designator
  | name tick reduction_attribute_designator

value_sequence ::= '[' ['parallel' ['(' chunk_specification ')']] iterated_element_association ']'

reduction_attribute_designator ::= IDENTIFIER '(' reduction_specification ')'

reduction_specification ::= name ',' expression

type_conversion ::=
    name '(' expression ')'
  | name '(' name ')'

qualified_expression ::= name tick '(' expression ')' | name tick aggregate

allocator ::=
    'new' [subpool_specification] subtype_indication
  ;; 'new' [ subpool_specification ] qualified_expression ;; redundant with name in subtype_indication

subpool_specification ::= '(' name ')'

sequence_of_statements ::= statement {statement} {label}

sequence_of_statements_opt : ;; new; eliminates many conflicts in entry_call and select
    [sequence_of_statements]

  ;; inlined "[sequence_of_statements]" to "sequence_of_statements_opt"

statement ::=
    {label} simple_statement | {label} compound_statement

simple_statement ::= null_statement
  | assignment_statement
  | exit_statement
  | goto_statement
  | procedure_call_statement
  | simple_return_statement
  ;; entry_call_statement ;;:redundant with procedure_call_statement
  | requeue_statement
  | delay_statement
  | abort_statement
  | raise_statement
  ;; code_statement ;;:redundant with procedure_call_statement
  | pragma_g ;;:new for pragma
  ;

compound_statement
  : if_statement
  | case_statement
  | loop_statement
  | block_statement
  | extended_return_statement
  | parallel_block_statement
  | accept_statement
  | select_statement
  ;

null_statement ::= 'null' ';'

label
  : '<<' statement_identifier '>>'
    %((wisi-face-apply-action [2 nil font-lock-constant-face])
      (wisi-indent-action [ada-indent-label ada-indent-broken ada-indent-broken]))%
  ;

statement_identifier ::= direct_name

assignment_statement
  : name ':=' expression ';'
    %((wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-indent-action [nil
                           ada-indent-broken
                           (wisi-hanging
                            (wisi-anchored% 2 ada-indent-broken)
                            (wisi-anchored% 3 ada-indent-broken))
                           ada-indent-broken]))%
  ;

target_name ::= '@'

elsif_statement_item ;;:new for action
  : 'elsif' condition 'then' sequence_of_statements
    %((wisi-statement-action [1 motion 3 motion])
      (wisi-motion-action [1 3])
      (wisi-indent-action [nil [ada-indent-broken ada-indent-broken] nil [ada-indent ada-indent]]))%
  ;

elsif_statement_list ;;:new for action
  : elsif_statement_item
  | elsif_statement_list elsif_statement_item
  ;

if_statement
  : 'if' condition 'then' sequence_of_statements [elsif_statement_list] ['else' sequence_of_statements] 'end' 'if' ';'
    %((wisi-statement-action [1 statement-start 3 motion 6 motion 10 statement-end])
      (wisi-motion-action [1 3 [5 ELSIF] 6 10])
      (wisi-indent-action [nil
                           [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                            ada-indent-broken]
                           nil
                           [ada-indent ada-indent] nil nil
                           [ada-indent ada-indent] nil ada-indent-broken ada-indent-broken]))%
  ;

case_statement_alternative_list ;;:new for action
  : case_statement_alternative
  | case_statement_alternative_list case_statement_alternative
  ;

case_statement
  : 'case' expression 'is' case_statement_alternative_list 'end' 'case' ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-motion-action [1 [4 WHEN] 7])
      (wisi-indent-action [nil ada-indent-broken nil [ada-indent-when ada-indent-when]
                               nil ada-indent-broken ada-indent-broken]))%
;

case_statement_alternative
  : 'when' discrete_choice_list '=>' sequence_of_statements
    %((wisi-statement-action [1 motion])
      ;; ada-indent-when added in case_statement
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken [ada-indent ada-indent]]))%
  ;

loop_statement
  : [statement_identifier ':'] [iteration_scheme] 'loop' sequence_of_statements 'end' 'loop' [IDENTIFIER] ';'
    %((wisi-statement-action [1 statement-start 3 statement-override 4 motion 9 statement-end])
      (wisi-motion-action [3 4 9])
      (wisi-indent-action [ada-indent-label nil nil nil [ada-indent ada-indent] nil ada-indent-broken ada-indent-broken
                               ada-indent-broken]))%
  ;

iteration_scheme
  : 'while' condition
    %((wisi-indent-action [nil [ada-indent-broken ada-indent-broken]]))%
  | 'for' loop_parameter_specification
    %((wisi-indent-action [nil [ada-indent-broken ada-indent-broken]]))%
  | 'for' iterator_specification
    %((wisi-indent-action [nil [ada-indent-broken ada-indent-broken]]))%
  | ['parallel'] 'for' procedural_iterator
    %((wisi-indent-action [nil nil [ada-indent-broken ada-indent-broken]]))%
  | 'parallel' [ '(' chunk_specification ')' ] 'for' loop_parameter_specification
    %((wisi-indent-action [nil nil (wisi-anchored 1 1) (wisi-anchored 1 0) nil [ada-indent-broken ada-indent-broken]]))%
  | 'parallel' [ '(' chunk_specification ')' ] 'for' iterator_specification
    %((wisi-indent-action [nil nil (wisi-anchored 1 1) (wisi-anchored 1 0) nil [ada-indent-broken ada-indent-broken]]))%
  ;

chunk_specification ::=
    simple_expression
  | IDENTIFIER 'in' discrete_subtype_definition

loop_parameter_specification
  ;;  This is almost a subset of iterator_specification;
  ;;  discrete_subtype_definition is a superset of 'name'; could merge
  ;;  to reduce conflicts.
  : IDENTIFIER 'in' ['reverse'] discrete_subtype_definition [iterator_filter]
    %((wisi-face-remove-action [4]))%
  ;

iterator_filter ::= 'when' condition

iterator_specification ::=
    IDENTIFIER [':' loop_parameter_subtype_indication] 'in' ['reverse'] name [iterator_filter]
  | IDENTIFIER [':' loop_parameter_subtype_indication] 'of' ['reverse'] name [iterator_filter]

loop_parameter_subtype_indication ::= subtype_indication | access_definition

procedural_iterator ::= iterator_parameter_specification 'of' iterator_procedure_call [iterator_filter]

iterator_parameter_specification ::=
    formal_part
  | '(' IDENTIFIER {',' IDENTIFIER} ')'

iterator_procedure_call ::=
    name
  | name iterator_actual_parameter_part

iterator_actual_parameter_part ::= '(' iterator_parameter_association { ',' iterator_parameter_association} ')'

iterator_parameter_association ::=
    parameter_association
  | parameter_association_with_box

parameter_association_with_box ::= [ selector_name  '=>'  ]  '<>'

block_statement
  : [statement_identifier ':'] ['declare' declarative_part] 'begin' handled_sequence_of_statements
    'end' [IDENTIFIER] ';'
    %((wisi-statement-action [1 statement-start 3 statement-override 5 motion 9 statement-end])
      (wisi-motion-action [1 3 5 [6 WHEN] 9])
      (wisi-indent-action [ada-indent-label nil nil [ada-indent ada-indent] nil [ada-indent ada-indent]
                                            nil ada-indent-broken ada-indent-broken]))%
    %((wisi-match-names 1 8))%
  ;

parallel_block_statement ::=
    'parallel' 'do' handled_sequence_of_statements 'and' handled_sequence_of_statements
      {'and' handled_sequence_of_statements} 'end' 'do' ';'

exit_statement
  : 'exit' [name] ['when' condition] ';'
    %((wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-indent-action [nil nil nil ada-indent-broken ada-indent-broken]))%
  ;

goto_statement ::= 'goto' name';'

subprogram_declaration ::=
    [overriding_indicator]
      subprogram_specification
      [aspect_specification]';'

subprogram_specification ::=
    procedure_specification
  | function_specification

procedure_specification ::= 'procedure' name parameter_profile

function_specification
  : 'function' name parameter_and_result_profile
    %((wisi-statement-action [1 statement-start])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken]))%
    %((wisi-propagate-name 2))%
  ;

;; designator ::= [name  '.'] IDENTIFIER | STRING_LITERAL ;;:inlined to "name"

;; defining_designator ::= name | STRING_LITERAL ;;:inlined to "name"

;; defining_program_unit_name ::= [name  '.'] IDENTIFIER ;;:inlined to "name"; redundant with selected_component in name

;; operator_symbol ::= STRING_LITERAL ;;:inlined

;; defining_operator_symbol ::= STRING_LITERAL ;;:inlined

parameter_profile ::= [formal_part]

parameter_and_result_profile ::=
    [formal_part] 'return' [null_exclusion] name
  | [formal_part] 'return' access_definition
  ;

parameter_specification_list ;;:new for action
  : parameter_specification {';' parameter_specification}
  ;

formal_part
  : '(' parameter_specification_list ')'
    %((wisi-statement-action [1 misc]) ;; for ada-wisi-in-paramlist-p, ada-goto-declarative-region-start
      (wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

parameter_specification ::=
    defining_identifier_list ':' ['aliased'] mode [null_exclusion] name [':=' default_expression]
  | defining_identifier_list ':' access_definition [':=' default_expression]

mode ::= ['in'] | 'in' 'out' | 'out'

global_aspect_definition ::=
    'null'
  | 'unspecified'  ;; FIXME: new keyword? redundant with IDENTIFIER?
  | global_mode global_designator
  |  '(' global_aspect_element{ ','  global_aspect_element} ')'
  | extended_global_aspect_definition

global_aspect_element ::=
    global_mode global_set
  | extended_global_aspect_element

global_mode ::=
    basic_global_mode
  | extended_global_mode

basic_global_mode ::= 'in' | 'in' 'out' | 'out'

global_set ::= name { ','  name}

global_designator ::= 'all' | 'synchronized' | name

  ;; global_name ::= name | name ;; inlined to "name"

subprogram_body ::=
    [overriding_indicator]
      subprogram_specification
      [aspect_specification] 'is'
      declarative_part
      'begin'
      handled_sequence_of_statements
      'end' [name]';'

procedure_call_statement ::=
    name ';'
  ;; name actual_parameter_part ';' ;; redundant with function_call in name

function_call
  ;; name ;; redundant with "name"
  : name actual_parameter_part
    %((wisi-indent-action [nil
                           (if ada-indent-hanging-rel-exp
                               (wisi-anchored 1 ada-indent-broken)
                             (wisi-anchored% 1 ada-indent-broken))]))%
  ;

parameter_association_list ;; new to support actions
  : parameter_association {',' parameter_association} ;

actual_parameter_part
;; '(' parameter_association {',' parameter_association} ')' ;; deleted to support actions
  : '(' parameter_association_list ')' ;; new to support actions
    ;; see note in test/ada_mode-parens.adb Local_10 about right paren indent.
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%

  ;; ARM 4.5.7(7), ARM 4.5.8(4) allow ( conditional|quantified_expression ) instead of (( ... ))
  | '(' conditional_expression ')' ;; new
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  | '(' quantified_expression ')' ;; new
    %((wisi-indent-action [nil [(wisi-anchored 1 1) (wisi-anchored 1 1)] (wisi-anchored 1 0)]))%
  ;

parameter_association
  : [selector_name '=>'] explicit_actual_parameter
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           (ada-indent-anchored-expression 2)]))%
  ;

explicit_actual_parameter ::=
    expression
  ;; name ;; redundant with expression

simple_return_statement ::= 'return' [expression]';'

extended_return_object_declaration
  : IDENTIFIER ':' ['aliased'] ['constant'] return_subtype_indication [':=' expression]
    %((wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               (wisi-anchored% 6 ada-indent-broken)]))%
  ;

extended_return_statement
  : 'return' extended_return_object_declaration ['do' handled_sequence_of_statements 'end' 'return'] ';'
    ;; indent the same as a simple return statment
    ;; test/ada_mode-nominal.adb
    ;; return B : Integer :=
    ;;   (Local_Function);
    ;; (wisi-indent-action [nil nil nil]))
    %((wisi-statement-action [1 statement-start 3 motion 7 statement-end])
      (wisi-motion-action [1 3 [4 WHEN] 7])
      (wisi-indent-action [[nil ada-indent] ada-indent-broken nil [ada-indent ada-indent] nil ada-indent-broken
                           ada-indent-broken]))%
  ;

return_subtype_indication ::= subtype_indication | access_definition

null_procedure_declaration
  : [overriding_indicator] procedure_specification 'is' 'null' [aspect_specification] ';'
    ;; indent IS consistent with expression_function
    %((wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil nil ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

expression_function_declaration
  : [overriding_indicator] function_specification 'is' '(' expression ')' [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 8 statement-end])
      (wisi-indent-action [nil nil nil
                               ada-indent-broken (ada-indent-anchored-expression 4) (wisi-anchored 4 0)
                               ada-indent-broken ada-indent-broken]))%
  | [overriding_indicator] function_specification 'is' aggregate [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 6 statement-end])
      (wisi-indent-action [nil nil nil ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

package_declaration ::= package_specification';'

package_specification ::=
    'package' name [aspect_specification] 'is' {basic_declarative_item}
      ['private' {basic_declarative_item}] 'end' [[name '.' ] IDENTIFIER]

package_body ::=
    'package' 'body' name [aspect_specification] 'is' declarative_part
      ['begin' handled_sequence_of_statements] 'end' [[name '.' ] IDENTIFIER] ';'

private_type_declaration ::=
    'type' IDENTIFIER [discriminant_part] 'is'
      [['abstract'] 'tagged'] ['limited'] 'private' [aspect_specification]';'

private_extension_declaration ::=
    'type' IDENTIFIER [discriminant_part] 'is' ['abstract'] ['limited' | 'synchronized'] 'new'
      subtype_indication ['and' interface_list] 'with' 'private' [aspect_specification] ';'

overriding_indicator ::= ['not'] 'overriding'

use_clause ::= use_package_clause | use_type_clause

use_package_clause ::= 'use' name {',' name} ';'

use_type_clause ::= 'use' ['all'] 'type' name {',' name} ';'

renaming_declaration ::=
    object_renaming_declaration
  | exception_renaming_declaration
  | package_renaming_declaration
  | subprogram_renaming_declaration
  | generic_renaming_declaration

object_renaming_declaration
  : IDENTIFIER [':' [null_exclusion] name] 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 8 statement-end])
      (wisi-name-action 1)
      (wisi-face-apply-action [4 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil
                           ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken ada-indent-broken]))%
  | IDENTIFIER ':' access_definition 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-name-action 1)
      (wisi-indent-action [nil
                           ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken ada-indent-broken]))%
  ;

exception_renaming_declaration
  : IDENTIFIER ':' 'exception' 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-name-action 1)
      (wisi-face-apply-action [5 font-lock-function-name-face nil])
      (wisi-indent-action [nil
                           ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken ada-indent-broken]))%
  ;

package_renaming_declaration ::= 'package' name 'renames' name [aspect_specification]';'

subprogram_renaming_declaration ::=
    [overriding_indicator] subprogram_specification 'renames' name [aspect_specification]';'

generic_renaming_declaration
  : 'generic' 'package' name 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             ada-indent-broken]))%
  | 'generic' 'procedure' name 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             ada-indent-broken]))%
  | 'generic' 'function' name 'renames' name [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken
                             ada-indent-broken]))%
  ;

task_type_declaration ::=
    'task' 'type' IDENTIFIER [known_discriminant_part] [aspect_specification]
      ['is' ['new' interface_list 'with'] task_definition]';'

single_task_declaration ::=
    'task' IDENTIFIER [aspect_specification] ['is' ['new' interface_list 'with'] task_definition]';'

task_definition ::= {task_item} [ 'private' {task_item}] 'end' [IDENTIFIER]

task_item ::= entry_declaration | aspect_clause

task_body ::=
    'task' 'body' IDENTIFIER [aspect_specification] 'is' declarative_part 'begin'
      handled_sequence_of_statements 'end' [IDENTIFIER]';'

protected_type_declaration ::=
    'protected' 'type' IDENTIFIER [known_discriminant_part] [aspect_specification] 'is'
      ['new' interface_list 'with'] protected_definition';'

single_protected_declaration ::=
    'protected' IDENTIFIER [aspect_specification] 'is' ['new' interface_list 'with'] protected_definition';'

protected_definition ::=
    { protected_operation_declaration } [ 'private' { protected_element_declaration } ] 'end' [IDENTIFIER]

protected_operation_declaration ::=
    subprogram_declaration
  | entry_declaration
  | aspect_clause

protected_element_declaration ::= protected_operation_declaration | component_declaration

protected_body ::=
    'protected' 'body' IDENTIFIER [aspect_specification] 'is' { protected_operation_item } 'end' [IDENTIFIER]';'

protected_operation_item ::=
    subprogram_declaration
  | subprogram_body
  | null_procedure_declaration
  | expression_function_declaration
  | entry_body
  | aspect_clause

  ;; synchronization_kind ::= By_Entry | By_Protected_Procedure | Optional ;; not used in the grammar

entry_declaration
  : [overriding_indicator] 'entry' IDENTIFIER ['(' discrete_subtype_definition ')'] parameter_profile
      [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 9 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 nil font-lock-function-name-face])
        (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken (wisi-anchored 4 1) (wisi-anchored 4 0)
                               ada-indent-broken nil ada-indent-broken]))%
      ;

accept_statement ::=
    'accept' direct_name ['(' entry_index ')'] parameter_profile
    ['do' handled_sequence_of_statements 'end' [IDENTIFIER]] ';'
    %((wisi-statement-action [1 statement-start 7 motion 11 statement-end])
    (wisi-motion-action [1 7 [8 WHEN] 11])
    (wisi-face-apply-action [2 nil font-lock-function-name-face 10 nil font-lock-function-name-face])
    (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil nil ada-indent-broken
    [nil ada-indent] [ada-indent ada-indent] nil ada-indent-broken ada-indent-broken]))%
    %((wisi-match-names 2 10))%
  ;

entry_index ::= expression

entry_body
  : 'entry' IDENTIFIER entry_body_formal_part [aspect_specification] entry_barrier 'is' declarative_part 'begin'
      handled_sequence_of_statements 'end' [IDENTIFIER] ';'
    %((wisi-statement-action [1 statement-start 5 motion 6 motion 8 motion 12 statement-end])
      (wisi-name-action 2)
      (wisi-motion-action [1 5 6 8 [9 WHEN] 12])
      (wisi-face-apply-action [2 nil font-lock-function-name-face 11 nil font-lock-function-name-face])

        ;; test/ada_mode-nominal.adb
        ;; entry E2
        ;;   (X : Integer)
        ;;   when Local_1 = 0 and not
        ;;     (Local_2 = 1)
        ;;
        ;; entry E3
        ;;   (X : Integer) when Local_1 = 0 and not
        ;;     (Local_2 = 1)
        (wisi-indent-action [nil ada-indent-broken ada-indent-broken nil ada-indent-broken
                                 nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil ada-indent-broken
                                 ada-indent-broken]))%
    %((wisi-match-names 2 11))%
  ;

entry_body_formal_part
  : ['(' entry_index_specification ')'] parameter_profile
    %((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0) ada-indent-broken]))%
  ;

entry_barrier
  : 'when' condition
    %((wisi-statement-action [1 motion])
      (wisi-indent-action [nil (wisi-anchored% 1 ada-indent-broken)]))%
  ;

entry_index_specification ::= 'for' IDENTIFIER 'in' discrete_subtype_definition

  ;; entry_call_statement ::= name [actual_parameter_part] ';' ;; deleted; redundant with procedure_call_statement

requeue_statement ::= 'requeue' name ['with' 'abort'] ';'

delay_statement : delay_until_statement | delay_relative_statement ;

delay_until_statement
  : 'delay' 'until' expression ';'
    %((wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

delay_relative_statement
  : 'delay' expression ';'
    %((wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken]))%
  ;

select_statement ::=
    selective_accept
  | timed_entry_call
  | conditional_entry_call
  | asynchronous_select

selective_accept ::=
    'select' [guard] select_alternative { 'or' [guard] select_alternative } [ 'else' sequence_of_statements ] 'end'
      'select' ';'

guard ::= 'when' condition '=>'

select_alternative ::=
    accept_alternative
  | delay_alternative
  | terminate_alternative

accept_alternative ::= accept_statement sequence_of_statements_opt

delay_alternative ::= delay_statement sequence_of_statements_opt

terminate_alternative ::= 'terminate' ';'

timed_entry_call ::= 'select' entry_call_alternative 'or' delay_alternative 'end' 'select' ';'

entry_call_alternative ::= procedure_call_statement sequence_of_statements_opt

  ;; procedure_or_entry_call ::= procedure_call_statement | entry_call_statement ;; inlined to procedure_call_statement

conditional_entry_call
  : 'select' entry_call_alternative 'else' sequence_of_statements 'end' 'select' ';'
    %((wisi-statement-action [1 statement-start 3 motion 7 statement-end])
        (wisi-motion-action [1 3 7])
        (wisi-indent-action [nil [ada-indent ada-indent] nil [ada-indent ada-indent] nil ada-indent-broken
                                 ada-indent-broken]))%
  ;

asynchronous_select
  : 'select' triggering_alternative 'then' 'abort' abortable_part 'end' 'select' ';'
    %((wisi-statement-action [1 statement-start 3 motion 8 statement-end])
      (wisi-motion-action [1 3 8])
      (wisi-indent-action [nil [ada-indent ada-indent] [nil ada-indent-broken] ada-indent-broken
                               [ada-indent ada-indent] nil ada-indent-broken ada-indent-broken]))%
  ;

triggering_alternative ::=
  ;; triggering_statement [sequence_of_statements] ;; redundant
  ;; actually just causes conflicts; replaced by the following:
    procedure_call_statement sequence_of_statements_opt ;; new
  | delay_statement sequence_of_statements_opt ;; new

  ;; triggering_statement ::= procedure_call_statement | delay_statement ;; deleted, inlined to reduce conflicts

abortable_part ::= sequence_of_statements

abort_statement ::= 'abort' name {',' name} ';'

;; Compute indent for trailing comments.
compilation
  : compilation_unit
    %((wisi-indent-action [[0 0]]))%
    %((wisi-terminate-partial-parse))%
  | compilation compilation_unit
    %((wisi-indent-action [0 [0 0]]))%
  ;

;; extended for partial parse, fragment parse
compilation_unit ::=
  ;; context_clause library_item ;; redundant; all are in declarative_item
  ;; context_clause subunit ;; redundant
    with_clause ;; new
  | ['private'] declarative_item ;; new
    %((wisi-indent-action [0 0]))%
  | statement ;; new
  | subunit ;; new
  ;

;; library_item ::=
;;     ['private'] library_unit_declaration
;;   | library_unit_body
;;   | ['private'] library_unit_renaming_declaration

;; library_unit_declaration ::=
;;     subprogram_declaration
;;   | package_declaration
;;   | generic_declaration
;;   | generic_instantiation

;; library_unit_renaming_declaration ::=
;;     package_renaming_declaration
;;   | generic_renaming_declaration
;;   | subprogram_renaming_declaration

;; library_unit_body ::= subprogram_body | package_body

;; parent_unit_name ::= name ;; inlined

;; with_clause merged into compilation_unit; use_clause is already there via declarative_item
;; context_clause ::= context_item+
;; context_item ::= with_clause | use_clause

with_clause ::= limited_with_clause | nonlimited_with_clause

limited_with_clause ::= 'limited' ['private'] 'with' name {',' name} ';'

nonlimited_with_clause ::= ['private'] 'with' name {',' name} ';'

body_stub ::=
    subprogram_body_stub
  | package_body_stub
  | task_body_stub
  | protected_body_stub

subprogram_body_stub ::=
    [overriding_indicator] subprogram_specification 'is' 'separate' [aspect_specification] ';'

package_body_stub ::= 'package' 'body' IDENTIFIER 'is' 'separate' [aspect_specification] ';'

task_body_stub ::= 'task' 'body' IDENTIFIER 'is' 'separate' [aspect_specification] ';'

protected_body_stub ::= 'protected' 'body' IDENTIFIER 'is' 'separate' [aspect_specification] ';'

subunit ::= 'separate' '(' name ')' proper_body

exception_declaration
  : defining_identifier_list ':' 'exception' [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 5 statement-end]))%
  ;

exception_handler_list ;;:new for pragma, action
  : exception_handler
  | pragma_g ;;:new for pragma
  | exception_handler_list exception_handler
    %((wisi-motion-action [1 2]))%
  ;

handled_sequence_of_statements
  : sequence_of_statements ['exception' exception_handler_list]
    %((wisi-indent-action [[nil nil]
                             (- ada-indent)
                             [(- ada-indent-when ada-indent) (- ada-indent-when ada-indent)]]))%
  ;

exception_choice_list ;;:new for action
  : exception_choice {'|' exception_choice} ;

exception_handler
  : 'when' [choice_parameter_specification ':'] exception_choice_list '=>' sequence_of_statements
    %((wisi-statement-action [1 motion])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             [ada-indent ada-indent]]))%
    ;

choice_parameter_specification ::= IDENTIFIER

exception_choice ::= name | 'others'

raise_statement ::=
    'raise' ';'
  | 'raise' name ['with' expression] ';'

raise_expression ::= 'raise' name ['with' simple_expression]

generic_declaration : generic_subprogram_declaration | generic_package_declaration ;

generic_subprogram_declaration
  : generic_formal_part subprogram_specification [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 4 statement-end])
      (wisi-motion-action [1 2 4]))%
  ;

generic_package_declaration
  : generic_formal_part package_specification ';'
    %((wisi-statement-action [1 statement-start 3 statement-end])
      (wisi-motion-action [1 2 3])
      (wisi-indent-action [[nil ada-indent] nil ada-indent-broken]))%
  ;

generic_formal_part
  : 'generic' {generic_formal_parameter_declaration}
    %((wisi-statement-action [1 statement-start])
      (wisi-indent-action [nil ada-indent]))%
  ;

generic_formal_parameter_declaration
  : formal_object_declaration
  | formal_type_declaration
  | formal_subprogram_declaration
  | formal_package_declaration
  | use_clause ;;:new, moved here from generic_formal_part
  | pragma_g ;;:new for pragma
  ;

generic_instantiation
  : 'package' name 'is' 'new' name [generic_actual_part] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 8 statement-end])
        (wisi-name-action 2)
        (wisi-face-apply-action [2 font-lock-function-name-face font-lock-function-name-face
                                   5 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             nil ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken ada-indent-broken ada-indent-broken]))%
  | [overriding_indicator] 'procedure' name 'is' 'new' name [generic_actual_part] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 9 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   6 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken ada-indent-broken ada-indent-broken]))%
  | [overriding_indicator] 'function' name 'is' 'new' name [generic_actual_part] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 2 statement-override 9 statement-end])
        (wisi-name-action 3)
        (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                   6 font-lock-function-name-face font-lock-function-name-face])
        (wisi-indent-action [nil
                             nil
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken ada-indent-broken
                             (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                             ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

generic_actual_part ::= '(' generic_association {',' generic_association} ')'

generic_association
  : [selector_name '=>'] explicit_generic_actual_parameter
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)
                           ada-indent-broken
                           (ada-indent-anchored-expression 2)]))%
  ;

explicit_generic_actual_parameter ::=
    expression
  ;; name ;; redundant <variable_>name
  ;; name ;; redundant <subprogram_>name
  ;; name ;; redundant <entry_>name
  ;; name ;; redundant subtype_mark
  ;; name ;; redundant <package_instance_>name

formal_object_declaration
  : defining_identifier_list ':' mode [null_exclusion] name [':=' default_expression] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-face-apply-action [5 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil
                           ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken
                           (ada-indent-anchored-expression 6) ada-indent-broken ada-indent-broken]))%
  | defining_identifier_list ':' mode access_definition [':=' default_expression] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 8 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                             (ada-indent-anchored-expression 5) ada-indent-broken ada-indent-broken]))%
  ;

formal_type_declaration : formal_complete_type_declaration | formal_incomplete_type_declaration ;

formal_complete_type_declaration
  : 'type' IDENTIFIER [discriminant_part] 'is' formal_type_definition [ 'or' 'use' name ] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 10 statement-end])
      (wisi-face-apply-action [2 nil font-lock-type-face
                                 8 nil font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken]))%
  ;

formal_incomplete_type_declaration
  : 'type' IDENTIFIER [discriminant_part] ['is' 'tagged'] ['or' 'use' name] ';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-face-apply-action [2 nil font-lock-type-face
                                 8 nil font-lock-type-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken]))%
  ;

formal_type_definition ::=
    formal_private_type_definition
  | formal_derived_type_definition
  | formal_discrete_type_definition
  | formal_signed_integer_type_definition
  | formal_modular_type_definition
  | formal_floating_point_definition
  | formal_ordinary_fixed_point_definition
  | formal_decimal_fixed_point_definition
  | formal_array_type_definition
  | formal_access_type_definition
  | formal_interface_type_definition

formal_private_type_definition ::= [['abstract'] 'tagged'] ['limited'] 'private'

formal_derived_type_definition
  : ['abstract'] ['limited' | 'synchronized'] 'new' name [['and' interface_list] 'with' 'private']
    %((wisi-face-apply-action [5 font-lock-function-name-face font-lock-type-face]))%
  ;

formal_discrete_type_definition ::= '(' '<>' ')'

formal_signed_integer_type_definition ::= 'range' '<>'

formal_modular_type_definition ::= 'mod' '<>'

formal_floating_point_definition ::= 'digits' '<>'

formal_ordinary_fixed_point_definition ::= 'delta' '<>'

formal_decimal_fixed_point_definition ::= 'delta' '<>' 'digits' '<>'

formal_array_type_definition ::= array_type_definition

formal_access_type_definition ::= access_type_definition

formal_interface_type_definition ::= interface_type_definition

formal_subprogram_declaration : formal_concrete_subprogram_declaration | formal_abstract_subprogram_declaration ;

formal_concrete_subprogram_declaration
  : 'with' subprogram_specification ['is' subprogram_default] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

formal_abstract_subprogram_declaration
  : 'with' subprogram_specification 'is' 'abstract' [subprogram_default] [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-indent-action [nil nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken]))%
  ;

subprogram_default ::= default_name | '<>' | 'null'

default_name ::= name

formal_package_declaration
  : 'with' 'package' IDENTIFIER 'is' 'new' name formal_package_actual_part [aspect_specification] ';'
    %((wisi-statement-action [1 statement-start 9 statement-end])
      (wisi-face-apply-action [3 font-lock-function-name-face font-lock-function-name-face
                                 6 font-lock-function-name-face font-lock-function-name-face])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

formal_package_actual_part
  : '(' ['others' '=>'] '<>' ')'
  | [generic_actual_part]
  | '(' formal_package_association {',' formal_package_association} [',' 'others' '=>' '<>'] ')'
  ;

formal_package_association : generic_association | selector_name '=>' '<>' ;

aspect_clause ::=
    attribute_definition_clause
  | enumeration_representation_clause
  | record_representation_clause
  | at_clause

  ;; local_name ::= ;; inlined to "name"; redundant with attribute_designator in name
  ;;     direct_name tick attribute_designator
  ;;   | name

aspect_mark_list : aspect_mark ['=>' aspect_definition] {',' aspect_mark ['=>' aspect_definition] } ;

aspect_specification
  : 'with' aspect_mark_list
    %((wisi-indent-action [nil ada-indent-broken]))%
  ;

aspect_mark ::= IDENTIFIER [tick IDENTIFIER]
  ;; FIXME: "class" changed to IDENTIFIER so foo'class is legal
  ;; elsewhere; need %local_keyword "class" => in-parse action?

aspect_definition ::=
  ;; name ;; redundant with expression
    expression
  ;; IDENTIFIER ;; redundant with expression
  ;; aggregate ;; redundant with expression
  | global_aspect_definition

attribute_definition_clause
  : 'for' name tick attribute_designator 'use' expression ';'
    %((wisi-statement-action [1 statement-start 7 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken nil]))%

  ;; 'for' name tick attribute_designator 'use' name ';' ;;:redundant with expression
  ;

enumeration_representation_clause
  : 'for' name 'use' enumeration_aggregate ';'
    %((wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-face-apply-action [2 font-lock-function-name-face font-lock-type-face])
      (wisi-indent-action [nil
                           (wisi-hanging%- ada-indent-broken (* 2 ada-indent-broken))
                           ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

enumeration_aggregate : array_aggregate ;

record_representation_clause ::= 'for' name 'use' 'record' [mod_clause] {component_clause} 'end' 'record' [name] ';'

component_clause
  : name 'at' position 'range' first_bit '..' last_bit ';'
    %((wisi-statement-action [1 statement-start 8 statement-end])
      (wisi-indent-action [nil ada-indent-broken ada-indent-broken ada-indent-broken ada-indent-broken
                               ada-indent-broken ada-indent-broken ada-indent-broken]))%
  ;

position : expression ;

first_bit : simple_expression ;

last_bit : simple_expression ;

;; code_statement ;;:deleted; redundant with procedure_call_statement
;; ::= qualified_expression ';'

;; storage_pool_indicator ;;:deleted; not used in the grammar
;; ::= name | 'null' | Standard

;; restriction ;;:deleted; not used in the grammar
;; ::= IDENTIFIER | IDENTIFIER '=>' restriction_parameter_argument

;; restriction_parameter_argument ;;:deleted; not used in the grammar
;; ::= name | expression

extended_global_aspect_definition ::=
    'use' formal_parameter_designator
  | 'do' dispatching_operation_specifier

extended_global_aspect_element ::=
    'use' formal_parameter_set
  | 'do' dispatching_operation_set

extended_global_mode ::= 'overriding' basic_global_mode

formal_parameter_designator ::=
    formal_group_designator
  | name

formal_parameter_set ::=
    formal_group_designator
  | name {',' name}

formal_group_designator ::= 'null' | 'all' ;

;; formal_parameter_name ::= ;; inlined to "name"
;;     subtype_mark
;;   | name
;;   | name

dispatching_operation_set ::= dispatching_operation_specifier {',' dispatching_operation_specifier}

dispatching_operation_specifier ::= name  '(' name ')'

delta_constraint ::= 'delta' simple_expression [range_constraint]

at_clause
  : 'for' direct_name 'use' 'at' expression ';'
    %((wisi-statement-action [1 statement-start 6 statement-end]))%
  ;

mod_clause ::= 'at' 'mod' expression ';'

;; end of file
