\input texinfo  @c -*-texinfo-*-
@settitle Wisi

@copying
Copyright @copyright{} 1999 - 2020  Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory Emacs
@direntry
* Wisi: (wisi).         Error-correcting LR parsers and project integration.
@end direntry

@titlepage
@sp 10
@title Wisi Version 3.1.2
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Top

Wisi Version 3.1.2
@end ifnottex

@menu
* Overview::
* Grammar actions::
* Project extension::
* GNU Free Documentation License::
* Index::
@end menu

@node Overview
@chapter Overview
``wisi'' used to be an acronym, but now it's just a name.

The wisi package provides an elisp interface to an external parser. It
assumes the parser generator package WisiToken
(@url{http://stephe-leake.org/ada/wisitoken.html}, implemented in
Ada), but can use any parser that meets the same API. wisi provides
several grammar actions, to implement indentation, navigating, and
syntax highlighting (fontification).

wisi also provides an extension to Emacs @file{project.el}, providing
operations useful for compilation and cross-reference.

@node Grammar actions
@chapter Grammar Actions

Grammar actions are specified in the grammar file, in a nonterminal
declaration. We assume the user is familiar with parser grammars and
grammar actions. For example, a simple ``if'' statement can be
declared as:

@example
if_statement
  : IF expression THEN statements elsif_list ELSE statements END IF SEMICOLON
    %((wisi-statement-action [1 statement-start 3 motion 6 motion 10 statement-end])
      (wisi-motion-action [1 3 5 6 10])
      (wisi-indent-action [nil
                           [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                            ada-indent-broken]
                           nil
                           [ada-indent ada-indent] nil nil
                           [ada-indent ada-indent] nil nil nil]))%
@end example

The item before @code{:} is the ``left hand side'', or
``nonterminal''. The list of tokens after @code{:} is the ``right hand
side''; in general there can be more than one right hand side for each
nonterminal (separated by @code{|}).

The items enclosed in ``%()%'' are the grammar actions. They are
specified as list of elisp forms; an earlier version of the wisi
package generated an elisp parser. We keep the elisp form because it
is compact, and easier to read and write than the equivalent Ada
code. The @code{wisi-bnf-generate} tool converts the elisp into the
required Ada statements.

There are two classes of actions; in-parse and post-parse. WisiToken
calls these ``semantic checks'' and ``semantic actions''. The in-parse
actions are done as parsing procedes; they provide extra checks that
can cause the parse to fail. Currently the only one provided is
@code{match-names}; it is used to check that the declaration and end
names in named Ada blocks are the same (which can aid significantly in
error correction). In the grammar file, in-parse actions are specified
in a second @code{%()%} block, which can be omitted if empty. In this
document, the term ``action'' generally means ``post-parse action'',
we use ``in-parse action'' unless the meaning is clear from context.

Executing the wisi grammar actions creates text properties in the
source file; those text properties are then used by elisp code for
various purposes. The text properties created are:

@table @code
@item wisi-cache
This should be named @code{wisi-navigate}, but isn't for historical
reasons (there used to be only one kind of text property).

The property contains a @code{wisi-cache} object, containing:

@table @code
@item nonterm
The nonterminal in the grammar production that specified the action
that produced this text property.

@item token
A token identifier naming a token in the production right hand side
containing the text this text property is applied to.

@item last
The position of the last character in the token, relative to the first
character (0 indexed). The text property is only applied to the first
character in the token (mostly for historical reasons).

@item class
A token class; see the list of possible values in
@code{wisi-statement-action} below.

@item containing
A marker pointing to the start of the containing token for this token;
only @code{nil} for the outermost containing token in a file.

@item prev
A marker pointing to the previous ``motion token'' in the statement or
declaration. These are normally language keywords, but can be other
things.

@item next
A marker pointing to the next ``motion token'' in the statement or
declaration.

@item end
A marker pointing to the end of the statement or declaration.

@end table

wisi provides motion commands for going to the various markers.

@item wisi-name
Contains no data, applied to a ``name'' of some sort. wisi provides
commands for finding the next/previous name, and returning the
text. Useful for the names of subprograms, which can then be used to
build a completion table; see @code{wisi-xref-identifier-completion-table}.

@item font-lock-face
The standard font-lock property, specifying the face for the
text.

Some major modes do not use this for simple keywords; they use
font-lock regular expressions instead. One reason for this
is so keywords are still highlighted when the parser fails, which
can happen if there are severe syntax errors.

Other items, like function and package names, are typically marked
with @code{font-lock-face} by the parser.

@item fontified
Another standard font-lock text property; applied whenever
@code{font-lock-face} is.

@item wisi-indent
Contains the indent (in characters) for the next line; applied to
the newline character on the preceding line. The first line in a
buffer is assumed to have indent 0.

@end table

Each action is classified as one of @code{navigate, face, indent,
in-parse}; when actions are executed, only one of the first three classes
is executed (in-parse is always executed). This reflects the reasons
the parser is run; to figure out how to go somehere (end of current
statement, start of current procedure, etc), to apply faces for syntax
highlighting, or to indent the code.

@menu
* Navigate actions::
* Face actions::
* Indent actions::
* In-parse actions::
@end menu

@node Navigate actions
@section Navigate actions
@table @code
@item wisi-statement-action [TOKEN CLASS ...]
The argument is a vector; alternating items are a token index (an
integer or label indicating a token in the right hand side) and a
``token class''; one of:

@table @code
@item motion
Create a @code{wisi-cache} text property on the token, for use in a
subsequent @code{wisi-motion-action}.

@item statement-end
Create a @code{wisi-cache} text property on the token, enter a pointer
to it in the other @code{wisi-cache} objects in the statement or
declaration.

@item statement-start
Create a @code{wisi-cache} text property on the token, enter a pointer
to it in the other @code{wisi-cache} objects (in the @code{containing}
slot) in the statement or declaration.

@item statement-override
Same as @code{statement-start}; marks the token to be used as the
statement start if the first token is optional.

@item misc
Create a @code{wisi-cache} text property on the token, to be used for
some other purpose. It is good style to indicate the purpose in a
comment.

For example, ada-mode uses a 'misc' property on left parentheses that
start a subprogram parameter list; this distinquishes them from other
left parentheses, and makes it possible to automatically call
@code{ada-format-paramlist} to format the
parameter list, instead of using the standard Emacs @code{align}.

@end table

@item wisi-motion-action [TOKEN ...]
The argument is a vector, where each element is either a token index
or a vector [INDEX ID].

Each terminal token must already have a @code{wisi-cache} created by a
@code{wisi-statement-action} (this is checked at action execution, not
during grammar generation). This action sets the @code{prev, next}
slots for the chain of tokens, creating a chain of motion tokens.

If TOKEN is a nonterminal without an ID specified, the @code{wisi-cache}
must be on the first token in the nonterminal, and it is assumed to
have a valid pointer in the @code{next} slot, indicating a chain of
motion tokens. That chain is linked into the chain for the current
right hand side.

If TOKEN is a nonterminal with an ID, the region contained by the
nonterminal is searched for all @code{wisi-cache} with that token ID,
and for each one where prev/next is not already set, it is linked into
the motion chain.

Note that the ``search'' described here is done in the parser process, on
a tree data structure containing the data that will eventually be
stored in Emacs text properties.

@item wisi-name-action TOKEN
TOKEN is a token index. Create a @code{wisi-name} text property on the
the @code{char_region} of the token.

@end table

@node Face actions
@section Face actions
@table @code
@item wisi-face-mark-action [INDEX CLASS ...]
The argument is a vector; alternating elements form pairs of INDEX
CLASS, where class is one of @code{prefix, suffix}.

Mark the tokens as part of a compound name, for use by later face
actions.

@item wisi-face-apply-action [TOKEN PREFIX-FACE SUFFIX-FACE ...]
The argument is a vector; triples of items specify TOKEN,
PREFIX-FACE, SUFFIX-FACE. The faces are the elisp names of face
objects (which must declared by an @code{%elisp_face} declaration).

If the token is a nonterminal, and it has been marked by a previous
@code{wisi-face-mark-action}, the specified faces are applied to the
prefix and suffix in the token as @code{font-lock-face} text
properties.

If the token is a terminal, or a non-terminal with no face mark, the
suffix face is applied to the entire text contained by the token.

@item wisi-face-apply-list-action [TOKEN PREFIX-FACE SUFFIX-FACE ...]
Similar to ’wisi-face-apply-action’, but applies faces to all tokens
marked by @code{wisi-face-mark-action} in each indicated production
token, and does not apply a face if there are no such marks.

@end table

@node Indent actions
@section Indent actions

Indents are computed for each line in a cumulative way as the grammar
actions are executed. Initially, each indent is set to @code{nil},
which means ``not computed''; this is not the same as the value
@code{0}. The grammar actions are executed in a bottom-up fashion; low
level productions are executed before higher level ones. In general,
the indent action for a production specifies a ``delta indent''; the
indent for a line is incremented by that amount. When all productions
have been processed, the indent has been computed for all lines.

Indents are often given as a function call; the arguments to the
function can be other function calls, or integer
expressions. @code{wisitoken-bnf-generate} supports only simple integer
expressions; those using integers, integer-valued variables,
parenthesis, + (plus), - (minus), and * (multiply).

@table @code
@item wisi-indent-action [INDENT ...]
The argument is a vector, giving an indent for each token in the
production right-hand side.

For terminals, the indents only have meaning, and are only computed,
if the token is the first on a line. For nonterminals, the indent is
applied to all contained tokens that are the first on a
line.

An indent can have several forms.  In the descriptions below, the
``current token'' is given by the position of the indent expression in
the @code{wisi-indent-action} argument list.

@table @asis
@item An integer
This gives a delta indent; it is added to the total indent for the
line.

@item A variable name
An integer delta indent; the value can be changed at runtime.

The variable is an elisp variable; the name is translated to an Ada
identifier by replacing ``-'' with ``_'', and applying
@code{Camel_Case}. The translated name must identify a directly
visible run-time Ada integer variable; this is checked at Ada compile
time. The elisp variable value is copied to the Ada variable value at
the start of a parse.

For example, in Ada two indent variable names are @code{ada-indent}
and @code{ada-indent-broken}, giving the basic ident, and the
continuation line indent. They are runtime variables so different
projects can specify them as part of a coding standard.

@item A function call
A function that computes a delta indent. See @ref{Indent functions}.

@item [CODE-INDENT , COMMENT-INDENT]
A vector giving separate indents for code and comments.

Normally, the indent for trailing comments (on lines with no code,
after all code in the token) is given by the indent of the following
token in the production. When the current token is the last, or the
following tokens may be empty, or the indent of the following token
would be wrong for some reason (for example, it is a block end), the
comment indent may be specified separately. If it is not specified,
and the indent from the next token is not available, the indent for
the current token is used for code and comments.

Comment lines that are not trailing are indented by CODE-INDENT.

@item (label . INDENT)
Specifies that the indent applies to the token with the same label. If
any argument in an indent action is labeled, all must be labeled, and
thus all tokens in the production must be labeled. This
can improve readability in a long production.

When the grammar file uses EBNF meta-syntax, implicit labels are
automatically generated for all tokens, unless they are explicitly
specified; this allows keeping track of which optional tokens are left
out when the production is converted to BNF internally.

@end table

@end table

@menu
* Indent functions::
* Indent example::
@end menu

@node Indent functions
@subsection Indent functions
@table @code
@item wisi-anchored ANCHOR OFFSET
Sets the indent for the current token to be OFFSET (an integer
expression) from the start of ANCHOR (a token index). Previously
accumulated delta indents for the current token are ignored, as are
subsequent delta indents; the current token is ``anchored to'' ANCHOR.

A comment is indented the same as the last line of ANCHOR.

If two or more anchor indents apply to a token, only the innermost one
(the first one applied) is used.

@c FIXME: delete comments
@c @item wisi-anchored- ANCHOR OFFSET
@c Same as @code{wisi-anchored}, but does not change the indent if the
@c accumulated indent for the current token is not nil.

@item wisi-anchored% ANCHOR OFFSET
If there is an opening parenthesis containing ANCHOR in the line
containing ANCHOR, sets the indent for the current token to OFFSET from
that parenthesis; the current token is anchored to the
parenthesis. Otherwise, sets the delta indent to OFFSET; the current
token is not anchored.

@c @item wisi-anchored%- ANCHOR OFFSET
@c Same as @code{wisi-anchored%}, but does not change indent if the
@c accumulated indent for the current token is not nil.

@item wisi-anchored* ANCHOR OFFSET
The same as @code{wisi-anchored}, but the anchor point is the start of
the line containing ANCHOR.

@item wisi-hanging DELTA-1 DELTA-2
The current token is assumed to be a nonterminal. If the text it
contains spans multiple lines, use DELTA-1 for the first line, DELTA-2
for the rest. If the current token is only on one line, use DELTA-1.

DELTA-1 and DELTA-2 can be any IDENT expression, except a variant of
@code{wisi-hanging}.

@item wisi-hanging- DELTA-1 DELTA-2
Same as @code{wisi-hanging}, but no indent if the accumulated indent
for the current token is not nil.

@item wisi-hanging% DELTA-1 DELTA-2
Similar to @code{wisi-hanging}; if the first terminal token in the
current nonterminal is the first token on the first line, use DELTA-1
for the first line and DELTA-2 for the rest. Otherwise, use DELTA-1
for all lines.

@item wisi-hanging%- DELTA-1 DELTA-2
Same as @code{wisi-hanging%}, except applied only if the current token
accumulated indent is nil.

@item Language-specific function
Language-specific indent functions are specified by an
@code{%elisp_indent} declaration in the grammar file. Each function
specifies how many arguments it accepts; this is checked at action
runtime, not during grammar generation. Each argument is an INDENT as
described above, or a token ID prefixed by @code{'} (to allow
distinguishing token IDs from variable names).
@end table

@node Indent example
@subsection Indent example
To illustrate how indents are computed, we compute it for some example
code.

The simple grammar used for this example is:

@example
if_statement
  : 'if' expression 'then' statements 'end' 'if' ';'
    %((wisi-indent-action [nil
                           ada-indent-broken
                           nil
                           [ada-indent ada-indent]
                           nil nil nil]))%

expression
  : term
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)]))%

term
  : primary
  | primary '+' primary
  | primary '<' primary
  | term 'and' term

primary : integer | identifier | function_call

function_call
  : identifier formal_part
    %((wisi-indent-action [nil ada-indent-broken]))%

formal_part
  : '(' expression_list ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 0)]))%

expression_list : expression | expression_list ',' expression

statements : statement | statements statement

statement : function_call ';' | assigment | if_statment

assignment
  : identifier ':=' expression ';'
    %((wisi-indent-action nil ada-indent-broken ada-indent-broken nil))%
@end example

The indent variables have the values:
@example
ada-indent 3
ada-indent-broken 2
@end example

The example Ada code:

@example
 1: if A < B and
 2:   C < D
 3:   --  comment on expression
 4: then
 5:    Do_E;
 6:    -- comment on statement
 7:
 8:    G := F + Compute_Something
 9:      (Arg_1,
10:       Arg_2);
11:
12:    -- comment before 'end if'
13: end if;
@end example

The syntax tree produced by parsing this code, node numbers on the
left for reference. Note that comments are stored in the node
containing the terminal token node preceding the comment. Node 20
'formal_part' is empty; ``Do_E'' has no arguments.
@example
 1  if_statement
 2    'if'
 3    expression
 4      term
 5        primary
 6          identifier "A"
 7        '<'
 8        primary
 9          identifier "B"
10      'and'
11      term
12        primary
13          identifier "C"
14        '<'
15        primary
16          identifier "D", "--  comment on expression"
17    'then'
18    statements
19      statements
20        statement
21          function_call
22            identifier "Do_E"
23          formal_part
24          ';' "-- comment on statement", blank line
25      statement
26        assignment
27          identifier "G"
28          ':='
29          expression
30            term
31              primary
32                identifier "F"
33              '+'
34              primary
35                function_call
36                  identifier "Compute_Something"
37                  formal_part
38                    '('
39                    expression_list
40                      expression_list
41                        expression
42                          term
43                            primary
44                              identifier "Arg_1"
45                      ','
46                      expression
47                        term
48                          primary
49                            identifier "Arg_2"
50                    ')'
51          ';', blank line, "-- comment before 'end if'"
52    'end'
53    'if'
54    ';'
@end example

Actions are computed by traversing the tree depth first. Thus the
first node considered is node 6; it is an @code{identifier}, which is
a terminal token and has no post-parse action. The next nodes
considered are 5, 7, 9, 8, 4, 10, 13, 12, 14, 16, 15; all have no
action. Next is node 3, the @code{expression} @code{A < B and C < D}
on lines 1 and 2.

The indent action for @code{expression} is
@example
   [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
    ada-indent-broken]
@end example
This gives separate indents for the code and the trailing comment.
The code is @code{A < B and C < D}, on lines 1 and 2, with
a trailing comment of @code{--  comment on expression} on line 3. Since the
first line of the expression follows @code{if}, it is not first on
the line; thus @code{wisi-hanging} gives a delta indent of 2 for line
2, leaving line 1 at nil.

The comment on line 3 is given an indent of 2. Note that if the
comment indent had not been given separately in this indent action, it
would have been given the indent of the next token, which is nil.

The next action computed is node 21 @code{function_call} @code{Do_E;}
on line 5. The indent action is @code{%((wisi-indent-action [nil
ada-indent-broken]))%}; since the code is all on one line this leaves
the indent for line 5 at nil. The indent for the trailing comment and
blank line on lines 6 and 7 are also left at nil.

Next is node 41 @code{expression} @code{Arg_1} line 9; it is all on one line
and not the first token, so the indent is left at nil. Similarly for
node 49 @code{expression} @code{Arg_2} line 10.

At this point, the indents for all are the lines are (the indent is
given after the line number):
@example
 1: nil : if A < B and
 2:   2 :   C < D
 3:   2 :   --  comment on expression
 4: nil : then
 5: nil :    Do_E;
 6: nil :    -- comment on statement
 7: nil :
 8: nil :    G := A + Compute_Something
 9: nil :      (Arg_1,
10: nil :       Arg_2);
11: nil :
12: nil :    -- comment before 'end if'
13: nil : end if;
@end example

Next indent action is node 37 @code{formal_part} @code{(Arg_1, Arg_2)}
lines 9 and 10. The indent action is
@example
%((wisi-indent-action [nil
                       (wisi-anchored 1 1)
                       (wisi-anchored 1 0)]))%
@end example
This computes a delta indent for the @code{expression_list} of
@code{Anchored, 9, 1)}; anchored to line 9 with an offset of 1. This
delta indent is applied to the current indents for the lines covered
by the @code{expression_list}; that is just line 10. Since the indent
for line 10 is currently nil, it is set to @code{Anchored, 9, 1)}.

Next is node 35 @code{function_call} @code{Compute_Something (Arg_1,
Arg_2)} on lines 9 and 10. The indent action is
@code{%((wisi-indent-action [nil ada-indent-broken]))%}, which gives
a delta indent of 2 for the @code{formal_part}. This is applied to
lines 9 and 10, leaving line 9 at 2, and 10 unchanged at
@code{Anchored, 9, 1)}.

Next is node 29 @code{expression} @code{F +
Compute_Something (Arg_1, Arg_2)} on lines 8, 9 and 10; this computes
a delta indent 2 for lines 9 and 10, leaving 9 at 4 (FIXME: WRONG!) and 10 unchanged.

Next is node 16 @code{assignment} on lines 8, 9, 10; this computes a
delta indent of 2 for the @code{expression}, and nil for @code{;},
which is applied to lines 9 thru 12. The blank line and comment one
lines 11 and 12 are stored in node 51, which is in the
@code{assignment} nonterminal, and there is no following token in the
production, so the indent of ';' is computed for them. This leaves 9
at 6 (FIXME: WRONG!), 10 thru 12 unchanged.

At this point, the indents are:
@example
 1: nil          : if A < B and
 2:   2          :   C < D
 3:   2          :   --  comment on expression
 4: nil          : then
 5: nil          :    Do_E;
 6: nil          :    -- comment on statement
 7: nil          :
 8: nil          :    G := F + Compute_Something
 9: nil          :      (Arg_1,
10: Anchored 9 1 :       Arg_2);
11: nil          :
12: nil          :    -- comment before 'end if'
13: nil          : end if;
@end example

The final indent action is for node 1 @code{if_statement} on lines 1
thru 13. The indent for each token in the production is:

@table @code
@item if: nil
Leaves line 1 at nil.

@item expression: ada-indent-broken
Applies a delta indent of 2 to lines 1 and 2, leaving them at 4
(FIXME: WRONG!).

@item then: nil
Applies delta of nil to lines 3 and 4.

Note that specifying the indent for the comment following an
expression in the @code{expression} indent action enforces a style of
indenting the comment with the last line of the expression.

@item statements: [ada-indent ada-indent]
Applies a delta indent of 3 to the code and comment on lines 5 thru
10, and 3 to the trailing comment on lines 11 and 12.

Note that the indent for comments after statements is given here, not
at a lower level; it would be tedious to add it to each statement.

@item end if; : nil
Leaves line 13 at nil.
@end table

The indents so far:
@example
 1: nil          : if A < B and
 2:   2          :   C < D
 3:   2          :   --  comment on expression
 4: nil          : then
 5:   3          :    Do_E;
 6:   3          :    -- comment on statement
 7:   3          :
 8:   3          :    G := F + Compute_Something
 9:   5          :      (Arg_1,
10: Anchored 9 1 :       Arg_2);
11:   3          :
12:   3          :    -- comment before 'end if'
13: nil          : end if;
@end example

The final step is compute all the anchored lines; that sets the indent
for line 10 to 6.

In a full grammar, the top production should specify an indent of 0,
not nil, for tokens that are not indented; then every line will have a
non-nil indent.

However, in normal operation a nil indent is treated as 0; the
@code{wisi-indent} text property is not set for lines that have nil
indent, and @code{wisi-indent-region} detects that and uses 0 for the
indent. You can set the variable @code{wisi-debug} to a value > 0 to
signal an error for nil indents; this is useful to catch indent errors
during grammar development.

To further illustrate the rule for applying delta indents to indents,
consider the following code layout
@example
 column:           123456789
 1: nil          : G
 2: 2                :=
 3: 2                  F +
 4: 4                    Compute_Something
 5: 6            :         (Arg_1,
 6: Anchored 9 1 :          Arg_2);
@end example
This is the same assignment statement, but fully spread out on
different lines, as might be required if the names or subexpressions
are long. In this case, none of the delta indents are ignored when
applied to a line, which is why they all need to be present in the
indent actions.

The first indent action computed in this code is node 37
@code{formal_part} @code{(Arg_1, Arg_2)} lines 5, 6. As above, this
sets line 5 indent to nil, line 6 to @code{Anchored, 4, 1)}.

Next indent action is node 35 @code{function_call}
@code{Compute_Something (Arg_1, Arg_2)} on lines 4, 5, 6. This applies
a delta indent of 2 lines 5 and 6, leaving line 5 at 2, and 6
unchanged.

Next is node 29 @code{expression} @code{F + Compute_Something (Arg_1,
Arg_2)} on lines 3 .. 6; this computes a delta indent of nil for line
3, and 2 for lines 4 .. 6, leaving 3 at nil, 4 at nil, 5 at 4, and 6
unchanged.

Last indent action is node 16 @code{assignment} on lines 1 .. 6; this computes a
delta indent of 2 for ':=', applied to line 2, and 2 for the @code{expression},
applied to lines 3 .. 6. This gives the results shown.

@node In-parse actions
@section In-parse actions
@table @code

@item wisi-propagate-name TOKEN
The argument is a token index. Set the @code{name} component of the
left-hand-side parse-time token object to the @code{name} component of
the identified token, if it is not empty. Otherwise use the
@code{char_region} component.

@item wisi-merge-name FIRST-TOKEN, LAST-TOKEN
The arguments are token indices, giving a range of
tokens. LAST-TOKEN may be omitted if it is the same as FIRST-TOKEN.

Set the @code{name} component of the left-hand-side to the merger of
the @code{name} or @code{char_region} components of the identified tokens.

@item wisi-match-name START-TOKEN END-TOKEN
The arguments are token indices. Compare the text contained by the
@code{name} (or @code{char_region} if @code{name} is empty) token
components for START-TOKEN and END-TOKEN; signal a parse error if they
are different.

The behavior when a name is missing is determined by the runtime
language variable given in the @code{%end_names_optional_option}
declaration; if True, a missing name that is supposed to match a
present name is an error. Both names missing is not an error (assuming
that is allowed by the grammar).

@end table

@node Project extension
@chapter Project extension
wisi defines the @code{cl-defstuct} @code{wisi-prj}, with operations
suitable for compilation and cross-reference.

In order to use wisi projects, the user must write project files and
customize @code{project-find-functions} and
@code{xref-backend-functions}.

@menu
* Project files::
* Selecting projects::
* Casing exception files::
* Other project functions::
@end menu

@node Project files
@section Project files

Project file names must have an extension given by
@code{wisi-prj-file-extensions} (default @file{.adp, .prj}).

Project files have a simple syntax; they may be edited directly. Each
line specifies a project variable name and its value, separated by
``='':

@example
src_dir=/Projects/my_project/src_1
src_dir=/Projects/my_project/src_2
@end example

There must be no space between the variable name and ``='', and no
trailing spaces after the value.

Any line that does not have an ``='' is a comment.

Some variables (like @code{src_dir}) are lists; each line in the
project file specifies one element of the list. The value on the last
line is the last element in the list.

A variable name that starts with @code{$} is set as a process
environment variable, for processes launched from Emacs for the
project.

In values, process environment variables can be referenced
using the normal @code{$var} syntax.

In values, relative file names are expanded relative to the
directory containing the project file.

Here is the list of project variables defined by wisi; major modes may
add more.

@table @asis
@item @code{casing}         [slot: @code{case-exception-files}]
List of files containing casing exceptions. @xref{Casing exception files}.

@item @code{src_dir}        [slot: @code{source-path}]
A list of directories to search for source files.

@end table

@node Selecting projects
@section Selecting projects
The current project can either be indicated by a global variable
(called a ``selected project''), or depend on the current buffer.

In addition, the project file can be parsed each time it is needed, or
the result cached to improve response time,

One reason to use a selected project is to handle a hierarchy of
projects; if projects B and C both depend on library project A, then
when in a file of project A, there is no way to determine which of the
three projects to return. So the user must indicate which is active,
by using one of @code{wisi-prj-select-file} or
@code{wisi-prj-select-cache}.

In addition, if changing from one project to another requires setting
global resources that must also be unset (such as a syntax propertize
hook or compilation filter hook), then the project should define
@code{wisi-prj-deselect} in addition to @code{wisi-prj-select}. Such
projects require having a selected current project, so it can be
deselected before a new one is selected. One example of such projects
is ada-mode.

One way to declare each project is to add a Local Variables section
in the main Makefile for the project; when the Makefile is first
visited, the project is declared. In the examples here, we assume
that approach is used; each gives an :eval line.

Note that @code{wisi-prj-current-parse} and
@code{wisi-prj-current-cached} always succeed after some project is
selected; no functions after them on @code{project-find-functions} will
be called. That's why the depth is 90 for those in the examples.

@table @asis
@item No caching, current project depends on current buffer

@example
(add-hook 'project-find-functions #'wisi-prj-find-dominating-parse 0)

:eval (wisi-prj-set-dominating "foo.prj" (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-set-dominating} declares the name of a project file with a
default project object, and ensures that the current buffer file name
is in @code{wisi-prj--dominating}.

@code{wisi-prj-find-dominating-parse} looks for the filenames in
@code{wisi-prj--dominiating} in the parent directories of the current
buffer. When one is found, the associated project file is parsed,
using the default project object to dispatch to the appropriate
parsers. Then the final project object is returned.

@item Caching, current project depends on current buffer

@example
(add-hook 'project-find-functions #'wisi-prj-find-dominating-cached 0)

:eval (wisi-prj-cache-dominating "foo.prj" (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-cache-dominating} declares the project file, parses it,
and saves the project object in a cache indexed by the absolute
project file name.

@code{wisi-prj-find-dominating-cached} finds the dominating
project file, and retrieves the object from the cache.

@item No caching, last selected project is current

@example
(add-hook 'project-find-functions #'wisi-prj-current-parse 90)

:eval: (wisi-prj-select-file <prj-file> (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-select-file} sets the project file as the current
project, and saves the default project object.

@code{wisi-prj-current-parse} parses the current project file, using
the saved default project object, and returns the project object.

@item Caching, last selected project is current

@example
(add-hook 'project-find-functions #'wisi-prj-current-cached 90)

:eval: (wisi-prj-select-cache <prj-file> (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-select-cache} parses the project file, caches the
project object.

@code{wisi-prj-current-cached} returns the cached current project
object.

@end table

In addition, the user should set @code{xref-backend-functions}. Currently,
there is only one choice for wisi projects:

@example
(add-to-list 'xref-backend-functions #'wisi-prj-xref-backend 90)
@end example

@code{wisi-prj-xref-backend} returns the current wisi project object.

@node Casing exception files
@section Casing exception files
Each line in a case exception
file specifies the casing of one word or word fragment. If an
exception is defined in multiple files, the first occurrence is used.

If the word starts with an asterisk (@code{*}), it defines the casing
of a word fragment (or ``substring''); part of a word between two
underscores or word boundary.

For example:

@example
DOD
*IO
GNAT
@end example

The word fragment @code{*IO} applies to any word containing ``_io'';
@code{Text_IO}, @code{Hardware_IO}, etc.

@node Other project functions
@section Other project functions

@table @code
@item wisi-refresh-prj-cache (not-full)
Refreshes all cached data in the project, and re-selects the
project. If NOT-FULL is non-nil, slow refresh operations are skipped.

This reparses the project file, and any cross reference information.

@item wisi-prj-select-dominating (dominating-file)
  Find a wisi-prj matching DOMINATING-FILE (defaults to the current
buffer file). If the associated project is current, do nothing. If it
is not current, select it.

This is useful before running `compilation-start', to ensure the correct
project is current.

@end table

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include doclicense.texi

@node Index,  , GNU Free Documentation License, Top
@unnumbered Index

@printindex fn

@bye
