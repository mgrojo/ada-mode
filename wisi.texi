\input texinfo  @c -*-texinfo-*-
@settitle Wisi

@copying
Copyright @copyright{} 1999 - 2020  Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory Emacs
@direntry
* Wisi: (wisi).         Error-correcting LR parsers and project integration.
@end direntry

@titlepage
@sp 10
@title Wisi Version 3.1.2
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Top

Wisi Version 3.1.2
@end ifnottex

@menu
* Overview::
* Grammar actions::
* Project extension::
* GNU Free Documentation License::
* Index::
@end menu

@node Overview
@chapter Overview
``wisi'' used to be an acronym, but now it's just a name.

The wisi package provides an elisp interface to an external parser. It
assumes the parser generator package WisiToken
(@url{http://stephe-leake.org/ada/wisitoken.html}, implemented in
Ada), but can use any parser that meets the same API. wisi provides
several grammar actions, to implement indentation, navigating, and
syntax highlighting (fontification).

wisi also provides an extension to Emacs @file{project.el}, providing
operations useful for compilation and cross-reference.

@node Grammar actions
@chapter Grammar Actions

Grammar actions are specified in the grammar file, in a nonterminal
declaration. We assume the user is familiar with parser grammars and
grammar actions. For example, a simple ``if'' statement can be
declared as:

@example
if_statement
  : IF expression THEN statements elsif_list ELSE statements END IF SEMICOLON
    %((wisi-statement-action [1 statement-start 3 motion 6 motion 10 statement-end])
      (wisi-motion-action [1 3 5 6 10])
      (wisi-indent-action [nil
                           [(wisi-hanging% ada-indent-broken (* 2 ada-indent-broken))
                            ada-indent-broken]
                           nil
                           [ada-indent ada-indent] nil nil
                           [ada-indent ada-indent] nil nil nil]))%
@end example

The item before @code{:} is the ``left hand side'', or
``nonterminal''. The list of tokens after @code{:} is the ``right hand
side''; in general there can be more than one right hand side for each
nonterminal (separated by @code{|}).

The items enclosed in ``%()%'' are the grammar actions. They are
specified as list of elisp forms; an earlier version of the wisi
package generated an elisp parser. We keep the elisp form because it
is compact, and easier to read and write than the equivalent Ada
code. The @code{wisi-bnf-generate} tool converts the elisp into the
required Ada statements.

There are two classes of actions; in-parse and post-parse. WisiToken
calls these ``semantic checks'' and ``semantic actions''. The in-parse
actions are done as parsing procedes; they provide extra checks that
can cause the parse to fail. Currently the only one provided is
@code{match-names}; it is used to check that the declaration and end
names in named Ada blocks are the same (which can aid significantly in
error correction). In the grammar file, in-parse actions are specified
in a second @code{%()%} block, which can be omitted if empty. In this
document, the term ``action'' generally means ``post-parse action'',
we use ``in-parse action'' unless the meaning is clear from context.

Executing the wisi grammar actions creates text properties in the
source file; those text properties are then used by elisp code for
various purposes. The text properties created are:

@table @code
@item wisi-cache
This should be named @code{wisi-navigate}, but isn't for historical
reasons (there used to be only one kind of text property).

The property contains a @code{wisi-cache} object, containing:

@table @code
@item nonterm
The nonterminal in the grammar production that specified the action
that produced this text property.

@item token
A token identifier naming a token in the production right hand side
containing the text this text property is applied to.

@item last
The position of the last character in the token, relative to the first
character (0 indexed). The text property is only applied to the first
character in the token (mostly for historical reasons).

@item class
A token class; see the list of possible values in
@code{wisi-statement-action} below.

@item containing
A marker pointing to the start of the containing token for this token;
only @code{nil} for the outermost containing token in a file.

@item prev
A marker pointing to the previous ``motion token'' in the statement or
declaration. These are normally language keywords, but can be other
things.

@item next
A marker pointing to the next ``motion token'' in the statement or
declaration.

@item end
A marker pointing to the end of the statement or declaration.

@end table

wisi provides motion commands for going to the various markers.

@item wisi-name
Contains no data, applied to a ``name'' of some sort. wisi provides
commands for finding the next/previous name, and returning the
text. Useful for the names of subprograms, which can then be used to
build a completion table; see @code{wisi-xref-identifier-completion-table}.

@item font-lock-face
The standard font-lock property, specifying the face for the
text.

Some major modes do not use this for simple keywords; they use
font-lock regular expressions instead. One reason for this
is so keywords are still highlighted when the parser fails, which
can happen if there are severe syntax errors.

Other items, like function and package names, are typically marked
with @code{font-lock-face} by the parser.

@item fontified
Another standard font-lock text property; applied whenever
@code{font-lock-face} is.

@item wisi-indent
Contains the indent (in characters) for the next line; applied to
the newline character on the preceding line. The first line in a
buffer is assumed to have indent 0.

@end table

Each action is classified as one of @code{navigate, face, indent,
in-parse}; when actions are executed, only one of the first three classes
is executed (in-parse is always executed). This reflects the reasons
the parser is run; to figure out how to go somehere (end of current
statement, start of current procedure, etc), to apply faces for syntax
highlighting, or to indent the code.

@menu
* Navigate actions::
* Face actions::
* Indent actions::
* In-parse actions::
@end menu

@node Navigate actions
@section Navigate actions
@table @code
@item wisi-statement-action [TOKEN CLASS ...]
The argument is a vector; alternating items are a token index (an
integer or label indicating a token in the right hand side) and a
``token class''; one of:

@table @code
@item motion
Create a @code{wisi-cache} text property on the token, for use in a
subsequent @code{wisi-motion-action}.

@item statement-end
Create a @code{wisi-cache} text property on the token, enter a pointer
to it in the other @code{wisi-cache} objects in the statement or
declaration.

@item statement-start
Create a @code{wisi-cache} text property on the token, enter a pointer
to it in the other @code{wisi-cache} objects (in the @code{containing}
slot) in the statement or declaration.

@item statement-override
Same as @code{statement-start}; marks the token to be used as the
statement start if the first token is optional.

@item misc
Create a @code{wisi-cache} text property on the token, to be used for
some other purpose. It is good style to indicate the purpose in a
comment.

For example, ada-mode uses a 'misc' property on left parentheses that
start a subprogram parameter list; this distinquishes them from other
left parentheses, and makes it possible to automatically call
@code{ada-format-paramlist} to format the
parameter list, instead of using the standard Emacs @code{align}.

@end table

@item wisi-motion-action [TOKEN ...]
The argument is a vector, where each element is either a token index
or a vector [INDEX ID].

Each terminal token must already have a @code{wisi-cache} created by a
@code{wisi-statement-action} (this is checked at action execution, not
during grammar generation). This action sets the @code{prev, next}
slots for the chain of tokens, creating a chain of motion tokens.

If TOKEN is a nonterminal without an ID specified, the @code{wisi-cache}
must be on the first token in the nonterminal, and it is assumed to
have a valid pointer in the @code{next} slot, indicating a chain of
motion tokens. That chain is linked into the chain for the current
right hand side.

If TOKEN is a nonterminal with an ID, the region contained by the
nonterminal is searched for all @code{wisi-cache} with that token ID,
and for each one where prev/next is not already set, it is linked into
the motion chain.

Note that the ``search'' described here is done in the parser process, on
a tree data structure containing the data that will eventually be
stored in Emacs text properties.

@item wisi-name-action TOKEN
TOKEN is a token index. Create a @code{wisi-name} text property on the
the @code{char_region} of the token.

@end table

@node Face actions
@section Face actions
@table @code
@item wisi-face-mark-action [INDEX CLASS ...]
The argument is a vector; alternating elements form pairs of INDEX
CLASS, where class is one of @code{prefix, suffix}.

Mark the tokens as part of a compound name, for use by later face
actions.

@item wisi-face-apply-action [TOKEN PREFIX-FACE SUFFIX-FACE ...]
The argument is a vector; triples of items specify TOKEN,
PREFIX-FACE, SUFFIX-FACE. The faces are the elisp names of face
objects (which must declared by an @code{%elisp_face} declaration).

If the token is a nonterminal, and it has been marked by a previous
@code{wisi-face-mark-action}, the specified faces are applied to the
prefix and suffix in the token as @code{font-lock-face} text
properties.

If the token is a terminal, or a non-terminal with no face mark, the
suffix face is applied to the entire text contained by the token.

@item wisi-face-apply-list-action [TOKEN PREFIX-FACE SUFFIX-FACE ...]
Similar to ’wisi-face-apply-action’, but applies faces to all tokens
marked by @code{wisi-face-mark-action} in each indicated production
token, and does not apply a face if there are no such marks.

@end table

@node Indent actions
@section Indent actions

Indents are computed for each line in a cumulative way as the grammar
actions are executed. Initially, the indent for all lines are set to @code{nil},
which means ``not computed''; this is not the same as the value
@code{0}. The grammar actions are executed in a bottom-up fashion; low
level productions are executed before higher level ones. In general,
the indent action for a production specifies a ``delta indent''; the
indent for a line is incremented by that amount. When all productions
have been processed, the indent has been computed for all lines.

Indent actions specify a delta indent for each token in a
production. If the token is a nonterminal, it can contain multiple
lines of text; the delta indent applies to the lines whose first
tokens are contained by the nonterminal.

When a delta indent applied to the indent for a line, it is either
added or ignored. We call the token whose delta indent is being
applied the ``controlling'' token. The indent for each line has a
field storing the line number of the last controlling token that added
to the indent. If the line number of the controlling token for the
delta indent begin applied is the same as the stored controlling token
line number, the indent is ignored. @ref{Indent example} for
explanations of why this rule is needed.

Indents are often given as a function call; the arguments to the
function can be other function calls, or integer
expressions. @code{wisitoken-bnf-generate} supports only simple integer
expressions; those using integers, integer-valued variables,
parenthesis, + (plus), - (minus), and * (multiply).

@table @code
@item wisi-indent-action [INDENT ...]
The argument is a vector, giving an indent for each token in the
production right-hand side.

For terminals, the indents only have meaning, and are only computed,
if the token is the first on a line. For nonterminals, the indent is
applied to all contained tokens that are the first on a
line.

An indent can have several forms.  In the descriptions below, the
``current token'' is given by the position of the indent expression in
the @code{wisi-indent-action} argument list.

@table @asis
@item An integer
This gives a delta indent; it is added to the total indent for the
line.

@item A variable name
An integer delta indent; the value can be changed at runtime.

The variable is an elisp variable; the name is translated to an Ada
identifier by replacing ``-'' with ``_'', and applying
@code{Camel_Case}. The translated name must identify a directly
visible run-time Ada integer variable; this is checked at Ada compile
time. The elisp variable value is copied to the Ada variable value at
the start of a parse.

For example, in Ada two indent variable names are @code{ada-indent}
and @code{ada-indent-broken}, giving the basic ident, and the
continuation line indent. They are runtime variables so different
projects can specify them as part of a coding standard.

@item A function call
A function that computes a delta indent. See @ref{Indent functions}.

@item [CODE-INDENT , COMMENT-INDENT]
A vector giving separate indents for code and comments.

Normally, the indent for trailing comments (on lines with no code,
after all code in the token) is given by the indent of the following
token in the production. When the current token is the last, or the
following tokens may be empty, or the indent of the following token
would be wrong for some reason (for example, it is a block end), the
comment indent may be specified separately. If it is not specified,
and the indent from the next token is not available, the indent for
the current token is used for code and comments.

Comment lines that are not trailing are indented by CODE-INDENT.

@item (label . INDENT)
Specifies that the indent applies to the token with the same label. If
any argument in an indent action is labeled, all must be labeled, and
thus all tokens in the production must be labeled. This
can improve readability in a long production.

When the grammar file uses EBNF meta-syntax, implicit labels are
automatically generated for all tokens, unless they are explicitly
specified; this allows keeping track of which optional tokens are left
out when the production is converted to BNF internally.

@end table

@end table

@menu
* Indent functions::
* Indent example::
@end menu

@node Indent functions
@subsection Indent functions
@table @code
@item wisi-anchored ANCHOR OFFSET
Sets the delta indent for the current token to be OFFSET (an integer
expression) from the start of ANCHOR (a token index). Subsequent delta
indents are ignored; the current token is ``anchored to'' ANCHOR.

A comment is indented the same as the last line of ANCHOR.

@item wisi-hanging DELTA-1 DELTA-2
Use DELTA-1 for the first line, DELTA-2 for the rest.

DELTA-1 and DELTA-2 can be any ident expression, except a variant of
@code{wisi-hanging}.

@code{wisi-hanging} is useful when the lower level productions for the
current token do not have indent actions.

@item wisi-hanging% DELTA-1 DELTA-2
If the first token in the nonterminal is first on its line, use
DELTA-1 for the first line, DELTA-2 for the rest. Otherwise, use
DELTA-1 for all lines.

@item Language-specific function
Language-specific indent functions are specified by an
@code{%elisp_indent} declaration in the grammar file. Each function
specifies how many arguments it accepts; this is checked at action
runtime, not during grammar generation. Each argument is an INDENT as
described above, or a token ID prefixed by @code{'} (to allow
distinguishing token IDs from variable names).
@end table

@node Indent example
@subsection Indent example
To illustrate how indents are computed, we compute it for some example
code.

The simple grammar used for this example is:

@example
if_statement
  : 'if' expression 'then' statements 'end' 'if' ';'
    %((wisi-indent-action [nil
                           ada-indent-broken
                           nil
                           [ada-indent ada-indent]
                           nil nil nil]))%

expression
  : term
    %((wisi-indent-action [(wisi-hanging nil ada-indent-broken)]))%

term
  : primary
  | primary '+' primary
  | primary '<' primary
  | term 'and' term

primary : integer | identifier | function_call

function_call
  : identifier formal_part
    %((wisi-indent-action [nil ada-indent-broken]))%

formal_part
  : '(' expression_list ')'
    %((wisi-indent-action [nil
                           (wisi-anchored 1 1)
                           (wisi-anchored 1 0)]))%

expression_list : expression | expression_list ',' expression

statements : statement | statements statement

statement : function_call ';' | assigment | if_statment

assign_value : ':=' expression

assignment
  : identifier assign_value ';'
    %((wisi-indent-action [nil (wisi-hanging ada-indent-broken (* 2 ada-indent-broken)) nil]))%
@end example

Note that we have split out @code{assign_value} from
@code{assignment}, so we can apply the @code{wisi-hanging} indent
function to it; see the first example below for an explanation of why
this is needed.

The indent variables have the values:
@example
ada-indent 3
ada-indent-broken 2
@end example

First we consider a simple example, with the line numbers and the line
indents on the left:
@example
 1: nil : G
 2: nil :   :=
 3: nil :     F +
 4: nil :       Compute_Something
 5: nil :         (Arg_1,
 6: nil :          H +
 7: nil :            I);
@end example
The assignment statement is fully spread out on different lines, as
might be required if the names or subexpressions are long. In this
case, none of the delta indents are ignored when applied to a line
(except anchored lines), which is why they all need to be present in
the indent actions. Thus we can leave out the stored controlling token
in the line indents for this example.

Indents are computed in bottom up order; the first indent action
computed in this code is for @code{expression} @code{H + I} lines 6
and 7:
@example
   [(wisi-hanging% nil ada-indent-broken) ada-indent-broken]
@end example
This gives separate indents for the code and a trailing comment; there
is no trailing comment in this example (there is one in the next
example). This gives a delta indent of nil for line 6, and 2 for line 7.

The next indent action is for @code{formal_part} @code{(Arg_1, H + I)}
lines 5, 6. The indent action is:
@example
%((wisi-indent-action [nil (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
@end example
For each token, the delta indent computed by this is:
@table code
@item ( : nil
Leaves line 5 at nil.

@item expression_list : (wisi-anchored 1 1)
The first @code{1} is the anchor token; the left parenthesis on line
5. The second @code{1} is the offset from the anchor; thus the delta
indent is @code{Anchored, 5, 1}; anchored to line 5 with an offset of
1. This delta indent is applied to the lines whose first tokens are
contained by the @code{expression_list}; that is lines 6 and 7. Line 6
indent is currently nil, so the indent is set to @code{Anchored, 5,
1}. Line 7 indent is currently 2, so that is added to 1, setting the
indent to @code{Anchored, 5, 3}.

@item ) : (wisi-anchored 1 1)
')' is not first on a line, so this leaves line 6 indent unchanged.
@end table

Next indent action is @code{function_call} @code{Compute_Something
(Arg_1, H + I)} on lines 4 .. 7. The indent action is
@code{%((wisi-indent-action [nil ada-indent-broken]))%}; this applies
a delta indent of 2 to the @code{formal_part} on lines 5 .. 7,
leaving line 5 at 4, and 6 and 7 unchanged.

Next is @code{expression} @code{F + Compute_Something (Arg_1, H + I)}
on lines 3 .. 7.  This computes a delta indent of nil for line 3, and
2 for lines 4 .. 7, leaving 3 at nil, 4 at 2, 5 at 6, and 6 and 7
unchanged.

Last indent action is node 16 @code{assignment} on lines 1 .. 6; the
indent is @code{(wisi-hanging ada-indent-broken (* 2
ada-indent-broken))}, applied to all the lines contained by
@code{assign_value}, which is lines 2 thru 7. This gives a delta
indent of 2 for line 2, and 4 for lines 3 .. 7. This gives the
indents:
@example
 column            : 12345678901
 1: nil            : G
 2: 2              :   :=
 3: 4              :     F +
 4: 6              :       Compute_Something
 5: 8              :         (Arg_1,
 6: Anchored, 5, 1 :          H +
 7: Anchored, 5, 3 :            I);
@end example
The final step is compute all the anchored lines; for line 6, we add 1
to the indent for line 5, leaving 9; for line 7, add 3, leaving 11.

Now consider a more extensive example:

@example
 1: if A < B and
 2:   C < D
 3:   --  comment on expression
 4: then
 5:    Do_E;
 6:    -- comment on statement
 7:
 8:    G := F + Compute_Something
 9:      (Arg_1,
10:       Arg_2);
11:
12:    -- comment before 'end if'
13: end if;
@end example
Here the assignment is on fewer lines, illustrating why we need the
rule about ignoring some delta indents.

To understand the order in which indents are computed, we need the
syntax tree produced by parsing this code; that is shown here, with
node numbers on the left for reference. Note that comments are stored
in the node containing the terminal token node preceding the
comment. Node 20 'formal_part' is empty; ``Do_E'' has no arguments.
@example
 1  if_statement
 2    'if'
 3    expression
 4      term
 5        primary
 6          identifier "A"
 7        '<'
 8        primary
 9          identifier "B"
10      'and'
11      term
12        primary
13          identifier "C"
14        '<'
15        primary
16          identifier "D", "--  comment on expression"
17    'then'
18    statements
19      statements
20        statement
21          function_call
22            identifier "Do_E"
23          formal_part
24          ';' "-- comment on statement", blank line
25      statement
26        assignment
27          identifier "G"
28          assign_value
29            ':='
30            expression
31              term
32                primary
33                  identifier "F"
34                '+'
35                primary
36                  function_call
37                    identifier "Compute_Something"
38                    formal_part
39                      '('
40                      expression_list
41                        expression_list
42                          expression
43                            term
44                              primary
45                                identifier "Arg_1"
46                        ','
47                        expression
48                          term
49                            primary
50                              identifier "Arg_2"
51                      ')'
52          ';', blank line, "-- comment before 'end if'"
53    'end'
54    'if'
55    ';'
@end example

Actions are computed by traversing the tree depth first. Thus the
first node considered is node 6; it is an @code{identifier}, which is
a terminal token and has no indent action. The next nodes considered
are 5, 7, 9, 8, 4, 10, 13, 12, 14, 16, 15; all have no action. Next is
node 3 @code{expression} on lines 1 and 2, which has the indent
action:
@example
   [(wisi-hanging% nil ada-indent-broken) ada-indent-broken]
@end example
This gives separate indents for the code and the trailing comment.
The code is @code{A < B and C < D} on lines 1 and 2, with
a trailing comment of @code{--  comment on expression} on line 3. Since the
first token in the expression follows @code{if} on line 1, it is not first on
the line; thus @code{wisi-hanging} gives a delta indent of 2 for line
2, leaving line 1 at nil.

The comment on line 3 is given an indent of 2. Note that if the
comment indent had not been given separately in this indent action, it
would have been given the indent of the next token, which is nil.

The stored controlling token line for lines 2 and 3 is 1.

The next action computed is node 21 @code{function_call} @code{Do_E;}
on line 5. The indent action is @code{%((wisi-indent-action [nil
ada-indent-broken]))%}; since the code is all on one line this leaves
the indent for line 5 at nil. The indent for the trailing comment and
blank line on lines 6 and 7 are also left at nil.

Next is node 42 @code{expression} @code{Arg_1} line 9; it is all on one line
and not the first token, so the indent is left at nil. Similarly for
node 47 @code{expression} @code{Arg_2} line 10.

At this point, the indents for all are the lines are (the stored
controlling token line and indent is given after the line number):
@example
 1: nil nil : if A < B and
 2: 1   2   :   C < D
 3: 1   2   :   --  comment on expression
 4: nil nil : then
 5: nil nil :    Do_E;
 6: nil nil :    -- comment on statement
 7: nil nil :
 8: nil nil :    G := A + Compute_Something
 9: nil nil :      (Arg_1,
10: nil nil :       Arg_2);
11: nil nil :
12: nil nil :    -- comment before 'end if'
13: nil nil : end if;
@end example

Next indent action is node 38 @code{formal_part} @code{(Arg_1, Arg_2)}
lines 9 and 10. The indent action is
@example
%((wisi-indent-action [nil
                       (wisi-anchored 1 1)
                       (wisi-anchored 1 0)]))%
@end example
This computes a delta indent for the @code{expression_list} of
@code{Anchored, 9, 1)}; anchored to line 9 with an offset of 1. This
delta indent is applied to the lines whose first tokens are contained by the
@code{expression_list}; that is just line 10. Since the indent for
line 10 is currently nil, it is set to @code{Anchored, 9, 1)},
controlling token line 9.

Next is node 36 @code{function_call} @code{Compute_Something (Arg_1,
Arg_2)} on lines 9 and 10. The indent action is
@code{%((wisi-indent-action [nil ada-indent-broken]))%}, which gives a
delta indent of 2 for the @code{formal_part}. This is applied to lines
9 and 10, leaving line 9 at 2, stored controlling token line 8; and 10
unchanged.

Next is node 30 @code{expression} @code{F + Compute_Something (Arg_1,
Arg_2)} on lines 8, 9 and 10; this computes a delta indent of 2 for lines
9 and 10. The controlling token line is 8, and the stored controlling
token for line 9 is also 8, so this delta indent is ignored for line
9. Line 10 is anchored, so the delta indent is ignored. Thus the
indent for lines 9 and 10 are unchanged.

Next is node 28 @code{assign_value} on lines 8, 9, 10; this computes a
delta indent of 2 for the @code{expression}, which is applied to lines
9 and 10; it is ignored as the delta indent from node 29 was.

Next is node 16 @code{assignment} on lines 8, 9, 10; this computes a
delta indent of 2 for the @code{expression}, which is applied to lines
9 and 10; it is ignored.

The blank line and comment on
lines 11 and 12 are stored in node 51, which is in the
@code{assignment} nonterminal, and there is no following token in the
production, so the indent of ';' is used for them; that's nil.

At this point, the indents are:
@example
 1: nil nil          : if A < B and
 2: 1   2            :   C < D
 3: 1   2            :   --  comment on expression
 4: nil nil          : then
 5: nil nil          :    Do_E;
 6: nil nil          :    -- comment on statement
 7: nil nil          :
 8: nil nil          :    G := F + Compute_Something
 9: 8   2            :      (Arg_1,
10: 9   Anchored 9 1 :       Arg_2);
11: nil nil          :
12: nil nil          :    -- comment before 'end if'
13: nil nil          : end if;
@end example

The final indent action is for node 1 @code{if_statement} on lines 1
thru 13. The indent for each token in the production is:

@table @code
@item if: nil
Leaves line 1 at nil.

@item expression: ada-indent-broken
Since the controlling token line is the same as the stored controlling
token line, this is ignored.

@item then: nil
Applies delta of nil to line 4.

Note that specifying the indent for the comment following an
expression in the @code{expression} indent action enforces a style of
indenting the comment with the last line of the expression.

@item statements: [ada-indent ada-indent]
Applies a delta indent of 3 to the code and comment on lines 5 thru
10, and 3 to the trailing comment on lines 11 and 12. The controlling
token line is 5, so this is not ignored except for the Anchored line 10.

Note that the indent for comments after statements is given here, not
at a lower level; it would be tedious to add it to each statement.

@item end if; : nil
Leaves line 13 at nil.
@end table

The indents so far:
@example
 1: nil nil          : if A < B and
 2: 1   2            :   C < D
 3: 1   2            :   --  comment on expression
 4: nil nil          : then
 5: 5   3            :    Do_E;
 6: 5   3            :    -- comment on statement
 7: 5   3            :
 8: 5   3            :    G := F + Compute_Something
 9: 5   5            :      (Arg_1,
10: 9   Anchored 9 1 :       Arg_2);
11: 5   3            :
12: 5   3            :    -- comment before 'end if'
13: nil nil          : end if;
@end example

The final step is compute the anchored lines; that sets the indent
for line 10 to 6.

In a full grammar, the top production should specify an indent of 0,
not nil, for tokens that are not indented; then every line will have a
non-nil indent.

However, in normal operation a nil indent is treated as 0; the
@code{wisi-indent} text property is not set for lines that have nil
indent, and @code{wisi-indent-region} detects that and uses 0 for the
indent. You can set the variable @code{wisi-debug} to a value > 0 to
signal an error for nil indents; this is useful to catch indent errors
during grammar development.

@node In-parse actions
@section In-parse actions
@table @code

@item wisi-propagate-name TOKEN
The argument is a token index. Set the @code{name} component of the
left-hand-side parse-time token object to the @code{name} component of
the identified token, if it is not empty. Otherwise use the
@code{char_region} component.

@item wisi-merge-name FIRST-TOKEN, LAST-TOKEN
The arguments are token indices, giving a range of
tokens. LAST-TOKEN may be omitted if it is the same as FIRST-TOKEN.

Set the @code{name} component of the left-hand-side to the merger of
the @code{name} or @code{char_region} components of the identified tokens.

@item wisi-match-name START-TOKEN END-TOKEN
The arguments are token indices. Compare the text contained by the
@code{name} (or @code{char_region} if @code{name} is empty) token
components for START-TOKEN and END-TOKEN; signal a parse error if they
are different.

The behavior when a name is missing is determined by the runtime
language variable given in the @code{%end_names_optional_option}
declaration; if True, a missing name that is supposed to match a
present name is an error. Both names missing is not an error (assuming
that is allowed by the grammar).

@end table

@node Project extension
@chapter Project extension
wisi defines the @code{cl-defstuct} @code{wisi-prj}, with operations
suitable for compilation and cross-reference.

In order to use wisi projects, the user must write project files and
customize @code{project-find-functions} and
@code{xref-backend-functions}.

@menu
* Project files::
* Selecting projects::
* Casing exception files::
* Other project functions::
@end menu

@node Project files
@section Project files

Project file names must have an extension given by
@code{wisi-prj-file-extensions} (default @file{.adp, .prj}).

Project files have a simple syntax; they may be edited directly. Each
line specifies a project variable name and its value, separated by
``='':

@example
src_dir=/Projects/my_project/src_1
src_dir=/Projects/my_project/src_2
@end example

There must be no space between the variable name and ``='', and no
trailing spaces after the value.

Any line that does not have an ``='' is a comment.

Some variables (like @code{src_dir}) are lists; each line in the
project file specifies one element of the list. The value on the last
line is the last element in the list.

A variable name that starts with @code{$} is set as a process
environment variable, for processes launched from Emacs for the
project.

In values, process environment variables can be referenced
using the normal @code{$var} syntax.

In values, relative file names are expanded relative to the
directory containing the project file.

Here is the list of project variables defined by wisi; major modes may
add more.

@table @asis
@item @code{casing}         [slot: @code{case-exception-files}]
List of files containing casing exceptions. @xref{Casing exception files}.

@item @code{src_dir}        [slot: @code{source-path}]
A list of directories to search for source files.

@end table

@node Selecting projects
@section Selecting projects
The current project can either be indicated by a global variable
(called a ``selected project''), or depend on the current buffer.

In addition, the project file can be parsed each time it is needed, or
the result cached to improve response time,

One reason to use a selected project is to handle a hierarchy of
projects; if projects B and C both depend on library project A, then
when in a file of project A, there is no way to determine which of the
three projects to return. So the user must indicate which is active,
by using one of @code{wisi-prj-select-file} or
@code{wisi-prj-select-cache}.

In addition, if changing from one project to another requires setting
global resources that must also be unset (such as a syntax propertize
hook or compilation filter hook), then the project should define
@code{wisi-prj-deselect} in addition to @code{wisi-prj-select}. Such
projects require having a selected current project, so it can be
deselected before a new one is selected. One example of such projects
is ada-mode.

One way to declare each project is to add a Local Variables section
in the main Makefile for the project; when the Makefile is first
visited, the project is declared. In the examples here, we assume
that approach is used; each gives an :eval line.

Note that @code{wisi-prj-current-parse} and
@code{wisi-prj-current-cached} always succeed after some project is
selected; no functions after them on @code{project-find-functions} will
be called. That's why the depth is 90 for those in the examples.

@table @asis
@item No caching, current project depends on current buffer

@example
(add-hook 'project-find-functions #'wisi-prj-find-dominating-parse 0)

:eval (wisi-prj-set-dominating "foo.prj" (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-set-dominating} declares the name of a project file with a
default project object, and ensures that the current buffer file name
is in @code{wisi-prj--dominating}.

@code{wisi-prj-find-dominating-parse} looks for the filenames in
@code{wisi-prj--dominiating} in the parent directories of the current
buffer. When one is found, the associated project file is parsed,
using the default project object to dispatch to the appropriate
parsers. Then the final project object is returned.

@item Caching, current project depends on current buffer

@example
(add-hook 'project-find-functions #'wisi-prj-find-dominating-cached 0)

:eval (wisi-prj-cache-dominating "foo.prj" (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-cache-dominating} declares the project file, parses it,
and saves the project object in a cache indexed by the absolute
project file name.

@code{wisi-prj-find-dominating-cached} finds the dominating
project file, and retrieves the object from the cache.

@item No caching, last selected project is current

@example
(add-hook 'project-find-functions #'wisi-prj-current-parse 90)

:eval: (wisi-prj-select-file <prj-file> (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-select-file} sets the project file as the current
project, and saves the default project object.

@code{wisi-prj-current-parse} parses the current project file, using
the saved default project object, and returns the project object.

@item Caching, last selected project is current

@example
(add-hook 'project-find-functions #'wisi-prj-current-cached 90)

:eval: (wisi-prj-select-cache <prj-file> (foo-prj-default "prj-name"))
@end example

@code{wisi-prj-select-cache} parses the project file, caches the
project object.

@code{wisi-prj-current-cached} returns the cached current project
object.

@end table

In addition, the user should set @code{xref-backend-functions}. Currently,
there is only one choice for wisi projects:

@example
(add-to-list 'xref-backend-functions #'wisi-prj-xref-backend 90)
@end example

@code{wisi-prj-xref-backend} returns the current wisi project object.

@node Casing exception files
@section Casing exception files
Each line in a case exception
file specifies the casing of one word or word fragment. If an
exception is defined in multiple files, the first occurrence is used.

If the word starts with an asterisk (@code{*}), it defines the casing
of a word fragment (or ``substring''); part of a word between two
underscores or word boundary.

For example:

@example
DOD
*IO
GNAT
@end example

The word fragment @code{*IO} applies to any word containing ``_io'';
@code{Text_IO}, @code{Hardware_IO}, etc.

@node Other project functions
@section Other project functions

@table @code
@item wisi-refresh-prj-cache (not-full)
Refreshes all cached data in the project, and re-selects the
project. If NOT-FULL is non-nil, slow refresh operations are skipped.

This reparses the project file, and any cross reference information.

@item wisi-prj-select-dominating (dominating-file)
  Find a wisi-prj matching DOMINATING-FILE (defaults to the current
buffer file). If the associated project is current, do nothing. If it
is not current, select it.

This is useful before running `compilation-start', to ensure the correct
project is current.

@end table

@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include doclicense.texi

@node Index,  , GNU Free Documentation License, Top
@unnumbered Index

@printindex fn

@bye
