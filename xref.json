[  {"comment": ["emulate the benchmark-xref sequence"]},
   {"start": {"cmd": ["${ALS}", "--tracefile=/Projects/org.emacs.ada-mode/xref-traces.cfg"]}},
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "id": "1",
            "method": "initialize",
            "params": {
               "processId": 223237,
               "rootUri": "$URI{.}",
               "capabilities": {
                  "workspace": {
                      "applyEdit": true,
                      "executeCommand": {"dynamicRegistration": false},
                      "workspaceEdit": {"dynamicRegistration": false},
                      "didChangeWatchedFiles": {"dynamicRegistration": true},
                      "symbol": {"dynamicRegistration": false},
                      "configuration": true
                  },
                   "textDocument":
                   {"synchronization":
                    {"dynamicRegistration":false,
                     "willSave":true,
                     "willSaveWaitUntil":true,
                     "didSave":true},
                    "completion":
                    {"dynamicRegistration":false,
                     "completionItem":{"snippetSupport":false},
                     "contextSupport":true},
                    "hover":{"dynamicRegistration":false,"contentFormat":["plaintext"]},
                    "signatureHelp":
                    {"dynamicRegistration":false,
                     "signatureInformation":{"parameterInformation":{"labelOffsetSupport":true}}},
                    "references":{"dynamicRegistration":false},
                    "definition":{"dynamicRegistration":false},
                    "declaration":{"dynamicRegistration":false},
                    "implementation":{"dynamicRegistration":false},
                    "typeDefinition":{"dynamicRegistration":false},
                    "documentSymbol":
                    {"dynamicRegistration":false,
                     "hierarchicalDocumentSymbolSupport":true,
                     "symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},
                    "documentHighlight":{"dynamicRegistration":false},
                    "codeAction":
                    {"dynamicRegistration":false,
                     "codeActionLiteralSupport":
                     {"codeActionKind":
                      {"valueSet":
                       ["quickfix","refactor","refactor.extract","refactor.inline",
                        "refactor.rewrite","source","source.organizeImports"]}},
                     "isPreferredSupport":true},
                    "formatting":{"dynamicRegistration":false},
                    "rangeFormatting":{"dynamicRegistration":false},
                    "rename":{"dynamicRegistration":false},
                    "publishDiagnostics":{"relatedInformation":false}}
               }
            }
         },
         "wait": [
            {
               "id": "1",
               "result": {
                  "capabilities": {
                     "textDocumentSync": 2,
                     "completionProvider": {
                        "triggerCharacters": [
                           ".",
                           ",",
                           "'",
                           "("
                        ],
                        "resolveProvider": true
                     },
                     "hoverProvider": true,
                     "declarationProvider": true,
                     "definitionProvider": true,
                     "typeDefinitionProvider": true,
                     "implementationProvider": true,
                     "referencesProvider": true,
                     "documentHighlightProvider": true,
                     "documentSymbolProvider": true,
                     "codeActionProvider": {},
                     "documentFormattingProvider": true,
                     "renameProvider": {},
                     "foldingRangeProvider": true,
                     "workspaceSymbolProvider": true,
                     "callHierarchyProvider": {},
                     "alsShowDepsProvider": true,
                     "alsReferenceKinds": [
                        "reference",
                        "access",
                        "write",
                        "call",
                        "dispatching call",
                        "parent",
                        "child"
                     ]
                  }
               }
            }
         ]
      }
   },
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "method": "workspace/didChangeConfiguration",
            "params": {
               "settings": {
                   "ada": {
                     "projectFile": "/Projects/org.emacs.ada-mode/ada_mode_wisi_parse.gpr"
                  }
               }
            }
         },
         "wait": []
      }
   },
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "method": "textDocument/didOpen",
            "params": {
               "textDocument": {
                  "uri": "file:///Projects/org.emacs.ada-mode/wisi-ada.adb",
                  "languageId": "ada-eglot",
                  "version": 0,
                  "text": "--  Abstract :\n--\n--  see spec.\n--\n--  Copyright (C) 2017 - 2021 Free Software Foundation, Inc.\n--\n--  This library is free software;  you can redistribute it and/or modify it\n--  under terms of the  GNU General Public License  as published by the Free\n--  Software  Foundation;  either version 3,  or (at your  option) any later\n--  version. This library is distributed in the hope that it will be useful,\n--  but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN-\n--  TABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\npragma License (GPL);\n\nwith Ada.Exceptions;\nwith Ada.Strings.Fixed;\nwith Ada.Strings.Unbounded;\nwith Ada.Text_IO;\nwith Ada_Annex_P_Process_Actions; --  token_enum_id\nwith GNAT.Traceback.Symbolic;\npackage body Wisi.Ada is\n   use WisiToken;\n\n   ----------\n   --  body local subprograms\n\n   function Indent_Record\n     (Data                   : in out Parse_Data_Type;\n      Tree                   : in     Syntax_Trees.Tree;\n      Controlling_Token_Line : in     Line_Number_Type;\n      Anchor_Token           : in     Syntax_Trees.Valid_Node_Access;\n      Record_Token           : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Token        : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment      : in     Boolean;\n      Offset                 : in     Integer)\n     return Wisi.Delta_Type\n   is\n      use Ada_Annex_P_Process_Actions;\n   begin\n      if not Indenting_Comment and Tree.ID (Indenting_Token) = +RECORD_ID then\n         --  Indenting 'record'\n         return Indent_Anchored_2\n           (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment, Ada_Indent_Record_Rel_Type);\n\n      elsif Indenting_Comment and Tree.ID (Indenting_Token) = +WITH_ID then\n         --  comment before 'record'. test/ada_mode-nominal-child.ads Child_Type_1\n         return Indent_Anchored_2\n           (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment, Ada_Indent_Record_Rel_Type);\n\n      elsif Indenting_Comment and Tree.ID (Indenting_Token) = +IS_ID then\n         --  comment after 'is'\n         if Tree.ID (Record_Token) = +RECORD_ID then\n            --  before 'record'. test/ada_mode-nominal.ads Record_Type_1\n            return Indent_Anchored_2\n              (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment, Ada_Indent_Record_Rel_Type);\n         else\n            --  not before 'record'. test/ada_mode-nominal-child.ads Child_Type_1\n            return (Simple, (Int, Controlling_Token_Line, Offset));\n         end if;\n\n      else\n         --  Indenting comment after 'record', other comment, component or 'end'\n         --\n         --  Ensure line containing 'record' is anchored to Anchor_Token.\n         if Data.Indents (Tree.Line_Region (Record_Token).First).Label /= Anchored then\n            if Tree.Line_Region (Anchor_Token).First /= Tree.Line_Region (Record_Token).First then\n               --  We don't pass Indenting_Comment here, because 'record' is code.\n               Indent_Token_1\n                 (Data,\n                  Tree,\n                  Line_Region          => Tree.Line_Region (Record_Token, Trailing_Non_Grammar => False),\n                  Delta_Indent         => Indent_Anchored_2\n                    (Data, Tree, Anchor_Token, Record_Token,\n                     Indenting_Comment => False,\n                     Offset            => Ada_Indent_Record_Rel_Type),\n                  Indenting_Comment    => None);\n            end if;\n         end if;\n\n         return Indent_Anchored_2\n           (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment, Current_Indent_Offset\n              (Tree, Anchor_Token,\n               (if Tree.Line_Region (Anchor_Token).First = Tree.Line_Region (Record_Token).First\n                then Offset\n                else Offset + Ada_Indent_Record_Rel_Type)));\n      end if;\n   end Indent_Record;\n\n   ----------\n   --  Refactor body subprograms\n\n   function Find_ID_At\n     (Tree       : in WisiToken.Syntax_Trees.Tree;\n      ID         : in Token_ID;\n      Edit_Begin : in WisiToken.Buffer_Pos)\n     return WisiToken.Syntax_Trees.Node_Access\n   is\n      function Match (Tree : in Syntax_Trees.Tree; Node : in Syntax_Trees.Valid_Node_Access) return Boolean\n        is (Tree.ID (Node) = ID and then Tree.Byte_Region (Node).First = Edit_Begin);\n   begin\n      return Tree.Find_Descendant (Tree.Root, Predicate => Match'Access);\n   end Find_ID_At;\n\n   procedure Unrecognized\n     (Expecting : in     String;\n      Tree      : in     WisiToken.Syntax_Trees.Tree;\n      Data      : in out Parse_Data_Type;\n      Found     : in     WisiToken.Syntax_Trees.Valid_Node_Access)\n   with No_Return\n   is begin\n      raise SAL.Parameter_Error with \"expecting '\" & Expecting & \"'; found \" &\n        Tree.Image (Found, Node_Numbers => True) & \" '\" & Elisp_Escape_Quotes (Data.Get_Text (Tree, Found)) & \"'\";\n   end Unrecognized;\n\n   procedure Method_Object_To_Object_Method\n     (Tree       : in     WisiToken.Syntax_Trees.Tree;\n      Data       : in out Parse_Data_Type;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   --  Data.Tree contains one statement or declaration; Edit_Begin is at\n   --  start of a subprogram call. Convert the subprogram call from\n   --  Prefix.Method (Object, ...) to Object.Method (...).\n   is\n      use Ada_Annex_P_Process_Actions;\n      use Standard.Ada.Strings.Unbounded;\n      use Standard.Ada.Text_IO;\n      use WisiToken.Syntax_Trees;\n\n      Call : constant Node_Access := Find_ID_At (Tree, +function_call_ID, Edit_Begin);\n\n      Edit_End              : WisiToken.Buffer_Pos;\n      Actual_Parameter_Part : Node_Access;\n      Association_List      : Node_Access;\n      Method                : Node_Access;\n\n   begin\n      if Call = Invalid_Node_Access then\n         --  Most likely the edit point is wrong.\n         raise SAL.Parameter_Error with \"no subprogram call found at byte_pos\" & Edit_Begin'Image;\n      end if;\n\n      if Trace_Action > Detail then\n         Data.Trace.Put_Line\n           (\"refactoring node \" & Tree.Image (Call, Node_Numbers => True) & \" '\" & Data.Get_Text (Tree, Call) & \"'\");\n      end if;\n\n      Actual_Parameter_Part := Tree.Child (Call, 2);\n      pragma Assert (Tree.ID (Actual_Parameter_Part) = +actual_parameter_part_ID);\n\n      Association_List := Tree.Child (Actual_Parameter_Part, 2);\n      pragma Assert (Tree.ID (Association_List) = +parameter_association_list_ID);\n\n      Edit_End := Tree.Byte_Region (Call).Last;\n\n      Method := Tree.Child (Tree.Child (Call, 1), 1);\n\n      case To_Token_Enum (Tree.ID (Method)) is\n      when selected_component_ID =>\n         Method := Tree.Child (Method, 3);\n         pragma Assert (Tree.ID (Method) = +selector_name_ID);\n\n         Method := Tree.Child (Method, 1);\n\n      when attribute_reference_ID =>\n         case To_Token_Enum (Tree.ID (Tree.Child (Method, 1))) is\n         when name_ID =>\n            Method := Tree.Child (Method, 3);\n            pragma Assert (Tree.ID (Method) = +attribute_designator_ID);\n\n            Method := Tree.Child (Method, 1);\n\n         when reduction_attribute_reference_ID =>\n            Unrecognized (\"subprogram call\", Tree, Data, Method);\n\n         when others =>\n            raise SAL.Programmer_Error;\n         end case;\n\n      when qualified_expression_ID =>\n         raise SAL.Not_Implemented; -- need use case\n\n      when direct_name_ID =>\n         Method := Tree.Child (Method, 1);\n\n      when others =>\n         Unrecognized (\"supported token\", Tree, Data, Method);\n      end case;\n\n      pragma Assert (To_Token_Enum (Tree.ID (Method)) in IDENTIFIER_ID | STRING_LITERAL_ID);\n\n      declare\n         Object : constant Node_Access := Tree.Find_Descendant (Association_List, +expression_ID);\n         Result : Unbounded_String;\n      begin\n         if Object = Invalid_Node_Access then\n            Unrecognized (\"expression\", Tree, Data, Association_List);\n         end if;\n\n         --  Build remaining arg list in Result.\n         loop\n            if Tree.RHS_Index (Association_List) = 1 then\n               Result := Get_Text (Data, Tree, Tree.Child (Association_List, 3)) &\n                 (if Length (Result) = 0 then \"\" else \", \") &\n                 Result;\n               Association_List := Tree.Child (Association_List, 1);\n            else\n               --  The remaining element in Association_List is the first one, which is Object.\n               if Length (Result) > 0 then\n                  Result := \" (\" & Result & \")\";\n               end if;\n               exit;\n            end if;\n         end loop;\n         Result := (Get_Text (Data, Tree, Object) & \".\" & Get_Text (Data, Tree, Method)) & Result;\n         Put_Line (\"[\" & Edit_Action_Code & Edit_Begin'Image & Edit_End'Image & \" \"\"\" &\n                     Elisp_Escape_Quotes (To_String (Result)) & \"\"\"]\");\n      end;\n   end Method_Object_To_Object_Method;\n\n   procedure Object_Method_To_Method_Object\n     (Tree       : in     WisiToken.Syntax_Trees.Tree;\n      Data       : in out Parse_Data_Type;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   is\n      --  Data.Tree contains one statement or declaration; Edit_Begin is at\n      --  start of a subprogram call. Convert the subprogram call from\n      --  Object.Method (...) to Method (Object, ...).\n      use Ada_Annex_P_Process_Actions;\n      use Standard.Ada.Strings.Unbounded;\n      use WisiToken.Syntax_Trees;\n\n      Call          : Node_Access := Find_ID_At (Tree, +name_ID, Edit_Begin);\n      Edit_End      : WisiToken.Buffer_Pos;\n      Object_Method : Node_Access;\n      Args          : Node_Access := Invalid_Node_Access;\n      Method        : Unbounded_String;\n      Object        : Unbounded_String;\n      Result        : Unbounded_String;\n   begin\n      if Call = Invalid_Node_Access then\n         --  Most likely the edit point is wrong.\n         raise SAL.Parameter_Error with \"no 'name' at byte_pos\" & Edit_Begin'Image;\n      end if;\n\n      if Trace_Action > Detail then\n         Data.Trace.Put_Line\n           (\"refactoring node \" & Tree.Image (Call, Node_Numbers => True) & \" '\" & Data.Get_Text (Tree, Call) & \"'\");\n      end if;\n\n      if Tree.ID (Tree.Child (Call, 1)) = +attribute_reference_ID then\n         --  Code looks like: Container.Length'Old. We only want to edit\n         --  'Container.Length', keeping the trailing 'Old.\n         Call := Tree.Child (Tree.Child (Call, 1), 1);\n      end if;\n\n      Edit_End      := Tree.Byte_Region (Call).Last;\n      Object_Method := Tree.Child (Call, 1);\n      loop\n         case To_Token_Enum (Tree.ID (Object_Method)) is\n         when function_call_ID =>\n            --  Object_Method looks like:\n            --  Object.Method (Args)\n            --  test/ada_mode-refactor_object_method_to_method_object.adb\n            Args := Tree.Child (Tree.Child (Object_Method, 2), 2);\n            pragma Assert (Tree.ID (Args) = +parameter_association_list_ID);\n\n            Object_Method := Tree.Child (Object_Method, 1);\n\n         when name_ID =>\n            Object_Method := Tree.Child (Object_Method, 1);\n\n         when selected_component_ID =>\n            Object := +Get_Text (Data, Tree, Tree.Child (Object_Method, 1));\n            Method := +Get_Text (Data, Tree, Tree.Child (Object_Method, 3));\n            exit;\n\n         when others =>\n            Unrecognized (\"supported token\", Tree, Data, Object_Method);\n         end case;\n      end loop;\n\n      Result := Method & \" (\" & Object;\n      if Args /= Invalid_Node_Access then\n         Result := Result & \", \" & Get_Text (Data, Tree, Args);\n      end if;\n      Result := Result & \")\";\n      Standard.Ada.Text_IO.Put_Line\n        (\"[\" & Edit_Action_Code & Edit_Begin'Image & Edit_End'Image & \" \"\"\" &\n           Elisp_Escape_Quotes (To_String (Result)) & \"\"\"]\");\n   end Object_Method_To_Method_Object;\n\n   procedure Element_Object_To_Object_Index\n     (Tree       : in     WisiToken.Syntax_Trees.Tree;\n      Data       : in out Parse_Data_Type;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   --  Data.Tree contains one statement or declaration; Edit_Begin is at\n   --  start of a subprogram call. Convert the subprogram call from\n   --  Prefix.Element (Object, Index) to Object (Index).\n   is\n      use Ada_Annex_P_Process_Actions;\n      use Standard.Ada.Text_IO;\n      use WisiToken.Syntax_Trees;\n\n      Call             : constant Node_Access := Find_ID_At (Tree, +function_call_ID, Edit_Begin);\n      Edit_End         : WisiToken.Buffer_Pos;\n      Temp             : Node_Access;\n      Association_List : Node_Access;\n      Object           : Node_Access;\n      Index            : Node_Access;\n   begin\n      if Call = Invalid_Node_Access then\n         --  Most likely the edit point is wrong.\n         raise SAL.Parameter_Error with \"no subprogram call found at byte_pos\" & Edit_Begin'Image;\n      end if;\n\n      if Trace_Action > Detail then\n         Data.Trace.Put_Line\n           (\"refactoring node \" & Tree.Image (Call, Node_Numbers => True) & \" '\" & Data.Get_Text (Tree, Call) & \"'\");\n      end if;\n\n      Association_List := Tree.Child (Tree.Child (Call, 2), 2);\n      pragma Assert (Tree.ID (Association_List) = +parameter_association_list_ID);\n\n      Edit_End := Tree.Byte_Region (Call).Last;\n\n      if Tree.RHS_Index (Association_List) /= 1 then\n         Unrecognized (\"two args\", Tree, Data, Association_List);\n      end if;\n\n      Temp := Tree.Find_Descendant (Association_List, +expression_ID);\n      if Temp = Invalid_Node_Access then\n         Unrecognized (\"expression\", Tree, Data, Association_List);\n      else\n         Object := Temp;\n      end if;\n\n      Temp := Tree.Find_Descendant (Tree.Child (Association_List, 3), +expression_ID);\n      if Temp = Invalid_Node_Access then\n         Unrecognized (\"expression\", Tree, Data, Association_List);\n      else\n         Index := Temp;\n      end if;\n\n      Put_Line\n        (\"[\" & Edit_Action_Code & Edit_Begin'Image & Edit_End'Image & \" \"\"\" &\n           Elisp_Escape_Quotes (Get_Text (Data, Tree, Object) & \" (\" & Get_Text (Data, Tree, Index) & \")\") &\n           \"\"\"]\");\n   end Element_Object_To_Object_Index;\n\n   procedure Object_Index_To_Element_Object\n     (Tree       : in     WisiToken.Syntax_Trees.Tree;\n      Data       : in out Parse_Data_Type;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   --  Data.Tree contains one statement or declaration; Edit_Begin is at\n   --  start of a subprogram call. Convert the subprogram call from\n   --  Object (Index) to Element (Object, Index).\n   is\n      use Ada_Annex_P_Process_Actions;\n      use Standard.Ada.Text_IO;\n      use WisiToken.Syntax_Trees;\n\n      Call             : constant Node_Access := Find_ID_At (Tree, +function_call_ID, Edit_Begin);\n      Edit_End         : WisiToken.Buffer_Pos;\n      Temp             : Node_Access;\n      Association_List : Node_Access;\n      Object           : Node_Access;\n      Index            : Node_Access;\n   begin\n      if Call = Invalid_Node_Access then\n         --  Most likely the edit point is wrong.\n         raise SAL.Parameter_Error with \"no subprogram_call found at byte_pos\" & Edit_Begin'Image;\n      end if;\n\n      if Trace_Action > Detail then\n         Data.Trace.Put_Line\n           (\"refactoring node \" & Tree.Image (Call, Node_Numbers => True) & \" '\" & Data.Get_Text (Tree, Call) & \"'\");\n      end if;\n\n      Object := Tree.Child (Call, 1);\n      pragma Assert (Tree.ID (Object) = +name_ID);\n\n      Association_List := Tree.Child (Tree.Child (Call, 2), 2);\n      pragma Assert (Tree.ID (Association_List) = +parameter_association_list_ID);\n\n      Edit_End := Tree.Byte_Region (Call).Last;\n\n      if Tree.RHS_Index (Association_List) /= 0 then\n         Unrecognized (\"one arg\", Tree, Data, Association_List);\n      end if;\n\n      Temp := Tree.Find_Descendant (Tree.Child (Association_List, 1), +expression_ID);\n      if Temp = Invalid_Node_Access then\n         Unrecognized (\"expression\", Tree, Data, Association_List);\n      else\n         Index := Temp;\n      end if;\n\n      Put_Line\n        (\"[\" & Edit_Action_Code & Edit_Begin'Image & Edit_End'Image & \" \"\"\" &\n           Elisp_Escape_Quotes\n             (\"Element (\" & Get_Text (Data, Tree, Object) & \", \" & Get_Text (Data, Tree, Index) & \")\") &\n           \"\"\"]\");\n   end Object_Index_To_Element_Object;\n\n   procedure Format_Parameter_List\n     (Tree       : in out WisiToken.Syntax_Trees.Tree;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   is separate;\n   --  Tree contains a subprogram declaration or body; Edit_Begin is\n   --  at the start of the parameter list. Format the parameter list.\n   --\n   --  Handle virtual tokens as much as possible; at least closing paren.\n\n   ----------\n   --  Public subprograms, declaration order\n\n   overriding\n   procedure Initialize\n     (Data  : in out Parse_Data_Type;\n      Trace : in     WisiToken.Trace_Access)\n   is\n      use all type Ada_Annex_P_Process_Actions.Token_Enum_ID;\n   begin\n      Wisi.Initialize (Wisi.Parse_Data_Type (Data), Trace);\n\n      Data.First_Comment_ID := +COMMENT_ID;\n      Data.Last_Comment_ID  := WisiToken.Invalid_Token_ID;\n      Data.Left_Paren_ID    := +LEFT_PAREN_ID;\n      Data.Right_Paren_ID   := +RIGHT_PAREN_ID;\n\n      --  All nonterms in compilation_unit, basic_declarative_item for\n      --  package specs, wisitoken_accept for point in leading/trailing\n      --  comments.\n      Data.Statement_IDs.Append (+compilation_unit_ID);\n      Data.Statement_IDs.Append (+with_clause_ID);\n      Data.Statement_IDs.Append (+declarative_item_ID);\n      Data.Statement_IDs.Append (+statement_ID);\n      Data.Statement_IDs.Append (+subunit_ID);\n      Data.Statement_IDs.Append (+basic_declarative_item_ID);\n      Data.Statement_IDs.Append (+wisitoken_accept_ID);\n      --  not entry_declaration; only needed with partial parse\n\n      Data.Embedded_Quote_Escape_Doubled := True;\n   end Initialize;\n\n   overriding\n   procedure Parse_Language_Params\n     (Data   : in out Parse_Data_Type;\n      Params : in     String)\n   is\n      use Standard.Ada.Strings.Fixed;\n      First : Integer := Params'First;\n      Last  : Integer := Index (Params, \" \");\n   begin\n      if Params /= \"\" then\n         Ada_Indent := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Broken := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := First + 1;\n         Ada_Indent_Comment_Col_0 := Params (First) = '1';\n\n         First := Last + 1;\n         Last := First + 1;\n         Ada_Indent_Comment_GNAT := Params (First) = '1';\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Label := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Record_Rel_Type := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Renames := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Return := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Use := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_When := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_With := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := Index (Params, \" \", First);\n         Ada_Indent_Subprogram_Is := Integer'Value (Params (First .. Last - 1));\n\n         First := Last + 1;\n         Last := First + 1;\n         End_Names_Optional := Params (First) = '1';\n      else\n         Ada_Indent                 := Ada_Indent_Default;\n         Ada_Indent_Broken          := Ada_Indent_Broken_Default;\n         Ada_Indent_Comment_Col_0   := Ada_Indent_Comment_Col_0_Default;\n         Ada_Indent_Comment_GNAT    := Ada_Indent_Comment_GNAT_Default;\n         Ada_Indent_Label           := Ada_Indent_Label_Default;\n         Ada_Indent_Record_Rel_Type := Ada_Indent_Record_Rel_Type_Default;\n         Ada_Indent_Renames         := Ada_Indent_Renames_Default;\n         Ada_Indent_Return          := Ada_Indent_Return_Default;\n         Ada_Indent_Use             := Ada_Indent_Use_Default;\n         Ada_Indent_When            := Ada_Indent_When_Default;\n         Ada_Indent_With            := Ada_Indent_With_Default;\n         Ada_Indent_Subprogram_Is   := Ada_Indent_Subprogram_Is_Default;\n         End_Names_Optional         := End_Names_Optional_Default;\n      end if;\n\n      Data.Indent_Comment_Col_0 := Ada_Indent_Comment_Col_0;\n   end Parse_Language_Params;\n\n   overriding\n   function Get_Token_IDs\n     (User_Data           : in out Parse_Data_Type;\n      Command_Line : in String;\n      Last : in out Integer)\n     return WisiToken.Token_ID_Arrays.Vector\n   is\n      pragma Unreferenced (User_Data);\n      use Ada_Annex_P_Process_Actions;\n   begin\n      return IDs : WisiToken.Token_ID_Arrays.Vector do\n         Wisi.Skip (Command_Line, Last, '(');\n         loop\n            IDs.Append (+Token_Enum_ID'Value (Wisi.Get_Enum (Command_Line, Last)));\n            Wisi.Skip (Command_Line, Last, ' ');\n            exit when Command_Line (Last + 1) = ')';\n         end loop;\n         Last := Last + 1;\n      end return;\n   end Get_Token_IDs;\n\n   overriding function Insert_After\n     (User_Data           : in out Parse_Data_Type;\n      Tree                : in     WisiToken.Syntax_Trees.Tree'Class;\n      Insert_Token        : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Insert_Before_Token : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Comment_Present     : in     Boolean;\n      Blank_Line_Present  : in     Boolean)\n     return WisiToken.Insert_Location\n   is\n      pragma Unreferenced (User_Data);\n      use Ada_Annex_P_Process_Actions;\n\n      Insert_ID        : constant Token_Enum_ID := To_Token_Enum (Tree.ID (Insert_Token));\n      Insert_Before_ID : constant Token_Enum_ID := To_Token_Enum (Tree.ID (Insert_Before_Token));\n\n      After_End : constant array (Token_Enum_ID) of Boolean :=\n        --  Terminals that appear after 'end', other than ';'.\n        (\n           CASE_ID |\n           DO_ID |\n           IDENTIFIER_ID |\n           IF_ID |\n           LOOP_ID |\n           RECORD_ID |\n           RETURN_ID |\n           SELECT_ID => True,\n         others => False);\n\n      After_Comment : constant array (Token_Enum_ID) of Insert_Location :=\n        (\n         ABORT_ID |\n           ACCEPT_ID |\n           BEGIN_ID |\n           CASE_ID |\n           DECLARE_ID |\n           DELAY_ID |\n           ELSE_ID |\n           ELSIF_ID |\n           ENTRY_ID |\n           EXCEPTION_ID |\n           EXIT_ID |\n           FOR_ID |\n           FUNCTION_ID |\n           GENERIC_ID |\n           GOTO_ID |\n           IF_ID |\n           LOOP_ID |\n           OVERRIDING_ID |\n           PRAGMA_ID |\n           PROCEDURE_ID |\n           RAISE_ID |\n           REQUEUE_ID |\n           SELECT_ID |\n           TYPE_ID |\n           WHILE_ID => After_Prev,\n         others => Before_Next);\n   begin\n      if After_End (Insert_ID) and then -Tree.ID (Tree.Prev_Terminal (Insert_Token)) = END_ID then\n         return After_Prev;\n      end if;\n\n      case Insert_Before_ID is\n      when ELSE_ID | END_ID | IS_ID | WHEN_ID =>\n         case Insert_ID is\n         when END_ID =>\n            --  Ending a block of statements. The desired result depends on what\n            --  the user is doing, and what indent is begin computed.\n            --\n            --  If continuing the block of statements and indenting a blank line,\n            --  the 'end' should be placed after the indent line; before_next.\n            --\n            --  If indenting a block of code, keep the indent of the existing\n            --  'end'; between or after_prev.\n            --\n            --  We don't know what lines are being indented; we use the presence\n            --  of a blank line and comment to hint at that, and we bias towards\n            --  continuing a block of statements, not inserting 'end'.\n            --\n            --  If there is a blank line followed by comments, we assume that\n            --  means we are not adding code on the blank line.\n            --\n            --  If there is a blank line not followed by comments, we assume that\n            --  means we are adding code on the blank line.\n\n            --  Before ELSE_ID:\n            --     test/ada_mode-recover_27.adb\n            --     first 'else'\n            --\n            --  Before END_ID:\n            --     test/ada_mode-interactive_02 New_Line_2,\n            --     actually inserting 'end if;' before 'end case;'\n            --     blank line present => assume continuing code for 'if' body\n            --     => insert before 'end case;' => before_next.\n            --\n            --     test/ada_mode-recover_06.adb\n            --     actually inserting 'end;'\n            --     blank line and comment present; assume extending code for block body\n            --     => insert on blank line => between\n            --\n            --     test/ada_mode-recover_08.adb\n            --     no blank line or comment; keep correct indent for existing 'end' => after_prev.\n            --\n            --     test/ada_mode-recover_17.adb\n            --     inserting missing 'end if;', but assume extending code\n            --     comment present, no blank line; keep correct indent for existing 'end' => between\n            --\n            --  Before IS_ID : test/ada_mode-recover_incremental_01.adb insert \"Float\"\n            --     no blank line or comment\n            --     'is' should be first. => after_prev\n            --\n            --  Before WHEN_ID : test/ada_mode-recover_34.adb\n            --     completing 'if'; keep existing indent of 'when' => after_prev\n            if Comment_Present then\n               return Between;\n            else\n               if Blank_Line_Present then\n                  return Before_Next;\n               else\n                  return After_Prev;\n               end if;\n            end if;\n\n         when others =>\n            --  Before END_ID :\n            --     test/ada_mode-recover_10.adb,\n            --     test/ada_mode-recover_37.adb,\n            --     put trailing 'end' in correct column\n            --\n            --     test/ada_mode-recover_41.adb\n            --     insert on blank line; continue previous code\n            if Blank_Line_Present then\n               return Between;\n            else\n               return After_Prev;\n            end if;\n         end case;\n\n      when RETURN_ID =>\n         --  Before RETURN_ID : test/ada_mode-recover_16.adb\n         --     There is never code before 'return'. => after_prev\n         return After_Prev;\n\n      when others =>\n         case Insert_ID is\n         when BEGIN_ID | DO_ID | ELSE_ID | GREATER_EQUAL_ID | LOOP_ID | IS_ID | THEN_ID =>\n            --  Starting a block of statements\n            if Blank_Line_Present then\n               --  Assume editing; this and next token should start new line.\n               return Between;\n            else\n               --  Next token should start new line.\n               return After_Prev;\n            end if;\n\n         when SEMICOLON_ID =>\n            --  test/ada_mode-interactive_2.adb A := B \\n+C; on blank line: extending code => between | before_next\n            --  test/ada_mode-recover_03.adb after 'renames', _13.adb not on blank line: after_prev\n            --  test/ada_mode-recover_30.adb before 'if', blank line present: between\n            --  test/ada_mode-recover_36.adb after 'function Update\\n comments': before_next\n            --\n            --  test/ada_mode-recover_07.adb after 'loop' on blank line: after_prev | Between,\n            if Blank_Line_Present then\n               return Between;\n            else\n               return After_Prev;\n            end if;\n\n         when others =>\n            if Blank_Line_Present then\n               --  Assume editing; continue previous code\n               return Before_Next;\n\n            elsif Comment_Present then\n               --  Don't continue previous code\n               return After_Comment (Insert_ID);\n\n            else\n               case Insert_ID is\n               when END_ID =>\n                  --  test/ada_mode-recover_20.adb,\n                  --  test/ada_mode-interactive_2.adb Record_1.\n                  return Before_Next;\n\n               when IDENTIFIER_ID | NUMERIC_LITERAL_ID =>\n                  --  test/ada_mode-recover_03.adb after 'renames'; completing an expression: true.\n                  --  Starting a procedure call or assignment statement: false\n                  return\n                    (if -Tree.ID (Tree.Prev_Terminal (Insert_Token)) /= SEMICOLON_ID\n                     then After_Prev\n                     else Before_Next);\n\n               when BEGIN_ID |    -- test/ada_mode-recover_exception_1.adb, test/ada_mode-recover_extra_declare.adb\n                 COLON_ID |       -- test/ada_mode-recover_partial_22.adb\n                 DECLARE_ID |\n                 RIGHT_PAREN_ID | -- test/ada_mode-recover_20.adb\n                 THEN_ID          -- test/ada_mode-recover_19\n                 =>\n                  return After_Prev;\n\n               when others =>\n                  return Before_Next;\n\n               end case;\n            end if;\n         end case;\n      end case;\n   end Insert_After;\n\n   overriding\n   procedure Refactor_Help (Data : in Parse_Data_Type)\n   is\n      use Standard.Ada.Text_IO;\n   begin\n      --  Must match \"ada-refactor-*\" in ada-core.el, Refactor_Label position number\n      Put (\"0 Method_Object_To_Object_Method\");\n      Put (\"1 Object_Method_To_Method_Object\");\n      Put (\"2 Element_Object_To_Object_Index\");\n      Put (\"3 Object_Index_To_Element_Object\");\n      Put (\"4 Format_Parameter_List         \");\n   end Refactor_Help;\n\n   overriding\n   procedure Refactor\n     (Data       : in out Parse_Data_Type;\n      Tree       : in out WisiToken.Syntax_Trees.Tree;\n      Action     : in     Refactor_Action;\n      Edit_Begin : in     WisiToken.Buffer_Pos)\n   is\n      Enum_Action : Refactor_Label;\n   begin\n      begin\n         Enum_Action := Refactor_Label'Val (Action);\n      exception\n      when Constraint_Error =>\n         Standard.Ada.Text_IO.Put_Line (\"(error \"\"unrecognized refactor action '\" & Action'Image & \"'\"\")\");\n         return;\n      end;\n\n      if Trace_Action > Extra then\n         Data.Trace.Put_Line (Tree.Image (Children => True));\n      end if;\n      case Enum_Action is\n      when Method_Object_To_Object_Method =>\n         Wisi.Ada.Method_Object_To_Object_Method (Tree, Data, Edit_Begin);\n      when Object_Method_To_Method_Object =>\n         Wisi.Ada.Object_Method_To_Method_Object (Tree, Data, Edit_Begin);\n      when Element_Object_To_Object_Index =>\n         Wisi.Ada.Element_Object_To_Object_Index (Tree, Data, Edit_Begin);\n      when Object_Index_To_Element_Object =>\n         Wisi.Ada.Object_Index_To_Element_Object (Tree, Data, Edit_Begin);\n      when Format_Parameter_List =>\n         Wisi.Ada.Format_Parameter_List (Tree, Edit_Begin);\n      end case;\n   exception\n   when E : others =>\n      if Debug_Mode then\n         Data.Trace.Put_Line\n           (Standard.Ada.Exceptions.Exception_Name (E) & \": \" & Standard.Ada.Exceptions.Exception_Message (E));\n         Data.Trace.Put_Line (GNAT.Traceback.Symbolic.Symbolic_Traceback (E));\n         Data.Trace.New_Line;\n      end if;\n      raise;\n   end Refactor;\n\n   function Ada_Indent_Aggregate\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Wisi.Indent_Arg_Arrays.Vector)\n     return Wisi.Delta_Type\n   is\n      pragma Unreferenced (Nonterm);\n      pragma Unreferenced (Data);\n      pragma Unreferenced (Indenting_Comment);\n      pragma Unreferenced (Args);\n\n      use Ada_Annex_P_Process_Actions;\n      use Syntax_Trees;\n\n      --  In our grammar, 'aggregate' can be an Ada aggregate, or a\n      --  parenthesized expression.\n      --\n      --  We always want an 'aggregate' that begins an expression to be\n      --  indented by ada-indent-broken. However, in some places in the\n      --  grammar, 'aggregate' is indented by ada-indent. The following\n      --  checks for those places, and returns a correction value. The\n      --  aggregate may be nested inside a conditional expression, so we\n      --  search for 'name' as well; see\n      --  test/ada_mode-conditional_expressions-more_1.adb.\n\n      pragma Assert (Tree.ID (Indenting_Token) = +aggregate_ID);\n\n      Expression : constant Node_Access := Tree.Find_Ancestor (Indenting_Token, (+expression_ID, +name_ID));\n   begin\n      if Expression = Invalid_Node_Access or else\n        Tree.Parent (Expression) = Invalid_Node_Access\n      then\n         return Null_Delta;\n      elsif Tree.ID (Tree.Parent (Expression)) in +if_expression_ID | +elsif_expression_item_ID |\n        +case_expression_alternative_ID\n      then\n         --  test/ada_mode-conditional_expressions.adb K; value expression in\n         --  if_expression is indented by ada-indent.\n         --\n         --  test/ada_mode-conditional_expressions.adb M1 nested \"(case C\";\n         --  value expression in case_expression-alternative is indented by\n         --  ada-indent. But this aggregate does not start the value expression.\n         declare\n            List : constant Node_Access := Tree.Find_Ancestor (Indenting_Token, +term_binary_adding_operator_list_ID);\n         begin\n            if Tree.RHS_Index (List) = 0 then\n               --  Aggregate starts expression\n               return (Simple, (Int, Invalid_Line_Number, Ada_Indent_Broken - Ada_Indent));\n            else\n               return Null_Delta;\n            end if;\n         end;\n\n      else\n         return Null_Delta;\n      end if;\n   end Ada_Indent_Aggregate;\n\n   function Ada_Indent_Aspect\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Wisi.Indent_Arg_Arrays.Vector)\n     return Delta_Type\n   is\n      pragma Unreferenced (Nonterm, Args);\n\n      use Ada_Annex_P_Process_Actions;\n\n      pragma Assert (Tree.ID (Indenting_Token) = +aspect_definition_ID);\n\n      Indenting    : constant Wisi.Indenting                 := Compute_Indenting (Data, Tree, Indenting_Token);\n      Anchor_Token : constant Syntax_Trees.Valid_Node_Access := Tree.Child (Tree.Parent (Indenting_Token), 2);\n   begin\n      if Tree.Line_Region (Indenting_Token).First = Indenting.Code.First then\n         --  aspect_definition starts a line; anchor the aspect_definition to\n         --  the line containing '=>' with offset ada_indent_broken.\n         return Indent_Anchored_2 (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment, Ada_Indent_Broken);\n      else\n         --  aspect_definition starts on same line as '=>'; anchor the aspect_definition to '=>' with offset 3\n         return Indent_Anchored_2\n           (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment,\n            Current_Indent_Offset (Tree, Anchor_Token, 3));\n      end if;\n   end Ada_Indent_Aspect;\n\n   function Ada_Indent_Renames_0\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Indent_Arg_Arrays.Vector)\n     return Wisi.Delta_Type\n   is\n      Subp_Node : constant Syntax_Trees.Valid_Node_Access := Tree.Child\n        (Nonterm, Positive_Index_Type (Integer'(Args (1))));\n\n      Paren_I : constant Syntax_Trees.Node_Access := Tree.Find_Descendant (Subp_Node, Data.Left_Paren_ID);\n   begin\n      if Paren_I /= Syntax_Trees.Invalid_Node_Access then\n         --  paren is present\n         if Ada_Indent_Renames > 0 then\n            return Indent_Anchored_2 (Data, Tree, Subp_Node, Indenting_Token, Indenting_Comment, Ada_Indent_Renames);\n         else\n            return Indent_Anchored_2\n              (Data, Tree, Paren_I, Indenting_Token, Indenting_Comment, Current_Indent_Offset\n                 (Tree, Paren_I, abs Ada_Indent_Renames));\n         end if;\n      else\n         return Indent_Anchored_2 (Data, Tree, Subp_Node, Indenting_Token, Indenting_Comment, Ada_Indent_Broken);\n      end if;\n   end Ada_Indent_Renames_0;\n\n   function Ada_Indent_Return_0\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Wisi.Indent_Arg_Arrays.Vector)\n     return Wisi.Delta_Type\n   is\n      use all type Ada_Annex_P_Process_Actions.Token_Enum_ID;\n      --  tree.child (Nonterm, Args (1)) = 'formal_part'\n      --  Indenting_Token = 'result_profile'\n      --  Args (2) = delta (= 0!)\n      --\n      --  We are indenting 'result_profile' in\n      --  'parameter_and_result_profile'. The indent depends on whether the\n      --  'formal_part' is present, and the location of 'FUNCTION'.\n\n      Parameter_And_Result_Profile : constant Syntax_Trees.Valid_Node_Access := Tree.Parent (Indenting_Token);\n\n      Indenting : constant Wisi.Indenting := Compute_Indenting (Data, Tree, Indenting_Token);\n   begin\n      if Tree.Line_Region (Indenting_Token).First = Indenting.Code.First then\n         if Ada_Indent_Return <= 0 then\n            declare\n               Anchor_Token : constant Syntax_Trees.Valid_Node_Access :=\n                 Tree.Child (Nonterm, Positive_Index_Type (Integer'(Args (1))));\n            begin\n               return Indent_Anchored_2\n                 (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment,\n                  Current_Indent_Offset (Tree, Anchor_Token, Args (2) + abs Ada_Indent_Return));\n            end;\n         else\n            declare\n               Anchor_Token : constant Syntax_Trees.Valid_Node_Access := Tree.Find_Sibling\n                 (Parameter_And_Result_Profile, +FUNCTION_ID);\n            begin\n               return Indent_Anchored_2\n                 (Data, Tree, Anchor_Token, Indenting_Token, Indenting_Comment,\n                  Current_Indent_Offset (Tree, Anchor_Token, Args (2) + abs Ada_Indent_Return));\n            end;\n         end if;\n\n      else\n         return Null_Delta;\n      end if;\n   end Ada_Indent_Return_0;\n\n   function Ada_Indent_Record_0\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Wisi.Indent_Arg_Arrays.Vector)\n     return Wisi.Delta_Type\n   is begin\n      return Indent_Record\n        (Parse_Data_Type (Data),\n         Tree,\n         Tree.Line_Region (Nonterm).First,\n         Anchor_Token      => Tree.Child (Nonterm, Positive_Index_Type (Integer'(Args (1)))),\n         Record_Token      => Tree.Child (Nonterm, Positive_Index_Type (Integer'(Args (2)))),\n         Indenting_Token   => Indenting_Token,\n         Indenting_Comment => Indenting_Comment,\n         Offset            => Args (3));\n   end Ada_Indent_Record_0;\n\n   function Ada_Indent_Record_1\n     (Data              : in out Wisi.Parse_Data_Type'Class;\n      Tree              : in     Syntax_Trees.Tree;\n      Nonterm           : in     WisiToken.Syntax_Trees.Valid_Node_Access;\n      Indenting_Token   : in     Syntax_Trees.Valid_Node_Access;\n      Indenting_Comment : in     Boolean;\n      Args              : in     Wisi.Indent_Arg_Arrays.Vector)\n     return Wisi.Delta_Type\n   is\n      --  We are indenting a token in record_definition or\n      --  record_representation_clause, or a comment before 'record'.\n      --\n      --  Args (1) is the token ID of the anchor. If record_definition, this\n      --  is TYPE; it appears as a direct child in an ancestor\n      --  full_type_declaration. If record_representation_clause, args (1)\n      --  is FOR, child of record_representation_clause.\n\n      use Ada_Annex_P_Process_Actions;\n\n      Anchor : constant Token_ID := Token_ID (Integer'(Args (1)));\n\n      Declaration : constant Syntax_Trees.Valid_Node_Access := Tree.Find_Ancestor\n        (Indenting_Token,\n         (if To_Token_Enum (Anchor) = TYPE_ID\n          then +full_type_declaration_ID\n          else +record_representation_clause_ID));\n\n      Tree_Anchor : constant Syntax_Trees.Valid_Node_Access := Tree.Find_Child (Declaration, Anchor);\n\n      --  Args (2) is the child index of RECORD (or a nonterminal possibly\n      --  starting with RECORD) in Nonterm\n      Record_Token : constant Syntax_Trees.Node_Access := Tree.Child\n        (Nonterm, Positive_Index_Type (Integer'(Args (2))));\n   begin\n      --  Args (3) is the offset\n      return Indent_Record\n        (Parse_Data_Type (Data),\n         Tree,\n         Tree.Line_Region (Nonterm).First,\n         Anchor_Token      => Tree_Anchor,\n         Record_Token      => Tree.First_Terminal (Record_Token),\n         Indenting_Token   => Indenting_Token,\n         Indenting_Comment => Indenting_Comment,\n         Offset            => Args (3));\n   end Ada_Indent_Record_1;\n\nend Wisi.Ada;\n"
               }
            }
         },
         "wait": []
      }
   },
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "id": "2",
            "method": "textDocument/definition",
            "params": {
               "textDocument": {"uri": "file:///Projects/org.emacs.ada-mode/wisi-ada.adb"},
               "position": {"line": 71, "character": 58}
            }
         },
         "wait": [
            {
               "id": "2",
               "result": [
                  {
                     "uri": "file:///Projects/org.wisitoken/wisitoken-syntax_trees.ads",
                     "range": {
                        "start": {"line": 1273, "character": 12},
                        "end": {"line": 1273, "character": 23}
                     }}]}]}},
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "method": "textDocument/didOpen",
            "params": {
               "textDocument": {
                  "uri": "file:///Projects/org.wisitoken/wisitoken-syntax_trees.ads",
                  "languageId": "ada-eglot",
                  "version": 0,
                  "text": "--  Abstract :\n--\n--  Syntax tree type and operations, providing parse streams as\n--  described in [1], but generalized for parallel parsers. Data\n--  structures and operations are optimized for incremental parsing.\n--\n--  References :\n--\n--  [1] Elad Lahav 2004, Efficient Semantic Analysis for Text Editors\n--\n--  Design :\n--\n--  There is one syntax tree; parallel parsers all add nodes to the\n--  same tree, maintaining different roots via Stream_IDs.\n--\n--  During parsing, the Shared_Stream contains all of the input source\n--  text, either as terminal tokens from the lexer in batch parse, or\n--  a mix of terminal (possibly virtual) and nonterminal tokens from\n--  Parse.Edit_Tree in incremental parse.\n--\n--  Node_Index is used only for debugging. Node_Index on nonterms is\n--  negative. Node_Index on terminal nodes created by the lexer in the\n--  shared stream is positive; Nod_Index on virtual nodes inserted by\n--  error recover is negative.\n--\n--  During a batch parse, Node_Index on terminals is sequential, as a\n--  consequence of lexing the source code first; Node_Index on\n--  nonterms is unique within the tree, and abs Node_Index of a\n--  nonterm is greater than abs Node_Index of any of its children.\n--  Error recover inserts and deletes terminals, with non-sequential\n--  Node_Index.\n--\n--  In incremental parse, Node_Index on terminals is not sequential,\n--  and Node_Index is not unique within the tree.\n--\n--  Error recover uses Sequential_Index to determine success, and to\n--  control where terminals are inserted and deleted. To be\n--  incremental, Sequential_Index is only set in a small portion of\n--  the shared stream at error recover start, and cleared when error\n--  recover completes.\n--\n--  During and after parsing, the sequence of terminals in the parse\n--  stream or syntax tree is given by Next_Terminal/Prev_Terminal.\n--\n--  Each parallel parser uses one stream as the parse stack and\n--  auxiliary input stream. The auxiliary input stream contains tokens\n--  that are pushed back in error recovery, or broken down from\n--  Shared_Stream in incremental parse.\n--\n--  Nodes that are deleted from the parse stream during error recover\n--  are referenced from the preceding terminal node or SOI, so they\n--  may be restored on the next incremental parse if appropriate.\n--  Similarly, parse errors are referenced from the error node. In\n--  order to avoid editing shared nodes, the nodes that are edited are\n--  copied to the parse stream first.\n--\n--  Each node contains a Parent link, to make it easy to traverse the\n--  tree in any direction after parsing is done. We do not set the\n--  Parent links while parsing, to avoid having to copy nodes. At the\n--  start of incremental parse (during and after Edit_Tree), the\n--  shared stream has complete parent links. However, Breakdown clears\n--  parent links, so shared nodes may not have complete parent links;\n--  error recover must use explicit Parent stack versions of tree\n--  routines. All Parent links are set when parse completes; condition\n--  Tree.Editable ensures that there is a single fully parsed tree\n--  with all parent links set. While editing the syntax tree after\n--  parse, any functions that modify children or parent relationships\n--  update the corresponding links, setting them to\n--  Invalid_Node_Access as appropriate.\n--\n--  We don't store the parse State in syntax tree nodes, to avoid\n--  having to copy nodes during parsing. State is stored in the parse\n--  stream elements. This means Parse.LR.Undo_Reduce has to call\n--  Action_For to compute the state for the child nodes.\n--\n--  During parsing, nodes are never deleted, copied or edited in any\n--  way once they are created, except for clearing parent links and\n--  setting Sequential_Index.\n--\n--  Type Tree is limited because a bit-copy is not a good start on copy\n--  for assign; use Copy_Tree.\n--\n--  We can't traverse Tree.Streams to deallocate tree Nodes, either\n--  when streams are terminated or during Finalize; in general Nodes\n--  are referenced multiple times in multiple streams. So we keep\n--  track of nodes to deallocate in Tree.Nodes. Nodes are deleted in\n--  Clear_Parse_Streams and when the entire tree is Finalized.\n--\n--  Copyright (C) 2018 - 2021 Free Software Foundation, Inc.\n--\n--  This library is free software;  you can redistribute it and/or modify it\n--  under terms of the  GNU General Public License  as published by the Free\n--  Software  Foundation;  either version 3,  or (at your  option) any later\n--  version. This library is distributed in the hope that it will be useful,\n--  but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN-\n--  TABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n--  As a special exception under Section 7 of GPL version 3, you are granted\n--  additional permissions described in the GCC Runtime Library Exception,\n--  version 3.1, as published by the Free Software Foundation.\n\npragma License (Modified_GPL);\n\nwith Ada.Finalization;\nwith Ada.Iterator_Interfaces;\nwith Ada.Unchecked_Deallocation;\nwith SAL.Gen_Definite_Doubly_Linked_Lists.Gen_Image_Aux;\nwith SAL.Gen_Indefinite_Doubly_Linked_Lists;\nwith SAL.Gen_Trimmed_Image;\nwith SAL.Gen_Unbounded_Definite_Stacks;\nwith SAL.Gen_Unbounded_Definite_Vectors;\nwith SAL.Gen_Unbounded_Sparse_Ordered_Sets;\nwith SAL.Generic_Decimal_Image;\nwith WisiToken.Lexer;\npackage WisiToken.Syntax_Trees is\n   use all type SAL.Base_Peek_Type;\n\n   type Node (<>) is private;\n   type Node_Access is access all Node;\n   subtype Valid_Node_Access is not null Node_Access;\n\n   Invalid_Node_Access : constant Node_Access := null;\n   Dummy_Node : constant Valid_Node_Access;\n   --  Use when you must initialize a Valid_Node_Access before overwritting it.\n\n   type Node_Access_Array is array (Positive_Index_Type range <>) of Node_Access;\n   type Valid_Node_Access_Array is array (Positive_Index_Type range <>) of Valid_Node_Access;\n\n   function To_Node_Access (Item : in Valid_Node_Access_Array) return Node_Access_Array;\n   function To_Valid_Node_Access (Item : in Node_Access_Array) return Valid_Node_Access_Array;\n\n   package Valid_Node_Access_Lists is new SAL.Gen_Definite_Doubly_Linked_Lists (Valid_Node_Access);\n   package Node_Stacks is new SAL.Gen_Unbounded_Definite_Stacks (Valid_Node_Access);\n\n   type Stream_ID is private;\n   Invalid_Stream_ID : constant Stream_ID;\n\n   type Stream_ID_Array is array (Positive_Index_Type range <>) of Stream_ID;\n\n   type Stream_Index is private;\n   Invalid_Stream_Index : constant Stream_Index;\n\n   type Node_Index is new Integer;\n   subtype Valid_Node_Index is Node_Index range 1 .. Node_Index'Last;\n   Invalid_Node_Index : constant Node_Index := 0;\n\n   type Base_Sequential_Index is new Integer;\n   Invalid_Sequential_Index : constant Base_Sequential_Index := Base_Sequential_Index'Last;\n   subtype Sequential_Index is Base_Sequential_Index range Base_Sequential_Index'First .. Invalid_Sequential_Index - 1;\n   --  Identifies a sequence of tokens in Shared_Stream during error\n   --  recovery. Index 1 is the error token (set in\n   --  wisitoken-parse-lr-mckenzie_recover-base.adb Initialize).\n   --\n   --  We need arbitrarily large negative index for Push_Back and\n   --  Undo_Reduce error recover operations, and arbitrarily large\n   --  positive index for handling unterminated strings.\n\n   type Base_Tree is new Ada.Finalization.Limited_Controlled with record\n      --  Visible components of Tree.\n\n      Lexer : WisiToken.Lexer.Handle;\n      --  Declared here because it provides access to the source text; any\n      --  code that needs access to Tree mostly likely also needs access to\n      --  the source text.\n   end record;\n\n   type Tree is new Base_Tree with private;\n   --  Use Copy_Tree to get a copy.\n\n   type Tree_Variable_Reference (Element : not null access Tree) is null record with\n     Implicit_Dereference => Element;\n\n   type Tree_Constant_Reference (Element : not null access constant Tree) is null record with\n     Implicit_Dereference => Element;\n\n   overriding procedure Finalize (Tree : in out Syntax_Trees.Tree);\n   --  Free any allocated storage.\n\n   procedure Free_Augmented (Tree : in Syntax_Trees.Tree);\n   --  Free Augmented in all nodes.\n\n   procedure Clear\n     (Tree        : in out Syntax_Trees.Tree;\n      Free_Memory : in     Boolean := False)\n   with Post => Tree.Cleared;\n   --  Delete all nodes in all streams, reset for new lex and parse.\n   --  Free_Memory applies to internal bookkeeping; leaving it False may\n   --  slightly speed parsing a similar sized file as the previous one.\n\n   function Is_Empty (Tree : in Syntax_Trees.Tree) return Boolean;\n\n   type Error_Data is abstract tagged null record;\n   --  Error_Data must not have Valid_Node_Access components; they would\n   --  not be updated properly when the tree is copied. The error node is\n   --  the node that contains this data.\n\n   function Dispatch_Equal (Left : in Error_Data; Right : in Error_Data'Class) return Boolean\n   is abstract;\n   --  True if Left matches Right for purposes of Update_Error and\n   --  Delete_Error, below.\n   --\n   --  Not named \"=\" because that's always ambiguous with the predefined \"=\".\n\n   function To_Message\n     (Data       : in Error_Data;\n      Tree       : in Syntax_Trees.Tree'Class;\n      Error_Node : in Valid_Node_Access)\n     return Error_Data'Class\n   is abstract;\n   --  Convert Data to a simple message; it is being moved to another\n   --  node (see wisitoken-parse-lr.adb Undo_Reduce).\n\n   function Image\n     (Data       : in Error_Data;\n      Tree       : in Syntax_Trees.Tree'Class;\n      Error_Node : in Valid_Node_Access)\n     return String\n   is abstract;\n   --  Should not include file name, line number; a higher level will add\n   --  that if desired.\n\n   type Null_Error_Data is new Error_Data with null record;\n   --  For Error_Data parameters when there is no error.\n\n   overriding function Dispatch_Equal\n     (Left  : in Null_Error_Data;\n      Right : in Error_Data'Class)\n     return Boolean\n   is (Right in Null_Error_Data);\n   overriding function To_Message\n     (Data       : in Null_Error_Data;\n      Tree       : in Syntax_Trees.Tree'Class;\n      Error_Node : in Valid_Node_Access)\n     return Error_Data'Class\n   is (raise SAL.Programmer_Error);\n\n   overriding function Image\n     (Data       : in Null_Error_Data;\n      Tree       : in Syntax_Trees.Tree'Class;\n      Error_Node : in Valid_Node_Access)\n     return String\n   is (\"\");\n\n   pragma Warnings (Off, \"\"\"others\"\" choice is redundant\");\n   No_Error : constant Null_Error_Data := (others => <>);\n   pragma Warnings (On);\n\n   No_Error_Classwide : constant Error_Data'Class := Error_Data'Class (No_Error);\n\n   package Error_Data_Lists is new SAL.Gen_Indefinite_Doubly_Linked_Lists (Error_Data'Class);\n   type Error_Data_List_Ref (List : not null access constant Error_Data_Lists.List) is private\n   with Implicit_Dereference => List;\n\n   type Node_Label is\n     (Source_Terminal,    -- text is user input, accessed via Lexer\n      Virtual_Terminal,   -- no text; inserted during error recovery\n      Virtual_Identifier, -- text in user data, created during tree rewrite\n      Nonterm);           -- nonterminal node.\n   subtype Terminal_Label is Node_Label range Source_Terminal .. Virtual_Identifier;\n   subtype Virtual_Terminal_Label is Node_Label range Virtual_Terminal .. Virtual_Identifier;\n\n   function Label (Node : in Valid_Node_Access) return Node_Label;\n\n   function Shared_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID;\n\n   type Stream_Node_Ref is record\n      Stream  : Stream_ID;\n      Element : Stream_Index;\n      Node    : Node_Access  := Invalid_Node_Access;\n      --  If both valid, Element contains Node in Stream. In some cases,\n      --  Element is valid but Node is Invalid_Node_Access (for example, if\n      --  the ref is the First_Terminal in an empty nonterm). In post-parse\n      --  actions, the parse stream is deleted, so Stream is\n      --  Invalid_Stream_Index, Element is Invalid_Stream_Index, but Node is\n      --  valid.\n   end record;\n\n   Invalid_Stream_Node_Ref : constant Stream_Node_Ref;\n\n   function Correct_Stream_Node\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Boolean;\n   --  True if Ref = Invalid_Stream_Node_Ref or Ref.Node =\n   --  Invalid_Node_Access or Stream contains Element, which contains\n   --  Node.\n   --\n   --  We allow Ref.Node = Invalid_Node_Access so a Stream_Node_Ref can\n   --  be First_Terminal of an empty nonterm, while still allowing\n   --  Next_Terminal (Ref).\n   --\n   --  Note that this is False in post-parse actions; there are no\n   --  streams, so Element is Invalid_Stream_Index.\n\n   function Valid_Stream_Node\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Boolean;\n   --  True if Ref refers to a node (possibly an empty nonterm).\n\n   subtype Terminal_Ref is Stream_Node_Ref\n   with Dynamic_Predicate =>\n     Terminal_Ref.Node = Invalid_Node_Access or else\n     Label (Terminal_Ref.Node) in Terminal_Label;\n\n   function Valid_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Terminal_Ref)\n     return Boolean\n   is (Valid_Stream_Node (Tree, Ref));\n   --  True if Ref refers to a Terminal node.\n\n   function Single_Terminal (Ref : in Stream_Node_Ref) return Boolean;\n   --  True if Ref contains a single terminal node.\n\n   function Valid_Single_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Boolean\n   is (Valid_Stream_Node (Tree, Ref) and then Single_Terminal (Ref));\n\n   subtype Single_Terminal_Ref is Stream_Node_Ref\n   with Dynamic_Predicate =>\n     Single_Terminal_Ref.Node = Invalid_Node_Access or else\n     Single_Terminal (Single_Terminal_Ref);\n\n   function Rooted (Ref : in Stream_Node_Ref) return Boolean;\n   --  True if Ref.Element.Node = Ref.Node.\n\n   subtype Rooted_Ref is Stream_Node_Ref\n   with Dynamic_Predicate =>\n     (Rooted_Ref = Invalid_Stream_Node_Ref --  allows initialization\n        or else Rooted (Rooted_Ref));\n\n   function To_Rooted_Ref\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Rooted_Ref;\n\n   type Stream_Node_Parents is record\n      Ref     : Stream_Node_Ref;\n      Parents : Node_Stacks.Stack;\n      --  Parents stores the path from Ref.Element.Node to Ref.Node. Parents\n      --  is empty if Ref is rooted (ie Ref.Element.Node = Ref.Node). If not\n      --  rooted, Parents.Peek (1) is Ref.Node parent, and Parents.Peek\n      --  (Parents.Depth) is Ref.Element.Node.\n   end record;\n\n   Invalid_Stream_Node_Parents : constant Stream_Node_Parents;\n\n   type Stream_Node_Parents_Array is array (Positive_Index_Type range <>) of Stream_Node_Parents;\n\n   function Parents_Valid (Ref : in Stream_Node_Parents) return Boolean;\n   --  True if Parents gives the path from Element.Node to Node, or Element or Node is invalid.\n\n   function To_Stream_Node_Parents (Tree : in Syntax_Trees.Tree; Ref : in Stream_Node_Ref) return Stream_Node_Parents\n   with Pre => Ref = Invalid_Stream_Node_Ref or else Tree.Parents_Set or else\n               (Rooted (Ref) or Ref.Node = Tree.First_Terminal (Get_Node (Ref.Element))),\n     Post => Parents_Valid (To_Stream_Node_Parents'Result);\n\n   type Recover_Token (Virtual : Boolean := True) is record\n      --  Virtual is True if there is no node in the syntax tree that is\n      --  this token; it was created by error recover.\n\n      --  Declared here because it needs Node_Access\n\n      --  Maintaining a syntax tree during error recovery is too slow, so we\n      --  store enough information in the recover stack to perform\n      --  In_Parse_Actions, Language_Fixes, Push_Back and Undo_Reduce\n      --  operations. and to apply the solution to the main parser state. We\n      --  make thousands of copies of the parse stack during recover, so\n      --  minimizing size and compute time for this is critical.\n\n      case Virtual is\n      when True =>\n         ID : Token_ID := Invalid_Token_ID;\n\n         First_Terminal : Node_Access := Invalid_Node_Access;\n         Last_Terminal  : Node_Access := Invalid_Node_Access;\n         --  For ID in Nonterminals, first and last terminal of this token in\n         --  the Tree shared or parse stream, cached from children;\n         --  Invalid_Node_Access if the children are virtual. For terminals,\n         --  Invalid_Node_Access. Used to detect empty nonterm and compute\n         --  Name.\n\n         Name : Buffer_Region := Null_Buffer_Region;\n         --  Set and used by In_Parse_Actions.\n\n         Contains_Virtual_Terminal : Boolean := False;\n         --  True if any contained terminal is Virtual.\n\n      when False =>\n         Element_Node : Node_Access := Invalid_Node_Access;\n         Node         : Node_Access := Invalid_Node_Access;\n         --  This token in the Tree shared or parse stream.\n         --\n         --  This implements a variant of Stream_Node_Ref for recover.\n         --\n         --  For terminals, Element_Node = Node.\n         --\n         --  For nonterminals, Node = some descendant of Element_Node (similar\n         --  to a Stream_Node_Ref).\n         --\n         --  This token can be virtual, if from Shared_Stream of an edited\n         --  tree.\n         --\n         --  In a non-default Recover_Token, Element_Node cannot be\n         --  Invalid_Node_Access. Node can be Invalid_Node_Access when it is\n         --  nominally a terminal and Element_Node is an empty nonterm.\n      end case;\n   end record;\n\n   subtype Virtual_Recover_Token is Recover_Token (Virtual => True);\n   subtype Real_Recover_Token is Recover_Token (Virtual => False);\n\n   Invalid_Recover_Token : constant Recover_Token := (Virtual => True, ID => Invalid_Token_ID, others => <>);\n\n   function Node_ID (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Token_ID\n   with Pre => Item.Virtual = False;\n   function Element_ID (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Token_ID;\n\n   function Element_Is_Terminal (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Boolean;\n   --  Virtual ID or Element_Node.\n\n   function Byte_Region (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Buffer_Region;\n\n   function Name (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Buffer_Region;\n   --  If Node.Name = Null_Buffer_Region and Is_Terminal (Node.ID),\n   --  return Node.Byte_Region; else return Node.Name.\n\n   procedure Set_Name\n     (Tree : in     Syntax_Trees.Tree;\n      Item : in out Recover_Token;\n      Name : in     Buffer_Region);\n\n   function Contains_Virtual_Terminal (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Boolean;\n   function Contains_Virtual_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Boolean;\n\n   function Is_Empty_Nonterm\n     (Tree : in Syntax_Trees.Tree;\n      Item : in Recover_Token)\n     return Boolean;\n   --  True if node contains no terminals.\n\n   function First_Terminal (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Node_Access;\n   function Last_Terminal (Tree : in Syntax_Trees.Tree; Item : in Recover_Token) return Node_Access;\n\n   function To_Real_Recover_Token (Item : in Stream_Node_Ref) return Real_Recover_Token\n   with Pre => Item.Element /= Invalid_Stream_Index;\n\n   function Make_Rooted (Item : in Recover_Token) return Recover_Token;\n\n   function Image\n     (Tree : in Syntax_Trees.Tree;\n      Item : in Recover_Token)\n     return String;\n\n   type Recover_Token_Array is array (Positive_Index_Type range <>) of Recover_Token;\n\n   ----------\n   --  User_Data_Type\n\n   type Base_Augmented is tagged null record;\n\n   function Image_Augmented (Aug : in Base_Augmented) return String\n   is (\"\");\n\n   type Augmented_Class_Access is access all Base_Augmented'Class;\n   type Augmented_Class_Access_Constant is access constant Base_Augmented'Class;\n\n   procedure Shift\n     (Augmented        : in out Base_Augmented;\n      Shift_Bytes      : in     Base_Buffer_Pos;\n      Shift_Chars      : in     Base_Buffer_Pos;\n      Shift_Line       : in     Base_Line_Number_Type;\n      Last_Stable_Byte : in     Buffer_Pos)\n   is null;\n   --  Add Shift_* to Augmented positions.\n\n   procedure Free is new Ada.Unchecked_Deallocation (Base_Augmented'Class, Augmented_Class_Access);\n\n   type User_Data_Type is tagged limited null record;\n   --  Many test languages don't need this, so we default the procedures\n   --  to null.\n\n   type User_Data_Access is access all User_Data_Type'Class;\n\n   function New_User_Data (Template : in User_Data_Type) return User_Data_Access\n   is (null);\n   --  Return a new empty object with the same type as Template.\n\n   procedure Reset (User_Data : in out User_Data_Type) is null;\n   --  Reset to start a new parse.\n\n   procedure Initialize_Actions\n     (User_Data : in out User_Data_Type;\n      Tree      : in     Syntax_Trees.Tree'Class)\n   is null;\n   --  Called by Execute_Actions, before processing the tree, after\n   --  Insert_Token/Delete_Token.\n\n   procedure Lexer_To_Augmented\n     (User_Data     : in out User_Data_Type;\n      Tree          : in out Syntax_Trees.Tree'Class;\n      Token         : in     Lexer.Token;\n      Grammar_Token : in     Valid_Node_Access)\n   is null;\n   --  Token is a grammar or non-grammar token that was just returned by\n   --  User_Data.Lexer. If grammar, it is Grammar_Token; if non-grammar,\n   --  it has already been added to Grammar_Token (which is SOI if before\n   --  first grammar token in input). Called before parsing, once for\n   --  each non-grammar token in the input stream.\n\n   function Copy_Augmented\n     (User_Data : in User_Data_Type;\n      Augmented : in Augmented_Class_Access)\n     return Augmented_Class_Access\n   with Pre => Augmented /= null;\n   --  Default implementation raises SAL.Programmer_Error.\n\n   function Insert_After\n     (User_Data           : in out User_Data_Type;\n      Tree                : in     Syntax_Trees.Tree'Class;\n      Insert_Token        : in     Valid_Node_Access;\n      Insert_Before_Token : in     Valid_Node_Access;\n      Comment_Present     : in     Boolean;\n      Blank_Line_Present  : in     Boolean)\n     return WisiToken.Insert_Location\n   with Post'Class => (if not (Blank_Line_Present or Comment_Present) then Insert_After'Result /= Between);\n   --  Return an insert location for Insert_Token. This can affect which\n   --  line it appears on, which affects indentation. Should be called from\n   --  user-overridden Insert_Token.\n   --\n   --  If Comment_Present, there is a comment between Tree.Prev_Terminal\n   --  (Insert_Before_Token) and Insert_Before_Token.\n   --\n   --  If Blank_Line_Present, there is at least one blank line\n   --  immediately after Tree.Prev_Terminal (Insert_Before_Token) (before\n   --  any comment).\n   --\n   --  The default implementation always returns Before_Next.\n\n   procedure Insert_Token\n     (User_Data      : in out User_Data_Type;\n      Tree           : in out Syntax_Trees.Tree'Class;\n      Trace          : in out WisiToken.Trace'Class;\n      Inserted_Token : in     Syntax_Trees.Valid_Node_Access)\n   is null\n   with Pre'Class => Tree.Parents_Set and Tree.Is_Virtual_Terminal (Inserted_Token);\n   --  Inserted_Token was inserted in error recovery. Move\n   --  Inserted_Token.Non_Grammar as needed to control which line the\n   --  token is on.\n   --\n   --  Called from Execute_Actions for each inserted token, before\n   --  Initialize_Actions.\n\n   procedure Delete_Token\n     (User_Data     : in out User_Data_Type;\n      Tree          : in     Syntax_Trees.Tree'Class;\n      Trace         : in out WisiToken.Trace'Class;\n      Deleted_Token : in     Valid_Node_Access)\n   with Pre'Class =>\n     Tree.Parents_Set and\n     Tree.Label (Deleted_Token) in Terminal_Label;\n   --  Deleted_Token was deleted in error recovery; Deleted_Token.Parent\n   --  is the non-deleted terminal token before Deleted_Token in the\n   --  parse stream.\n   --\n   --  The default body appends Deleted_Token.Non_Grammar to\n   --  Deleted_Token.Parent.Non_Grammar.\n   --\n   --  Called from Execute_Actions for each deleted token, before\n   --  Initialize_Actions.\n\n   procedure Reduce\n     (User_Data : in out User_Data_Type;\n      Tree      : in     Syntax_Trees.Tree'Class;\n      Nonterm   : in     Valid_Node_Access)\n   is null;\n   --  Called by Parser.Execute_Actions, just before processing Nonterm;\n   --  Nonterm was created by a 'reduce' parse action.\n\n   type Post_Parse_Action is access procedure\n     (User_Data : in out User_Data_Type'Class;\n      Tree      : in out Syntax_Trees.Tree;\n      Nonterm   : in     Valid_Node_Access);\n   --  Routines of this type are called by\n   --  WisiToken.LR.Parser.Execute_Actions when it processes a Nonterm\n   --  node in the syntax tree.\n\n   Null_Action : constant Post_Parse_Action := null;\n\n   ----------\n   --  Parsing operations (including error recovery and incremental\n   --  parse), Tree and Node attributes.\n\n   function New_Stream\n     (Tree       : in out Syntax_Trees.Tree;\n      Old_Stream : in     Stream_ID;\n      User_Data  : in     User_Data_Access)\n     return Stream_ID\n   with\n     Pre => Old_Stream = Invalid_Stream_ID or else\n            (not Tree.Parents_Set and Tree.Stream_Count > 1 and Tree.Is_Valid (Old_Stream)),\n     Post => Tree.Is_Valid (New_Stream'Result);\n   --  Create a new parse stream, initially copied from Old_Stream.\n\n   function Stream_Count (Tree : in Syntax_Trees.Tree) return Natural;\n   --  Number of active streams.\n\n   function First_Parse_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID\n   with Pre => Tree.Stream_Count >= 2;\n\n   function Last_Parse_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID\n   with Pre => Tree.Stream_Count >= 2;\n\n   procedure Next_Parse_Stream (Tree : in Syntax_Trees.Tree; Stream : in out Stream_ID)\n   with Pre => Stream /= Invalid_Stream_ID;\n\n   function Stream_Length (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return SAL.Base_Peek_Type\n   with Pre => Tree.Is_Valid (Stream);\n   --  Stack + input\n\n   function Stream_Input_Length (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return SAL.Base_Peek_Type\n   with Pre => Tree.Is_Valid (Stream);\n\n   function Stack_Depth (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return SAL.Base_Peek_Type\n   with Pre => Tree.Is_Valid (Stream);\n\n   procedure Delete_Stream (Tree : in out Syntax_Trees.Tree; Stream : in out Stream_ID)\n   with Pre => Tree.Is_Valid (Stream);\n   --  Delete the stream\n\n   function Is_Valid (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return Boolean;\n   --  Stream is available for parsing operations.\n\n   function Contains\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Token  : in Stream_Index)\n     return Boolean;\n   --  True if Stream and Token are valid, and Token is an element of Stream.\n\n   function Trimmed_Image (Item : in Stream_Index) return String;\n   --  Trimmed_Image of item.node_index.\n\n   function Trimmed_Image (Node : in Node_Access) return String;\n   --  Trimmed_Image of item.node_index.\n\n   function Get_Node\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Valid_Node_Access\n   with Pre => Tree.Contains (Stream, Element) or Tree.Contains (Tree.Shared_Stream, Element);\n   --  Parser.Current_Token may be from either stream.\n\n   function Get_Node\n     (Element : in Stream_Index)\n     return Valid_Node_Access\n   with Pre => Element /= Invalid_Stream_Index;\n   --  When we don't have the stream.\n\n   procedure Start_Lex\n     (Tree           : in out Syntax_Trees.Tree)\n   with Pre => Tree.Cleared,\n     Post => Tree.Lexable;\n   --  Create empty Tree.Shared_Stream, add SOI node containing\n   --  Tree.Lexer.Begin_Pos values to it.\n\n   procedure Start_Parse\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID;\n      State  : in     State_Index)\n   with Pre => (not Tree.Traversing and Stream /= Tree.Shared_Stream and Tree.Is_Valid (Stream)) and then\n               Tree.Stream_Length (Stream) = 0;\n   --  State must be the parser start state; it is stored in Tree.SOI.\n   --  Sets Tree.Parents_Set False.\n\n   procedure Start_Edit (Tree : in out Syntax_Trees.Tree)\n   with Pre => Tree.Editable,\n     Post => Tree.Parseable;\n   --  Construct Tree.Shared_Stream from Tree.SOI, Tree.Root, Tree.EOI.\n   --\n   --  On return, Tree is ready for Parse.Edit_Tree.\n   --\n   --  Parents_Set remains True. Parse.Edit_Tree calls Breakdown on\n   --  Shared_Stream Elements, which removes some parent links. However,\n   --  the remaining stream elements all have complete parent links; the\n   --  links removed point to nodes that are not accessible from the\n   --  shared stream.\n\n   function Reduce\n     (Tree            : in out Syntax_Trees.Tree;\n      Stream          : in     Stream_ID;\n      Production      : in     WisiToken.Production_ID;\n      Child_Count     : in     Ada.Containers.Count_Type;\n      Action          : in     Post_Parse_Action := null;\n      State           : in     State_Index;\n      Default_Virtual : in     Boolean         := False)\n     return Rooted_Ref\n   with Pre => not Tree.Traversing and not Tree.Parents_Set and Tree.Is_Valid (Stream) and Stream /= Tree.Shared_Stream,\n     Post => Reduce'Result.Stream = Stream and Tree.Valid_Stream_Node (Reduce'Result);\n   --  Reduce Child_Count tokens on Stream top of stack to a new Nonterm\n   --  node on Stream top of stack. Result points to the new Nonterm\n   --  node. If Child_Count = 0, set Nonterm.Virtual := Default_Virtual.\n   --\n   --  Set Result byte_region, char_region, line, column,\n   --  first_terminal to min/max of children.\n\n   procedure Shift\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID;\n      State  : in     State_Index);\n   --  Shift Stream current input token onto Stream stack. Then set State\n   --  in the Stream element.\n   --\n   --  Does _not_ clear shifted node Error_List; this shift may be part\n   --  of error recover.\n\n   function Pop\n     (Tree      : in out Syntax_Trees.Tree;\n      Stream    : in     Stream_ID)\n     return Valid_Node_Access\n   with Pre => not Tree.Traversing and Tree.Is_Valid (Stream);\n   --  Delete Stream stack top, returning its node.\n\n   procedure Push\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID;\n      Node   : in     Valid_Node_Access;\n      State  : in     State_Index)\n   with Pre => not Tree.Traversing and Tree.Is_Valid (Stream);\n   --  State, Node become Stream stack top.\n\n   procedure Push_Back\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID);\n   --  Move Stream.Stack_Top to Stream input.\n\n   procedure Move_Shared_To_Input\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID);\n   --  Insert Stream.Shared_Link into Parse_Stream input, increment\n   --  Stream.Shared_Link.\n   --\n   --  This is often needed before Left_Breakdown while parsing.\n\n   procedure Move_Shared_To_Input\n     (Tree   : in out Syntax_Trees.Tree;\n      First  : in     Stream_Node_Ref;\n      Last   : in     Stream_Node_Ref;\n      Stream : in     Stream_ID)\n   with Pre => Valid_Stream_Node (Tree, First) and Valid_Stream_Node (Tree, Last) and\n               First.Stream = Tree.Shared_Stream and Last.Stream = Tree.Shared_Stream and\n               Stream /= Tree.Shared_Stream;\n   --  Insert Shared_Stream elements First .. Last into Stream input.\n   --  Update Parse_Stream.Shared_Link to next Shared_Stream element\n   --  after Last.\n\n   procedure Left_Breakdown\n     (Tree : in out Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Ref)\n   with Pre =>\n     Valid_Stream_Node (Tree, Ref) and then\n     (Tree.Label (Ref.Element) = Nonterm and\n        Ref.Node /= Invalid_Node_Access and\n        Tree.Stack_Top (Ref.Stream) /= Ref.Element),\n     Post => Valid_Single_Terminal (Tree, Ref);\n   --  Bring first terminal of Ref.Element to the stream Ref.Stream\n   --  (which may be Shared_Stream in Edit_Tree). Ref.Element is updated\n   --  to the element containing the first terminal.\n   --\n   --  The stack top is unchanged. Note that Ref.Node is ignored on input.\n   --\n   --  Parent links are set to Invalid_Node_Access; if\n   --  Tree.Parents_Set, Child links are also cleared.\n\n   procedure Right_Breakdown\n     (Tree : in out Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Ref)\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Label (Ref.Element) = Nonterm and\n               Ref.Node /= Invalid_Node_Access and\n               Tree.Stack_Top (Ref.Stream) /= Ref.Element,\n     Post => Valid_Single_Terminal (Tree, Ref);\n   --  Bring last terminal of Ref.Element to the parse stream.\n   --  Ref.Element is updated to the element containing the last terminal.\n   --\n   --  The stack top is unchanged. Note that Ref.Node is ignored on input.\n   --\n   --  Parent links are set to Invalid_Node_Access. However, even if\n   --  Tree.Parents_Set, Child links are not changed.\n   --\n   --  FIXME: move errors as in Breakdown.\n\n   procedure Breakdown\n     (Tree      : in out Syntax_Trees.Tree;\n      Ref       : in out Terminal_Ref;\n      User_Data : in     User_Data_Access)\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Label (Ref.Element) = Nonterm and\n               Ref.Node /= Invalid_Node_Access and\n               Tree.Stack_Top (Ref.Stream) /= Ref.Element,\n     Post => Tree.First_Terminal (Get_Node (Ref.Element)) = Ref.Node;\n   --  Bring descendants of Ref.Element to the parse stream, until\n   --  First_Terminal of one of the parse stream elements = Ref.Node.\n   --  Ref.Element is updated to the element whose first terminal is\n   --  (a copy of) Ref.Node.\n   --\n   --  If Ref.Parents nonterms contain any errors, the errors are moved to\n   --  the first terminal of that nonterm, copying ancestor nodes, and\n   --  Ref.Parents is updated to match. If Ref.Node is one of those first\n   --  terminals, it will be copied.\n   --\n   --  The stack top is unchanged.\n   --\n   --  Parent/child links are set to Invalid_Node_Access as appropriate.\n\n   procedure Breakdown\n     (Tree      : in out Syntax_Trees.Tree;\n      Ref       : in out Stream_Node_Parents;\n      User_Data : in     Syntax_Trees.User_Data_Access)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Tree.Label (Ref.Ref.Element) = Nonterm and\n               Ref.Ref.Node /= Invalid_Node_Access and Tree.Stack_Top (Ref.Ref.Stream) /= Ref.Ref.Element and\n               Parents_Valid (Ref),\n     Post => Parents_Valid (Ref) and\n             Tree.First_Terminal (Get_Node (Ref.Ref.Element)) = Ref.Ref.Node;\n   --  Same as Breakdown (Ref.Ref), but supports not Tree.Parents_Set.\n\n   function State (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return State_Index\n   with Pre => Tree.Is_Valid (Stream);\n   --  Return State from Stream.Stack_Top.\n\n   function State\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Unknown_State_Index\n   with Pre => Tree.Contains (Stream, Element);\n   --  If Element is in input, state may be Unknown_State.\n\n   function Stream_First\n     (Tree     : in Syntax_Trees.Tree;\n      Stream   : in Stream_ID;\n      Skip_SOI : in Boolean := True)\n     return Stream_Index\n   with Pre => Tree.Is_Valid (Stream);\n\n   function Stream_First\n     (Tree     : in Syntax_Trees.Tree;\n      Stream   : in Stream_ID;\n      Skip_SOI : in Boolean := True)\n     return Rooted_Ref\n   with Pre => Tree.Is_Valid (Stream);\n\n   function Stream_Last\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Stream_Index\n   with Pre => Tree.Is_Valid (Stream);\n\n   function Stack_Top\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Stream_Index\n   with Pre => Tree.Is_Valid (Stream);\n\n   function Has_Input\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Boolean\n   with Pre => Stream /= Tree.Shared_Stream and Tree.Is_Valid (Stream);\n   --  Return True if there is a stream element after Stack_Top.\n\n   function First_Input\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Rooted_Ref\n   with Pre => Tree.Has_Input (Stream),\n     Post => Correct_Stream_Node (Tree, First_Input'Result);\n   --  Return first stream element after Stack_Top.\n\n   function Current_Token\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Rooted_Ref\n   with Post => Correct_Stream_Node (Tree, Current_Token'Result);\n   --  If Stream has input, then first input of Stream; otherwise\n   --  Stream.Shared_Link.\n\n   function Shared_Token\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Rooted_Ref\n   with Post => Correct_Stream_Node (Tree, Shared_Token'Result);\n   --  Stream.Shared_Link.\n\n   procedure Delete_Current_Token\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID);\n   --  User must call Add_Deleted with Deleted_Ref => Tree.Current_Input\n   --  before calling Delete_Current_Token.\n\n   function Stream_Next\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Stream_Index\n   with Pre => Element = Invalid_Stream_Index or else\n               (Tree.Contains (Stream, Element) or Tree.Contains (Tree.Shared_Stream, Element));\n   --  If Element is Invalid_Stream_Index, result is Stream_First (= SOI).\n\n   function Stream_Next\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Rooted_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Stream_Next'Result);\n   --  Return stream element after Ref.Element.\n\n   procedure Stream_Next\n     (Tree   : in     Syntax_Trees.Tree;\n      Ref    : in out Stream_Node_Ref;\n      Rooted : in     Boolean)\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Ref) and then\n             (Ref = Invalid_Stream_Node_Ref or else\n                (if Rooted\n                 then Tree.Get_Node (Ref.Stream, Ref.Element) = Ref.Node\n                 else Tree.First_Terminal (Tree.Get_Node (Ref.Stream, Ref.Element)) = Ref.Node));\n   --  Update Ref to root or first terminal of next stream element after Ref.Element.\n\n   procedure Stream_Next\n     (Tree   : in     Syntax_Trees.Tree;\n      Ref    : in out Stream_Node_Parents;\n      Rooted : in     Boolean)\n   with Pre => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref) and\n             (Ref.Ref = Invalid_Stream_Node_Ref or else\n                (if Rooted\n                 then Tree.Get_Node (Ref.Ref.Stream, Ref.Ref.Element) = Ref.Ref.Node\n                 else Tree.First_Terminal (Tree.Get_Node (Ref.Ref.Stream, Ref.Ref.Element)) = Ref.Ref.Node));\n   --  Update Ref to root or first terminal of next stream element after\n   --  Ref.Element.\n\n   function Stream_Prev\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Stream_Index\n   with Pre => Tree.Contains (Stream, Element);\n\n   function Stream_Prev\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Rooted_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Stream_Prev'Result);\n   --  Return stream element before Ref.Element.\n\n   procedure Stream_Prev\n     (Tree   : in     Syntax_Trees.Tree;\n      Ref    : in out Stream_Node_Ref;\n      Rooted : in     Boolean := True)\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Ref) and\n             (Ref = Invalid_Stream_Node_Ref or else\n                (if Rooted\n                 then Tree.Get_Node (Ref.Stream, Ref.Element) = Ref.Node\n                 else Tree.Last_Terminal (Tree.Get_Node (Ref.Stream, Ref.Element)) = Ref.Node));\n   --  Update Ref to root or last terminal of stream element before Ref.Element.\n\n   procedure Stream_Prev\n     (Tree   : in     Syntax_Trees.Tree;\n      Ref    : in out Stream_Node_Parents;\n      Rooted : in     Boolean)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and\n             (Ref.Ref = Invalid_Stream_Node_Ref or else\n                (if Rooted\n                 then Tree.Get_Node (Ref.Ref.Stream, Ref.Ref.Element) = Ref.Ref.Node\n                 else Tree.Last_Terminal (Tree.Get_Node (Ref.Ref.Stream, Ref.Ref.Element)) = Ref.Ref.Node));\n\n   procedure Stream_Insert\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID;\n      Node   : in     Valid_Node_Access;\n      Before : in     Stream_Index)\n   with Pre => Tree.Contains (Stream, Before);\n   --  Insert a new stream element on Stream containing Node, before Before.\n\n   function Stream_Insert\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID;\n      Node   : in     Valid_Node_Access;\n      Before : in     Stream_Index)\n     return Stream_Node_Ref\n   with Pre => Tree.Contains (Stream, Before);\n   --  Insert a new stream element on Stream containing Node, before Before.\n   --  Result references new element.\n\n   function Peek\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Count  : in SAL.Peek_Type := 1)\n     return Stream_Index\n   with Pre => Tree.Is_Valid (Stream);\n   --  Return Count element on stack in Stream; Count = 1\n   --  returns stack top.\n\n   function Add_Terminal\n     (Tree     : in out Syntax_Trees.Tree;\n      Stream   : in     Stream_ID;\n      Terminal : in     Lexer.Token;\n      Error    : in     Error_Data'Class)\n     return Single_Terminal_Ref\n   with Pre => not Tree.Traversing and Stream = Tree.Shared_Stream,\n     Post => Tree.Label (Add_Terminal'Result.Node) = Source_Terminal;\n   --  Append a new Source_Terminal element to Stream. Result points to the added\n   --  node.\n\n   type Token_Array_Var_Ref (Element : not null access WisiToken.Lexer.Token_Arrays.Vector) is private\n   with Implicit_Dereference => Element;\n\n   type Token_Array_Const_Ref (Element : not null access constant WisiToken.Lexer.Token_Arrays.Vector) is private\n   with Implicit_Dereference => Element;\n\n   function Has_Non_Grammar\n     (Tree     : in Syntax_Trees.Tree;\n      Terminal : in Valid_Node_Access)\n     return Boolean\n   with Pre => Tree.Label (Terminal) in Terminal_Label;\n\n   function Non_Grammar_Var\n     (Tree     : in Syntax_Trees.Tree;\n      Terminal : in Valid_Node_Access)\n     return Token_Array_Var_Ref\n   with Pre => Tree.Label (Terminal) in Terminal_Label;\n\n   function Non_Grammar_Const\n     (Tree     : in Syntax_Trees.Tree;\n      Terminal : in Valid_Node_Access)\n     return Token_Array_Const_Ref\n   with Pre => Tree.Label (Terminal) in Terminal_Label;\n\n   procedure Insert_Source_Terminal\n     (Tree     : in out Syntax_Trees.Tree;\n      Stream   : in     Stream_ID;\n      Terminal : in     Lexer.Token;\n      Before   : in     Stream_Index;\n      Error    : in     Error_Data'Class)\n   with Pre => not Tree.Traversing and (Before = Invalid_Stream_Index or else Tree.Contains (Stream, Before));\n   --  Insert a new Source_Terminal element on Stream, before Before.\n\n   function Insert_Source_Terminal\n     (Tree     : in out Syntax_Trees.Tree;\n      Stream   : in     Stream_ID;\n      Terminal : in     Lexer.Token;\n      Before   : in     Stream_Index;\n      Error    : in     Error_Data'Class)\n     return Single_Terminal_Ref\n   with Pre => not Tree.Traversing and (Before = Invalid_Stream_Index or else Tree.Contains (Stream, Before)),\n     Post => Tree.Label (Insert_Source_Terminal'Result.Node) = Source_Terminal;\n   --  Insert a new Source_Terminal element on Stream, before Before.\n   --  Result points to the added element.\n\n   function Insert_Virtual_Terminal\n     (Tree     : in out Syntax_Trees.Tree;\n      Stream   : in     Stream_ID;\n      Terminal : in     Token_ID)\n     return Single_Terminal_Ref\n   with\n     Pre  => not Tree.Traversing and Tree.Is_Valid (Stream) and Stream /= Tree.Shared_Stream,\n     Post => Tree.Label (Insert_Virtual_Terminal'Result.Node) = Virtual_Terminal;\n   --  Insert a new Virtual_Terminal element into Stream, after\n   --  Stack_Top. Result refers to the added node.\n\n   procedure Shift\n     (Tree             : in     Syntax_Trees.Tree;\n      Node             : in     Valid_Node_Access;\n      Shift_Bytes      : in     Base_Buffer_Pos;\n      Shift_Chars      : in     Base_Buffer_Pos;\n      Shift_Lines      : in     Base_Line_Number_Type;\n      Last_Stable_Byte : in     Buffer_Pos;\n      Non_Grammar_Next : in out Lexer.Token_Arrays.Extended_Index)\n   with Pre => Tree.Label (Node) in Terminal_Label;\n   --  Add Shift_* to token, non_grammar, and augmented corresponding\n   --  regions. If a non_grammar is after Last_Stable_Byte, set\n   --  Non_Grammar_Next to it, without shifting, and skip the rest of\n   --  non_grammar.\n\n   procedure Set_Node_Index\n     (Tree       : in Syntax_Trees.Tree;\n      Node       : in Valid_Node_Access;\n      Node_Index : in Syntax_Trees.Node_Index);\n\n   procedure Stream_Delete\n     (Tree    : in out Syntax_Trees.Tree;\n      Stream  : in     Stream_ID;\n      Element : in out Stream_Index)\n   with\n     Pre  => Tree.Contains (Stream, Element),\n     Post => Element = Invalid_Stream_Index;\n   --  Delete Element from Stream. If Element = Stream.Stack_Top,\n   --  Stack_Top is set to Invalid_Stream_Index.\n\n   function ID\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Token_ID\n   with Pre => Tree.Contains (Stream, Element) or Tree.Contains (Tree.Shared_Stream, Element);\n   --  The precondition allows either stream; Current_Token is\n   --  either a Source_Terminal from Shared_Stream or a Virtual_Terminal\n   --  in Stream input from error recovery; in incremental parse, it\n   --  could be a Source_Terminal in Stream input from push_back.\n\n   function Label (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Label;\n   function Label (Tree : in Syntax_Trees.Tree; Element : in Stream_Index) return Node_Label\n   with Pre => Element /= Invalid_Stream_Index;\n\n   function Child_Count (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return SAL.Base_Peek_Type;\n\n   function Children (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Access_Array\n   with Pre => Tree.Is_Nonterm (Node);\n   --  Any children that were deleted by tree editing are returned as\n   --  Invalid_Node_Access.\n\n   function Child\n     (Tree        : in Syntax_Trees.Tree;\n      Node        : in Valid_Node_Access;\n      Child_Index : in Positive_Index_Type)\n     return Node_Access\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Has_Children (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Has_Child\n     (Tree  : in Syntax_Trees.Tree;\n      Node  : in Valid_Node_Access;\n      Child : in Valid_Node_Access)\n     return Boolean\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Has_Parent (Tree : in Syntax_Trees.Tree; Child : in Valid_Node_Access) return Boolean;\n\n   function Is_Nonterm (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   function Is_Source_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   function Is_Virtual_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   function Is_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n\n   function Is_Empty_Nonterm (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   --  True if Node contains no terminals.\n\n   function Is_Empty_Or_Virtual_Nonterm\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Boolean;\n   --  True if Node contains no terminals, or all terminals are virtual,\n   --  and thus have Null_Buffer_Region for Byte_ and Char_Region.\n\n   function Is_Virtual_Identifier (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   function Traversing (Tree : in Syntax_Trees.Tree) return Boolean;\n\n   function Is_Next_Stream_Input\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Ref    : in Stream_Node_Ref)\n     return Boolean;\n   --  True if Ref is Stream.First_Input or Stream.Shared_Link if\n   --  Stream_First_Input is invalid.\n\n   procedure Set_Insert_Location\n     (Tree            : in Syntax_Trees.Tree;\n      Node            : in Valid_Node_Access;\n      Insert_Location : in WisiToken.Insert_Location)\n   with Pre => Tree.Is_Virtual_Terminal (Node);\n\n   procedure Set_Name\n     (Tree   : in Syntax_Trees.Tree;\n      Node   : in Valid_Node_Access;\n      Region : in Buffer_Region)\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function ID\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return WisiToken.Token_ID;\n\n   function ID\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return WisiToken.Token_ID;\n   --  One of Ref.Node.ID, Ref.Element.Node.ID, Invalid_Token_ID\n\n   function Production_ID\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return WisiToken.Production_ID\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Byte_Region (Tree : in Syntax_Trees.Tree; Index : in Stream_Index) return WisiToken.Buffer_Region\n   with Pre => Index /= Invalid_Stream_Index;\n\n   function Byte_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Node                 : in Valid_Node_Access;\n      Trailing_Non_Grammar : in Boolean := False)\n     return WisiToken.Buffer_Region;\n   --  If Trailing_Non_Grammar, any non_grammar attached to last terminal\n   --  in Node is included in region.\n   --\n   --  If Tree.Parents_Set:\n   --\n   --  Byte_Region of Virtual_Terminal is an empty region with .First\n   --  determined by Insert_Location, using previous or next\n   --  source_terminal or non_grammar.\n   --\n   --  Byte_Region of an empty nonterm with Trailing_Non_Grammar False is\n   --  an empty region; .First gives nominal location in source text,\n   --  using previous or next source_terminal or non_grammar.\n   --\n   --  If not Tree.Parents_Set, does as much of the above as possible,\n   --  returning Null_Buffer_Region if would need Parents_Set.\n\n   function Byte_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Ref                  : in Stream_Node_Ref;\n      Trailing_Non_Grammar : in Boolean := False)\n     return WisiToken.Buffer_Region\n   with Pre => Tree.Parents_Set and Valid_Stream_Node (Tree, Ref);\n   --  Return Byte_Region of Ref.Node, using stream to find prev, next\n   --  non_grammar if needed.\n\n   function Byte_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Ref                  : in Stream_Node_Parents;\n      Parse_Stream         : in Stream_ID;\n      Trailing_Non_Grammar : in Boolean := False)\n     return WisiToken.Buffer_Region\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n   --  Same as Byte_Region (Stream_Node_Ref), for use when parents are\n   --  not set. See Prev_Terminal (tree, stream_node_parents) for meaning\n   --  of Parse_Stream.\n\n   function Name (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Buffer_Region;\n   --  If Node.Label in Terminal_Label, return Node.Byte_Region; else if\n   --  Node.Name is not Null_Buffer_Region, return Node.Name; else return\n   --  Node.Byte_Region.\n\n   function Name (Tree : in Syntax_Trees.Tree; Ref : in Stream_Node_Ref) return Buffer_Region\n   with Pre => Valid_Stream_Node (Tree, Ref);\n   --  Call Name with Ref.Element.Node.\n\n   function Char_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Node                 : in Valid_Node_Access;\n      Trailing_Non_Grammar : in Boolean := False)\n     return WisiToken.Buffer_Region;\n   --  Similar to Byte_Region.\n\n   function Line_At_Byte_Pos\n     (Tree     : in Syntax_Trees.Tree;\n      Byte_Pos : in Buffer_Pos)\n     return Base_Line_Number_Type\n   with Pre => Tree.Editable;\n   --  Return line that contains Byte_Pos; Invalid_Line_Number is outside\n   --  range of text spanned by Tree.\n\n   function Line_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Node                 : in Valid_Node_Access;\n      Trailing_Non_Grammar : in Boolean := True)\n     return WisiToken.Line_Region\n   with Pre => Tree.Editable;\n   --  Lines of tokens in Node. First is the line started by the first\n   --  New_Line or SOI (start of input) before the first terminal in\n   --  Node. If Trailing_Non_Grammar, Last is the line ended by the last\n   --  New_Line in the first non_grammar array after the last terminal of\n   --  Node, or EOI (end of input); if not Trailing_Non_Grammar, Last is\n   --  the line ended by the first New_Line or EOI after the last\n   --  terminal of Node.\n\n   function Line_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Ref                  : in Stream_Node_Ref;\n      Trailing_Non_Grammar : in Boolean := True)\n     return WisiToken.Line_Region\n   with Pre => Tree.Valid_Stream_Node (Ref) and\n               (Tree.Parents_Set or Rooted (Ref) or Ref.Node = Tree.First_Terminal (Get_Node (Ref.Element)));\n   --  Same as Line_Region (Ref.Node), using Ref.Stream to find\n   --  prev/next non_grammar.\n   --\n   --  If not Tree.Parents_Set, constructs a Stream_Node_Parents\n   --  internally.\n\n   function Line_Region\n     (Tree                 : in Syntax_Trees.Tree;\n      Ref                  : in Stream_Node_Parents;\n      Parse_Stream         : in Stream_ID;\n      Trailing_Non_Grammar : in Boolean := True)\n     return WisiToken.Line_Region\n   with Pre => Tree.Valid_Stream_Node (Ref.Ref) and Parents_Valid (Ref);\n   --  Same as Line_Region (Stream_Node_Ref), for use when parents are\n   --  not set. See Prev_Terminal (tree, stream_node_parents) for meaning\n   --  of Parse_Stream.\n\n   function Line_Region\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Ref    : in Real_Recover_Token)\n     return WisiToken.Line_Region\n   with Pre => Ref.Element_Node = Ref.Node or Ref.Node = Tree.First_Terminal (Ref.Element_Node);\n   --  Constructs a Stream_Node_Parents from Stream, Ref. Assumes\n   --  Trailing_Non_Grammar => True. For use in error recovery.\n\n   function Column (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Ada.Text_IO.Count\n   with Pre => Tree.Editable and Tree.Subtree_Root (Node) = Tree.Root;\n   --  Column of first char of Node; offset from first character on line,\n   --  origin 0 (WisiToken and Emacs standard). If Node is empty or\n   --  Virtual, result is 0.\n\n   function Column\n     (Tree   : in Syntax_Trees.Tree;\n      Node   : in Valid_Node_Access;\n      Stream : in Stream_ID)\n     return Ada.Text_IO.Count;\n   --  Same as Column, but Node must be in Stream or Shared_Stream.\n\n   function RHS_Index\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Natural\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Get_Recover_Token\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Recover_Token;\n\n   function Get_Recover_Token\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Recover_Token;\n   --  Treat Node as a stream element.\n\n   function Children_Recover_Tokens\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Recover_Token_Array\n   with Pre => Tree.Contains (Stream, Element) and Tree.Label (Element) = Nonterm;\n\n   procedure Set_Augmented\n     (Tree  : in Syntax_Trees.Tree;\n      Node  : in Valid_Node_Access;\n      Value : in Augmented_Class_Access);\n   --  Value will be deallocated when Tree is finalized.\n\n   function Augmented\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Augmented_Class_Access;\n   --  Returns result of Set_Augmented.\n\n   function Augmented_Const\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Augmented_Class_Access_Constant;\n\n   function Action\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Post_Parse_Action\n   with Pre => Tree.Is_Nonterm (Node);\n\n   function Find_Ancestor\n     (Tree       : in Syntax_Trees.Tree;\n      Node       : in Valid_Node_Access;\n      ID         : in Token_ID;\n      Max_Parent : in Boolean := False)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   function Find_Ancestor\n     (Tree       : in Syntax_Trees.Tree;\n      Node       : in Valid_Node_Access;\n      IDs        : in Token_ID_Array;\n      Max_Parent : in Boolean := False)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return the ancestor of Node that contains one of IDs (starting\n   --  search with Node.Parent), or Invalid_Node_Access if none match.\n   --\n   --  If Max_Parent, return max parent found if none match; this will be\n   --  Invalid_Node_Access if Node has no parent.\n\n   function Find_Sibling\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access;\n      ID   : in Token_ID)\n     return Node_Access\n   with Pre => Tree.Parents_Set and Tree.Has_Parent (Node);\n   --  Return the sibling of Node that contains ID, or Invalid_Node_Access if\n   --  none match.\n\n   function Find_Child\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access;\n      ID   : in Token_ID)\n     return Node_Access\n   with Pre => Tree.Is_Nonterm (Node);\n   --  Return the child of Node whose ID is ID, or Invalid_Node_Access if\n   --  none match.\n\n   function Find_Descendant\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access;\n      ID   : in Token_ID)\n     return Node_Access;\n   --  Return the descendant of Node (may be Node) whose ID is ID, or\n   --  Invalid_Node_Access if none match.\n\n   function Find_Descendant\n     (Tree      : in     Syntax_Trees.Tree;\n      Node      : in     Valid_Node_Access;\n      Predicate : access function (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean)\n     return Node_Access;\n   --  Return the descendant of Node (may be Node) for which Predicate\n   --  returns True, or Invalid_Node_Access if none do.\n\n   function Is_Descendant_Of\n     (Tree       : in Syntax_Trees.Tree;\n      Root       : in Valid_Node_Access;\n      Descendant : in Valid_Node_Access)\n     return Boolean\n   with Pre => Tree.Parents_Set;\n\n   function Subtree_Root (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Valid_Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return top ancestor of Node.\n\n   procedure Process_Tree\n     (Tree         : in out Syntax_Trees.Tree;\n      Process_Node : access procedure\n        (Tree : in out Syntax_Trees.Tree;\n         Node : in     Valid_Node_Access);\n      Root         : in     Node_Access := Invalid_Node_Access)\n   with Pre => Root /= Invalid_Node_Access or else Tree.Root /= Invalid_Node_Access;\n   --  Traverse subtree of Tree rooted at Root (default single remaining\n   --  stream element) in depth-first order, calling Process_Node on each\n   --  node.\n\n   function Identifier (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Base_Identifier_Index\n   with Pre => Tree.Is_Virtual_Identifier (Node);\n\n   function Prev_Non_Grammar\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return first node before Node that has a non-empty Non_Grammar.\n   --  If Node = Tree.Root or Tree.SOI, return Tree.SOI.\n   --\n   --  Returns Invalid_Node_Access only in broken trees; we tolerate this\n   --  here so we can use this in Error_Message.\n\n   procedure Prev_Non_Grammar\n     (Tree         : in     Syntax_Trees.Tree;\n      Ref          : in out Stream_Node_Parents;\n      Parse_Stream : in     Stream_ID)\n   with Pre => Tree.Valid_Stream_Node (Ref.Ref) and Parents_Valid (Ref),\n     Post => Tree.Correct_Stream_Node (Ref.Ref) and Parents_Valid (Ref);\n\n   function First_Non_Grammar\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Node_Access;\n   --  Return first node in subtree under Node that has a non-empty\n   --  Non_Grammar.\n   --  Invalid_Node_Access if none.\n\n   function Last_Non_Grammar\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Node_Access;\n   --  Return last node in subtree under Node that has a non-empty\n   --  Non_Grammar.\n   --  Invalid_Node_Access if none.\n\n   function Next_Non_Grammar\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access)\n     return Valid_Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return first node after Node that has a non-empty Non_Grammar.\n   --  If Node = Tree.Root or Tree.EOI, return Tree.EOI.\n\n   procedure Next_Non_Grammar\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Parents)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Tree.Correct_Stream_Node (Ref.Ref) and Parents_Valid (Ref);\n\n   function First_Source_Terminal\n     (Tree                 : in Syntax_Trees.Tree;\n      Node                 : in Valid_Node_Access;\n      Trailing_Non_Grammar : in Boolean;\n      Following            : in Boolean := False)\n     return Node_Access\n   with Pre => (if Following then Tree.Parents_Set else True);\n   --  Return a terminal node that can give byte or char pos.\n   --\n   --  If Trailing_Non_Grammar, return first terminal in Node that is a\n   --  Source_Terminal, or a virtual terminal with non-empty non_grammar.\n   --  If not Trailing_Non_Grammar, only return a Source_Terminal.\n   --\n   --  If Following, return a matching terminal following Node if none\n   --  found in Node.\n\n   function Next_Source_Terminal\n     (Tree                 : in Syntax_Trees.Tree;\n      Node                 : in Valid_Node_Access;\n      Trailing_Non_Grammar : in Boolean)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return the next terminal node after Node that can give byte or\n   --  char pos; Invalid_Node_Access if there is no such node.\n   --\n   --  If Trailing_Non_Grammar, return next terminal after Ref.Ref.Node\n   --  that is a Source_Terminal, or a virtual terminal with non-empty\n   --  non_grammar. If not Trailing_Non_Grammar, only return a\n   --  Source_Terminal.\n\n   procedure Next_Source_Terminal\n     (Tree                 : in     Syntax_Trees.Tree;\n      Ref                  : in out Stream_Node_Ref;\n      Trailing_Non_Grammar : in     Boolean)\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Parents_Set,\n     Post => Tree.Correct_Stream_Node (Ref);\n   --  Update Ref to the next terminal node that can give byte or char\n   --  pos.\n   --\n   --  If Trailing_Non_Grammar, return next terminal after Ref.Node\n   --  that is a Source_Terminal, or a virtual terminal with non-empty\n   --  non_grammar. If not Trailing_Non_Grammar, only return a\n   --  Source_Terminal.\n\n   function Prev_Source_Terminal\n     (Tree                 : in Syntax_Trees.Tree;\n      Ref                  : in Stream_Node_Ref;\n      Trailing_Non_Grammar : in Boolean)\n     return Stream_Node_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Parents_Set,\n     Post => Tree.Correct_Stream_Node (Prev_Source_Terminal'Result);\n   --  Return the previous terminal node that can give byte or char pos.\n   --\n   --  If Trailing_Non_Grammar, return prev terminal before Ref.Ref.Node\n   --  that is a Source_Terminal, or a virtual terminal with non-empty\n   --  non_grammar. If not Trailing_Non_Grammar, only return a\n   --  Source_Terminal.\n\n   procedure Prev_Source_Terminal\n     (Tree                 : in     Syntax_Trees.Tree;\n      Ref                  : in out Stream_Node_Parents;\n      Parse_Stream         : in     Stream_ID;\n      Trailing_Non_Grammar : in     Boolean)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and not Tree.Parents_Set,\n     Post   => Tree.Correct_Stream_Node (Ref.Ref);\n\n   function Get_Virtuals (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Valid_Node_Access_Array\n   with Pre => Tree.Parents_Set,\n     Post => (for all Node of Get_Virtuals'Result => Tree.Label (Node) in Virtual_Terminal_Label);\n   --  Return list of virtual terminals in Node.\n\n   function Count_Terminals (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Natural;\n\n   function Get_Terminals (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Valid_Node_Access_Array\n   with Post => (for all Node of Get_Terminals'Result => Tree.Label (Node) in Terminal_Label);\n   --  Return sequence of terminals in Node.\n\n   function Get_Terminal_IDs (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Token_ID_Array;\n   --  Same as Get_Terminals, but return the IDs.\n\n   function First_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Access;\n   --  First of Get_Terminals. Invalid_Node_Access if Node is an empty nonterminal.\n\n   function First_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in     Valid_Node_Access;\n      Parents : in out Node_Stacks.Stack)\n     return Node_Access;\n   --  Same as First_Terminal (Tree, Node), also initializes Parents to\n   --  store path from Node to the first terminal, for Next_Terminal in\n   --  nodes that have unset parent links, or to limit Next_Terminal to\n   --  descendants of Node.\n   --\n   --  We don't have \"Pre => Parents.Is_Empty\" or \"Post => Parents_Valid\n   --  (Parents, First_Terminal'Result)\", because we call this function\n   --  recursively to create Parents.\n   --\n   --  Visible for use with error recovery Configuration input stream.\n\n   procedure First_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Ref)\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Valid_Stream_Node (Tree, Ref);\n   --  Update Ref to first terminal of Ref.Element.Node or a following\n   --  stream element. Continues search in Shared_Stream at\n   --  Stream.Shared_Link; will always find EOI.\n\n   function First_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Terminal_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Valid_Stream_Node (Tree, First_Terminal'Result);\n   --  Return first terminal in Ref.Element.Node or a following stream element.\n   --  Continues search in Shared_Stream; will always find EOI, so never\n   --  Invalid_Stream_Element.\n   --\n   --  Use First_Terminal_In_Node to not look in following stream\n   --  elements.\n\n   function First_Terminal_In_Node\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Terminal_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref);\n   --  Return first terminal in Ref.Node; Invalid_Node_Access if none.\n\n   procedure First_Terminal\n     (Tree      : in     Syntax_Trees.Tree;\n      Ref       : in out Stream_Node_Parents;\n      Following : in     Boolean)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Parents_Valid (Ref);\n   --  Update Ref to first terminal in Ref.Ref.Node or, if Following, a\n   --  following stream element - continues search in Shared_Stream.\n\n   function First_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Rooted_Ref)\n     return Stream_Node_Parents\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Valid_Stream_Node (Tree, First_Terminal'Result.Ref) and\n             Label (First_Terminal'Result.Ref.Node) in Terminal_Label and\n             Parents_Valid (First_Terminal'Result);\n   --  Return first terminal in Ref.Node or a following element.\n\n   function Last_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Access;\n   --  Last terminal in subtree under Node. Invalid_Node_Access if none.\n\n   function Last_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in     Valid_Node_Access;\n      Parents : in out Node_Stacks.Stack)\n     return Node_Access;\n   --  Same as Last_Terminal, also initializes Parents.\n   --\n   --  We don't have \"Pre => Parents.Is_Empty\" or \"Post => Parents_Valid\n   --  (Parents, Last_Terminal'Result)\", because we call this function\n   --  recursively to build Parents.\n   --\n   --  Visible for use with error recovery Configuration input stream.\n\n   procedure Last_Terminal\n     (Tree         : in     Syntax_Trees.Tree;\n      Ref          : in out Stream_Node_Parents;\n      Parse_Stream : in     Stream_ID)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Ref.Parents.Is_Empty,\n     Post => Parents_Valid (Ref);\n   --  Update Ref to last terminal of Ref.Ref.Element.Node or preceding\n   --  element.\n\n   function Prev_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Access\n   with Pre => Tree.Parents_Set,\n     Post => Prev_Terminal'Result = Invalid_Node_Access or else\n             Tree.Label (Prev_Terminal'Result) in Terminal_Label;\n   --  Return the terminal that is immediately before Node in subtree\n   --  containing Node; Invalid_Node_Access if Node is the first terminal\n   --  in that subtree.\n\n   function Prev_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Terminal_Ref)\n     return Terminal_Ref\n   with Pre => Tree.Parents_Set and Tree.Valid_Terminal (Ref),\n     Post => Tree.Correct_Stream_Node (Prev_Terminal'Result);\n\n   procedure Prev_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Terminal_Ref)\n   with Pre => Tree.Parents_Set and Tree.Valid_Terminal (Ref),\n     Post => Tree.Correct_Stream_Node (Ref);\n\n   procedure Prev_Terminal\n     (Tree         : in     Syntax_Trees.Tree;\n      Ref          : in out Stream_Node_Parents;\n      Parse_Stream : in     Stream_ID)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Tree.Correct_Stream_Node (Ref.Ref) and Parents_Valid (Ref);\n   --  If Parse_Stream is not Invalid_Stream_ID and Ref.Stream is\n   --  Shared_Stream, switches from Shared_Stream to Parse_Stream at\n   --  Parse_Stream.Shared_Link.\n\n   procedure Next_Terminal (Tree : in Syntax_Trees.Tree; Node : in out Node_Access)\n   with Pre => Tree.Parents_Set,\n     Post => Node = Invalid_Node_Access or else\n             Tree.Label (Node) in Terminal_Label;\n\n   function Next_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Access\n   with Pre => Tree.Parents_Set,\n     Post => Next_Terminal'Result = Invalid_Node_Access or else\n             Tree.Label (Next_Terminal'Result) in Terminal_Label;\n   --  Return the terminal that is immediately after Node in subtree\n   --  containing Node; Invalid_Node_Access if Node is the last terminal\n   --  in that subtree.\n\n   procedure Next_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Terminal_Ref)\n   with Pre => Tree.Parents_Set and Valid_Terminal (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Ref);\n   --  Update Ref to the next terminal that is after Ref.Node in Stream.\n   --  Continues search in Shared_Stream; will always find EOI. Result is\n   --  Invalid_Stream_Node_Ref if Ref.Node is EOI.\n\n   procedure Next_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Parents)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n   --  Same as Next_Terminal (Tree, Ref), using Ref.Parents for parent\n   --  links. Ref.Parents is initialized by First_Terminal.\n\n   function Next_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Terminal_Ref)\n     return Terminal_Ref\n   with Pre => Tree.Parents_Set and Valid_Terminal (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, Next_Terminal'Result);\n   --  Same as procedure Next_Terminal, but return result.\n\n   procedure Next_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in out Node_Access;\n      Parents : in out Node_Stacks.Stack);\n   --  Same as Next_Terminal, using Parents instead of node parent links.\n   --  Parent is initialized by First_Terminal.\n   --\n   --  Visible for use with error recovery Configuration input stream.\n\n   function First_Sequential_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Node_Access)\n     return Node_Access;\n   --  Return first terminal with valid Sequential_Index in Node;\n   --  Invalid_Node_Access if none.\n\n   function First_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in     Node_Access;\n      Parents : in out Node_Stacks.Stack)\n     return Node_Access;\n   --  Same as Tree.First_Sequential_Terminal (Node), also initialize\n   --  Parents.\n\n   procedure First_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in out Node_Access;\n      Parents : in out Node_Stacks.Stack);\n   --  Update Node to first terminal with valid Sequential_Index in Node;\n   --  Invalid_Node_Access if none. Also initialize Parents.\n\n   procedure First_Sequential_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Syntax_Trees.Stream_Node_Parents)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n   --  Return first terminal with valid Sequential_Index in Ref.Node or a\n   --  following stream element; continues search in Tree.Shared_Stream.\n   --  Invalid_Node_Access if none found.\n\n   procedure First_Sequential_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Stream_Node_Ref)\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Parents_Set,\n     Post => Correct_Stream_Node (Tree, Ref);\n   --  Return first terminal with valid Sequential_Index in Ref.Node or a\n   --  following stream element; continues search in Tree.Shared_Stream.\n   --  Invalid_Node_Access if none found.\n\n   function First_Sequential_Terminal\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Syntax_Trees.Rooted_Ref)\n     return Terminal_Ref\n   with Pre => Valid_Stream_Node (Tree, Ref),\n     Post => Correct_Stream_Node (Tree, First_Sequential_Terminal'Result);\n   --   Same as First_Sequential_Terminal, does not require Parents_Set.\n\n   function Last_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in     Node_Access;\n      Parents : in out Node_Stacks.Stack)\n     return Node_Access;\n   --  Return last terminal in Node that has a valid Sequential_Index,\n   --  also initialize Parents.\n\n   function Last_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in     Node_Access)\n     return Node_Access;\n   --  Return last terminal in Node that has a valid Sequential_Index.\n   --  Uses an internal parents stack.\n\n   procedure Last_Sequential_Terminal\n     (Tree         : in     Syntax_Trees.Tree;\n      Ref          : in out Syntax_Trees.Stream_Node_Parents;\n      Parse_Stream : in     Stream_ID)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n   --  Update Ref to last terminal with valid Sequential_Index in\n   --  Ref.Node or a preceding stream element; if Ref.Stream is\n   --  Tree.Shared_Stream, switches to Parse_Stream at\n   --  Parse_Stream.Shared_Link. Invalid_Node_Access if none found.\n\n   procedure Next_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in out Node_Access;\n      Parents : in out Node_Stacks.Stack)\n   with Pre => Tree.Label (Node) in Terminal_Label;\n   --  Update Node to the first terminal with valid Sequential_Index\n   --  following Node. .\n\n   procedure Next_Sequential_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Syntax_Trees.Stream_Node_Ref)\n   with Pre => Valid_Stream_Node (Tree, Ref) and Tree.Parents_Set,\n     Post => Correct_Stream_Node (Tree, Ref);\n\n   procedure Next_Sequential_Terminal\n     (Tree : in     Syntax_Trees.Tree;\n      Ref  : in out Syntax_Trees.Stream_Node_Parents)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n\n   procedure Prev_Sequential_Terminal\n     (Tree    : in     Syntax_Trees.Tree;\n      Node    : in out Node_Access;\n      Parents : in out Node_Stacks.Stack)\n   with Pre => Tree.Label (Node) in Terminal_Label;\n   --  Update Node to the last terminal with valid Sequential_Index\n   --  preceding Node.\n\n   procedure Prev_Sequential_Terminal\n     (Tree         : in     Syntax_Trees.Tree;\n      Ref          : in out Stream_Node_Parents;\n      Parse_Stream : in     Stream_ID)\n   with Pre => Valid_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref),\n     Post => Correct_Stream_Node (Tree, Ref.Ref) and Parents_Valid (Ref);\n\n   function Get_IDs\n     (Tree : in Syntax_Trees.Tree;\n      Node : in Valid_Node_Access;\n      ID   : in Token_ID)\n     return Valid_Node_Access_Array;\n   --  Return all descendants of Node matching ID.\n\n   ----------\n   --  Post-parsing operations; editing the tree. The tree has one or\n   --  zero streams, so these subprograms have no stream argument.\n   --\n   --  Some of these are also used for Packrat parsing, and don't have a\n   --  precondition of Fully_Parsed.\n\n   function Cleared (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if there are no streams and no nodes.\n\n   function Lexable (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if there is a shared stream that contains only SOI.\n\n   function Parseable (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if there are no parse streams and\n   --  Shared_Stream holds a lexed or edited stream.\n\n   function Fully_Parsed (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if there is only one parse stream, and it has only two\n   --  elements; SOI with the start state and the tree root (EOI is only\n   --  in the shared stream).\n\n   function Editable (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if Clear_Parse_Streams and Set_Parents have been called; the\n   --  remaining tree may be arbitrarily edited.\n\n   function Copy_Subtree\n     (Tree      : in out Syntax_Trees.Tree;\n      Root      : in     Node_Access;\n      User_Data : in     User_Data_Access)\n     return Node_Access\n   with Pre => Editable (Tree);\n   --  Deep copy (into Tree) subtree of Tree rooted at Root. Return root\n   --  of new subtree; it has no parent.\n   --\n   --  If Root is Invalid_Node_Access, returns Invalid_Node_Access.\n\n   procedure Copy_Tree\n     (Source      : in     Tree;\n      Destination :    out Tree;\n      User_Data   : in     User_Data_Access)\n   with Pre => Editable (Source);\n   --  The subtree at Tree.Root is copied. Destination parents are set.\n   --  All references are deep copied; Source may be finalized after this\n   --  operation.\n\n   procedure Clear_Parse_Streams\n     (Tree       : in out Syntax_Trees.Tree;\n      Keep_Nodes : in     Valid_Node_Access_Lists.List := Valid_Node_Access_Lists.Empty_List)\n   with Pre => Tree.Fully_Parsed or Tree.Stream_Count = 1,\n     Post => Tree.Editable;\n   --  If Tree.Root is not set, set it to the root of the single\n   --  remaining parse stream. Delete the parse stream and shared stream.\n   --  Delete all nodes not reachable from the root, and not Tree.SOI,\n   --  Tree.EOI, or in Keep_Nodes. Also call Set_Parents if not\n   --  Tree.Parents_Set.\n   --\n   --  Keep_Nodes should be set to nodes that occur in errors, or are\n   --  deleted by error recovery; they may be referenced by post-parse\n   --  actions.\n   --\n   --  No precondition for Packrat parser.\n\n   function Parents_Set (Tree : in Syntax_Trees.Tree) return Boolean;\n\n   procedure Set_Parents\n     (Tree   : in out Syntax_Trees.Tree;\n      Stream : in     Stream_ID := Invalid_Stream_ID);\n   --  If Stream is not Invalid_Stream_ID, set parents in all elements of\n   --  Stream. Otherwise, if Tree.Root is set, sets parents in tree\n   --  rooted at Tree.Root.\n   --\n   --  No precondition for packrat.\n\n   function Valid_Root (Tree : in Syntax_Trees.Tree) return Boolean;\n   --  True if Tree has a single root.\n\n   function Root (Tree : in Syntax_Trees.Tree) return Node_Access\n   with Pre => Tree.Valid_Root;\n   --  Tree.Root, or the root in the last parse stream if Tree.Root is\n   --  not set. Can be Invalid_Node_Access if input syntax does not allow\n   --  parsing to succeed.\n\n   procedure Set_Root (Tree : in out Syntax_Trees.Tree; New_Root : in Valid_Node_Access)\n   with Pre => (Tree.Parseable and Tree.Label (New_Root) = Nonterm) and then Tree.Child_Count (New_Root) > 0;\n   --  Set Tree.Root to Root. If New_Root.Children does not start with\n   --  Tree.SOI, prepend it. If New_Root.Children does not end with\n   --  Tree.EOI, append it.\n   --\n   --  Precondition matches Packrat parser conditions at end of parse.\n\n   function SOI (Tree : in Syntax_Trees.Tree) return Node_Access;\n   --  Return node representing start of input in the shared stream. It\n   --  has non_grammar giving the first line number, and all non_grammar\n   --  before the first grammar node.\n   --\n   --  Note that SOI may be copied in a parse stream, when it has\n   --  Following_Deleted.\n\n   function EOI (Tree : in Syntax_Trees.Tree) return Node_Access;\n   --  Return node representing end of input in the shared stream. It has\n   --  non_grammar giving the last line number. Invalid_Node_Access if it\n   --  has not yet been seen by the lexer.\n   --\n   --  Note that EOI may be copied in a parse stream, when it has an error.\n\n   function Parent\n     (Tree  : in Syntax_Trees.Tree;\n      Node  : in Valid_Node_Access;\n      Count : in Positive := 1)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return Count parent of Node.\n\n   function Find_Byte_Pos\n     (Tree                 : in Syntax_Trees.Tree;\n      Byte_Pos             : in Buffer_Pos;\n      Trailing_Non_Grammar : in Boolean)\n     return Node_Access;\n   --  Return the terminal that contains (including non_grammar if\n   --  Trailing_Non_Grammar) or is first after Byte_Pos.\n   --  Invalid_Node_Access if Byte_Pos is after text spanned by Tree.\n\n   function Find_Byte_Pos\n     (Tree                 : in Syntax_Trees.Tree;\n      Stream               : in Stream_ID;\n      Byte_Pos             : in Buffer_Pos;\n      Trailing_Non_Grammar : in Boolean;\n      Start_At             : in Terminal_Ref)\n     return Terminal_Ref\n   with Pre => Start_At = Invalid_Stream_Node_Ref or else Tree.Byte_Region (Start_At.Node).First <= Byte_Pos;\n   --  Return the terminal that contains (including non_grammar if\n   --  Trailing_Non_Grammar) or is first after Byte_Pos.\n   --  Invalid_Stream_Node_Ref if Byte_Pos is after text spanned by\n   --  Tree.Stream.\n   --\n   --  If Start_At is not Invalid_Stream_Node_Ref, start search there.\n\n   function Find_Char_Pos\n     (Tree                 : in Syntax_Trees.Tree;\n      Char_Pos             : in Buffer_Pos;\n      After                : in Boolean;\n      Trailing_Non_Grammar : in Boolean)\n     return Node_Access;\n   --  If After, return the first terminal after or containing\n   --  Char_Point. Otherwise return the terminal containing Char_Point.\n   --  If Include_Non_Grammar, non_grammar is included in token\n   --  char_region. Invalid_Node_Access if none.\n\n   function Find_New_Line\n     (Tree : in Syntax_Trees.Tree;\n      Line : in Line_Number_Type)\n     return Node_Access\n   with Pre => Tree.Editable,\n     Post => Find_New_Line'Result = Invalid_Node_Access or else\n             (Tree.Is_Terminal (Find_New_Line'Result));\n   --  Return the terminal node containing a non_grammar that ends Line -\n   --  1. Result is Invalid_Node_Access if Line is outside range spanned\n   --  by Tree.\n\n   function Find_New_Line\n     (Tree                : in     Syntax_Trees.Tree;\n      Line                : in     Line_Number_Type;\n      Line_Begin_Char_Pos :    out Buffer_Pos)\n     return Node_Access\n   with Pre => Tree.Editable,\n     Post => Find_New_Line'Result = Invalid_Node_Access or else\n             (Tree.Is_Terminal (Find_New_Line'Result));\n   --  Same as Find_New_Line, also updates Line_Begin_Char_Pos to first\n   --  char pos on Line.\n\n   procedure Next_New_Line\n     (Tree               : in     Syntax_Trees.Tree;\n      Start_Ref          : in     Terminal_Ref;\n      After_Non_Grammar  : in     Positive_Index_Type;\n      Result_Ref         :    out Terminal_Ref;\n      Result_Non_Grammar :    out Positive_Index_Type)\n   with Pre => Tree.Non_Grammar_Const (Start_Ref.Node).Last_Index >= After_Non_Grammar,\n     Post => Tree.Non_Grammar_Const (Result_Ref.Node).Last_Index >= Result_Non_Grammar;\n   --  Return next New_Line or EOI.\n\n   function Line_Begin_Char_Pos\n     (Tree : in Syntax_Trees.Tree;\n      Line : in Line_Number_Type)\n     return Buffer_Pos\n   with Pre => Tree.Editable;\n   --  First character on Line in text spanned by tree under Tree.Root;\n   --  it may be in no token, or in a grammar or non-grammar token.\n   --  Result is Invalid_Buffer_Pos if Line is not in the text spanned by\n   --  Tree, or if Line is inside a multi-line token.\n\n   function Line_Begin_Char_Pos\n     (Tree : in Syntax_Trees.Tree;\n      Line : in Line_Number_Type;\n      Stream : in Stream_ID)\n     return Buffer_Pos;\n   --  Same as other Line_Begin_Char_Pos, but searches in Stream instead of\n   --  Tree.Root. If not found there, continues searching input in\n   --  Shared_Stream.\n\n   function Line_Begin_Token\n     (Tree : in Syntax_Trees.Tree;\n      Line : in Line_Number_Type)\n     return Node_Access\n   with Pre => Tree.Parents_Set;\n   --  Return the node under Tree.Root of the first terminal token on\n   --  line Line; Invalid_Node_Access if there are no grammar tokens on\n   --  the line (ie only comment or whitespace), or the line is outside\n   --  the text spanned by Tree.\n\n   function Line_Begin_Token\n     (Tree                      : in Syntax_Trees.Tree;\n      Line                      : in Line_Number_Type;\n      Stream                    : in Stream_ID;\n      Following_Source_Terminal : in Boolean)\n     return Node_Access;\n   --  Same as other Line_Begin_Token, but searches in Stream instead of\n   --  Tree.Root. If not found there, continues searching input in\n   --  Shared_Stream.\n   --\n   --  If Following_Source_Terminal, returns next Source_Terminal in\n   --  stream if there are no grammar tokens on Line.\n\n   function Add_Nonterm\n     (Tree            : in out Syntax_Trees.Tree;\n      Production      : in     WisiToken.Production_ID;\n      Children        : in     Valid_Node_Access_Array;\n      Clear_Parents   : in     Boolean;\n      Action          : in     Post_Parse_Action := null;\n      Default_Virtual : in     Boolean         := False)\n     return Valid_Node_Access\n   with Pre => not Tree.Traversing and Children'First = 1;\n   --  Add a new Nonterm node (not on any stream), containing\n   --  Children, with no parent. Result points to the added node. If\n   --  Children'Length = 0, set Nonterm.Virtual := Default_Virtual.\n   --\n   --  If Parents_Set, Children.Parent are set to the new node. If a\n   --  child has a previous parent, then if Clear_Parents, the\n   --  corresponding entry in the parent's Children is set to null; if\n   --  not Clear_Parents and assertions are enabled, Assertion_Error is\n   --  raised.\n\n   function Add_Terminal\n     (Tree     : in out Syntax_Trees.Tree;\n      Terminal : in     Lexer.Token;\n      Error    : in     Error_Data'Class)\n     return Valid_Node_Access\n   with Pre => not Tree.Traversing and Tree.Editable;\n   --  Add a new Terminal node with no parent, on no stream. Result\n   --  points to the added node.\n\n   function Add_Terminal\n     (Tree       : in out Syntax_Trees.Tree;\n      Terminal   : in     Token_ID)\n     return Valid_Node_Access\n   with Pre => not Tree.Traversing and Tree.Editable;\n   --  Add a new Virtual_Terminal node with no parent, on no stream.\n   --  Result points to the added node.\n\n   procedure Add_Deleted\n     (Tree          : in out Syntax_Trees.Tree;\n      Deleted_Ref   : in     Stream_Node_Ref;\n      Prev_Terminal : in out Stream_Node_Parents;\n      User_Data     : in     User_Data_Access)\n   with Pre =>\n     Tree.Valid_Stream_Node (Deleted_Ref) and\n     Tree.Label (Deleted_Ref.Node) in Terminal_Label and\n     Tree.Valid_Stream_Node (Prev_Terminal.Ref) and\n     Parents_Valid (Prev_Terminal) and\n     Prev_Terminal.Ref.Stream /= Tree.Shared_Stream and\n     Tree.Label (Prev_Terminal.Ref.Node) = Source_Terminal;\n   --  Copy Prev_Terminal.Ref.Node, add Deleted_Node to\n   --  Prev_Terminal.Ref.Node.Following_Deleted. Update Prev_Terminal to\n   --  point to copied node. Move any non_grammar from Deleted_Node to\n   --  Prev_Terminal.Ref.Node.\n   --\n   --  Note that this does _not_ delete Deleted_Ref from the input; use\n   --  Delete_Current_Token for that.\n\n   function Has_Following_Deleted\n     (Tree : in out Syntax_Trees.Tree;\n      Node : in     Valid_Node_Access)\n     return Boolean\n   with Pre => Tree.Label (Node) = Source_Terminal;\n\n   type Valid_Node_Access_List_Var_Ref (List : not null access Valid_Node_Access_Lists.List) is private\n   with Implicit_Dereference => List;\n\n   function Following_Deleted\n     (Tree : in out Syntax_Trees.Tree;\n      Node : in     Valid_Node_Access)\n     return Valid_Node_Access_List_Var_Ref\n   with Pre => Tree.Label (Node) = Source_Terminal;\n\n   procedure Delete_Subtree\n     (Tree : in out Syntax_Trees.Tree;\n      Root : in out Node_Access);\n   --  Free all nodes under Root\n   --\n   --  No precondition; called from Finalize.\n\n   function Add_Identifier\n     (Tree        : in out Syntax_Trees.Tree;\n      ID          : in     Token_ID;\n      Identifier  : in     Identifier_Index)\n     return Valid_Node_Access\n   with Pre => not Tree.Traversing and Tree.Editable;\n   --  Add a new Virtual_Identifier node with no parent, on no stream.\n   --  Result points to the added node.\n\n   function Child_Index\n     (Tree   : in Syntax_Trees.Tree;\n      Parent : in Valid_Node_Access;\n      Child  : in Valid_Node_Access)\n     return SAL.Peek_Type\n   with Pre => Tree.Has_Child (Parent, Child);\n\n   procedure Replace_Child\n     (Tree                 : in out Syntax_Trees.Tree;\n      Parent               : in     Valid_Node_Access;\n      Child_Index          : in     SAL.Peek_Type;\n      Old_Child            : in     Node_Access;\n      New_Child            : in     Node_Access;\n      Old_Child_New_Parent : in     Node_Access := Invalid_Node_Access)\n   with\n     Pre => not Tree.Traversing and Tree.Editable and\n            (Tree.Is_Nonterm (Parent) and then\n               (Tree.Child (Parent, Child_Index) = Old_Child and\n                  (Old_Child = Invalid_Node_Access or else\n                     Tree.Parent (Old_Child) = Parent)));\n   --  In Parent.Children, replace child at Child_Index with New_Child.\n   --  Unless Old_Child is Invalid_Node_Access, set Old_Child.Parent to\n   --  Old_Child_New_Parent (may be Invalid_Node_Access). Unless New_Child\n   --  is Invalid_Node_Access, set New_Child.Parent to Parent.\n\n   procedure Set_Children\n     (Tree     : in out Syntax_Trees.Tree;\n      Node     : in out Valid_Node_Access;\n      New_ID   : in     WisiToken.Production_ID;\n      Children : in     Node_Access_Array)\n   with\n     Pre => not Tree.Traversing and Tree.Editable and\n            Tree.Is_Nonterm (Node) and (for all C of Children => C /= Invalid_Node_Access);\n   --  If parents of current Node.Children are not Invalid_Node_Access,\n   --  set corresponding entry in those parents to Invalid_Node_Access,\n   --  then set the child parent to Invalid_Node_Access.\n   --\n   --  Then set ID of Node to New_ID, and Node.Children to Children; set\n   --  parents of Children to Node.\n   --\n   --  If New_ID /= Tree.Production_ID (Node), Node.Action is set\n   --  to null, because the old Action probably no longer applies.\n   --\n   --  We use a precondition on Children, rather than\n   --  Valid_Node_Access_Array, so constructs like:\n   --\n   --     Tree.Set_Children (node, new_id, tree.childrend())\n   --\n   --  are legal.\n   --\n   --  Node is 'in out' because it must be reallocated if Children'length\n   --  /= Node.Children'length. If it is reallocated,\n   --  Node.Parent.Children is updated; the caller must update any other\n   --  copies of Node.\n\n   procedure Clear_Parent\n     (Tree           : in out Syntax_Trees.Tree;\n      Node           : in     Valid_Node_Access;\n      Clear_Children : in     Boolean)\n   with Pre => not Tree.Traversing;\n   --  If Clear_Children and Node.Parent /= Invalid_Node_Access, set\n   --  child in Node.Parent to Invalid_Node_Access, and if Node.Parent =\n   --  Tree.Root, set Tree.Root to Node. Finally, set Node.Parent to\n   --  Invalid_Node_Access.\n   --\n   --  Clear_Children should be False unless Tree is Editable or Node is\n   --  in Shared_Stream.\n\n   ----------\n   --  Accessing parse errors\n\n   function Contains_Error\n     (Tree       : in Syntax_Trees.Tree;\n      Error_Node : in Valid_Node_Access;\n      Data       : in Error_Data'Class)\n     return Boolean;\n   --  True if Error_Node's error list contains an element matching Data.\n\n   procedure Add_Error_To_Input\n     (Tree      : in out Syntax_Trees.Tree;\n      Stream    : in     Stream_ID;\n      Data      : in     Error_Data'Class;\n      User_Data : in     User_Data_Access);\n   --  Copy Stream.Shared_Link.Node to Stream, add Data to its error list.\n\n   procedure Add_Error_To_Stack_Top\n     (Tree      : in out Syntax_Trees.Tree;\n      Stream    : in     Stream_ID;\n      Data      : in     Error_Data'Class;\n      User_Data : in     User_Data_Access);\n   --  Copy Stream.Stack_Top.Node, add Data to its error list.\n\n   procedure Add_Errors\n     (Tree      : in out Syntax_Trees.Tree;\n      Error_Ref : in out Stream_Node_Parents;\n      Errors    : in     Error_Data_Lists.List;\n      User_Data : in     User_Data_Access)\n   with Pre => Parents_Valid (Error_Ref) and\n     (for all Err of Errors => not Tree.Contains_Error (Error_Ref.Ref.Node, Err));\n   --  Copy Error_Ref.Node and parents, add Errors to its error list.\n   --  Update Error_Ref to point to copied node.\n\n   type Error_Predicate is access function (Cur : in Error_Data_Lists.Cursor) return Boolean;\n\n   procedure Delete_Errors_In_Input\n     (Tree      : in out Syntax_Trees.Tree;\n      Stream    : in     Stream_ID;\n      Predicate : in     Error_Predicate;\n      User_Data : in     User_Data_Access);\n   --  Delete errors in Current_Token where Predicate returns True.\n   --\n   --  If Current_Token is a nonterm, deletes errors the entire subtree.\n\n   function Input_Has_Matching_Error\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Data   : in Error_Data'Class)\n     return Boolean;\n   --  Return True if Data matches (according to Dispatching_Equal) an\n   --  error on the current input node.\n\n   procedure Update_Error\n     (Tree      : in out Syntax_Trees.Tree;\n      Stream    : in     Stream_ID;\n      Error_Ref : in out Stream_Node_Parents;\n      Data      : in     Error_Data'Class;\n      User_Data : in     User_Data_Access)\n   with Pre => Tree.Contains_Error (Error_Ref.Ref.Node, Data),\n     Post => Tree.Contains_Error (Error_Ref.Ref.Node, Data);\n   --  Move Error_Ref to Stream, update error list element matching Data,\n   --  copying Error_Ref.Node and all ancestors. Update Error_Ref to\n   --  point to new stream element with copied nodes.\n\n   function Error_List (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Error_Data_List_Ref;\n   --  To change the error data, use Add_Error, which will copy Node.\n   --\n   --  Returns an empty list if Has_Error (Node) is false, so users can\n   --  just use 'for Err of Tree.Error_List (Node) loop'\n\n   type Error_Ref is record\n      --  Used when tree is fully parsed.\n      Node    : Node_Access;\n      Deleted : Valid_Node_Access_Lists.Cursor;\n      --  If Node = Invalid_Node_Access, no error. If Deleted = No_Element,\n      --  Node has an error. If Deleted /= No_Element, any error on Node has\n      --  already been visited, Element (Deleted) is a Source_Terminal that\n      --  has an error, and Element (Deleted).Parent = Node.\n\n      Error : Error_Data_Lists.Cursor;\n      --  Element in error node Error_Data_List.\n   end record;\n\n   Invalid_Error_Ref : constant Error_Ref :=\n     (Invalid_Node_Access, Valid_Node_Access_Lists.No_Element, Error_Data_Lists.No_Element);\n\n   type Stream_Error_Ref is record\n      --  Used while parsing\n      Ref     : Stream_Node_Parents;\n      Deleted : Valid_Node_Access_Lists.Cursor;\n      Error   : Error_Data_Lists.Cursor;\n   end record;\n\n   Invalid_Stream_Error_Ref : constant Stream_Error_Ref;\n\n   type Stream_Error_Cursor is private;\n   --  We need an extra layer of indirection for this type because\n   --  Stream_ID used in Stream_Node_Parents is private.\n\n   function Error (Item : in Stream_Error_Cursor) return Stream_Error_Ref;\n\n   function Error (Item : in Error_Ref) return Error_Data'Class;\n   function Error (Item : in Stream_Error_Ref) return Error_Data'Class;\n\n   function Error_Node (Tree : in Syntax_Trees.Tree; Error : in Error_Ref) return Node_Access\n   with Pre => Valid_Error_Ref (Error);\n\n   function Error_Node (Tree : in Syntax_Trees.Tree; Error : in Stream_Error_Ref) return Node_Access\n   with Pre => Valid_Error_Ref (Error);\n\n   function First_Error (Tree : in Syntax_Trees.Tree) return Error_Ref\n   with Pre => Tree.Parents_Set;\n   --  Return first error node in Tree.\n\n   function First_Error (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return Stream_Error_Ref;\n   --  Return first error node in Stream.\n\n   function Valid_Error_Ref (Error : in Error_Ref) return Boolean;\n   function Valid_Error_Ref (Error : in Stream_Error_Ref) return Boolean;\n   --  True if Error.Node is invalid_Node_Access or\n   --  Error.Node.Parse_Error is non-null or Error.Node.Following_Deleted\n   --  contains Error.Deleted and that node has an error.\n\n   procedure Next_Error (Tree : in Syntax_Trees.Tree; Error : in out Error_Ref)\n   with Pre => Tree.Parents_Set and (Error.Node /= Invalid_Node_Access and then Valid_Error_Ref (Error));\n   --  Update Error to next error node.\n\n   procedure Next_Error (Tree : in Syntax_Trees.Tree; Error : in out Stream_Error_Ref)\n   with Pre => Error.Ref.Ref.Node /= Invalid_Node_Access and then Valid_Error_Ref (Error);\n   --  Update Error to next error node.\n\n   function Error_Count (Tree : in Syntax_Trees.Tree) return Ada.Containers.Count_Type\n   with Pre => Tree.Parents_Set;\n   function Error_Count (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return Ada.Containers.Count_Type;\n\n   function Has_Error (Error : in Error_Ref) return Boolean;\n   function Has_Error (Error : in Stream_Error_Ref) return Boolean;\n   function Has_Error (Position : in Stream_Error_Cursor) return Boolean;\n   function Has_Error (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean;\n   function Has_Error (Node : in Valid_Node_Access) return Boolean;\n\n   package Error_Iterator_Interfaces is new Ada.Iterator_Interfaces\n     (Cursor      => Error_Ref,\n      Has_Element => Has_Error);\n\n   function Error_Iterate\n     (Tree     : aliased in Syntax_Trees.Tree)\n     return Error_Iterator_Interfaces.Forward_Iterator'Class;\n   --  Iterates over errors.\n\n   package Stream_Error_Iterator_Interfaces is new Ada.Iterator_Interfaces\n     (Cursor      => Stream_Error_Cursor,\n      Has_Element => Has_Error);\n\n   function Stream_Error_Iterate\n     (Tree   : aliased in Syntax_Trees.Tree;\n      Stream :         in Stream_ID)\n     return Stream_Error_Iterator_Interfaces.Forward_Iterator'Class;\n   --  Iterates over errors in Stream.\n\n   ----------\n   --  Debug and error message utils.\n   --\n   --  Typically no preconditions so they help with debugging errors\n   --  detected by other preconditions.\n\n   function Trimmed_Image (Tree : in Syntax_Trees.Tree; Item : in Stream_ID) return String;\n   function Next_Stream_ID_Trimmed_Image (Tree : in Syntax_Trees.Tree) return String;\n   --  Trimmed integer.\n\n   type Image_Action is access function (Action : in Post_Parse_Action) return String;\n\n   function Image\n     (Tree         : in Syntax_Trees.Tree;\n      Children     : in Boolean                   := False;\n      Non_Grammar  : in Boolean                   := False;\n      Augmented    : in Boolean                   := False;\n      Line_Numbers : in Boolean                   := False;\n      Root         : in Node_Access               := Invalid_Node_Access;\n      Image_Action : in Syntax_Trees.Image_Action := null)\n     return String;\n   --  Image of all streams, or root node if no streams.\n   --  If Children, subtree of each stream element is included.\n\n   function Image\n     (Tree          : in Syntax_Trees.Tree;\n      Stream        : in Stream_ID;\n      Stack         : in Boolean                   := True;\n      Input         : in Boolean                   := True;\n      Shared        : in Boolean                   := False;\n      Children      : in Boolean                   := False;\n      Node_Numbers  : in Boolean                   := True;\n      Non_Grammar   : in Boolean                   := False;\n      Augmented     : in Boolean                   := False;\n      Line_Numbers  : in Boolean                   := False;\n      Image_Action  : in Syntax_Trees.Image_Action := null;\n      State_Numbers : in Boolean                   := True)\n     return String;\n   --  Image of each node. If Stack, includes stack; if Input, includes\n   --  input; if Shared, includes continuation in Shared_Stream. If\n   --  Children, each entire subtree is included, with newlines, as in\n   --  Print_Tree.\n\n   function Image\n     (Tree                  : in Syntax_Trees.Tree;\n      Element               : in Stream_Index;\n      State                 : in Boolean                   := False;\n      Children              : in Boolean                   := False;\n      RHS_Index             : in Boolean                   := False;\n      Node_Numbers          : in Boolean                   := False;\n      Terminal_Node_Numbers : in Boolean                   := False;\n      Line_Numbers          : in Boolean                   := False;\n      Non_Grammar           : in Boolean                   := False;\n      Augmented             : in Boolean                   := False;\n      Expecting             : in Boolean                   := False;\n      Image_Action          : in Syntax_Trees.Image_Action := null)\n     return String;\n   --  Element can be from any stream, or Invalid_Stream_Index\n\n   function Image\n     (Tree                  : in Syntax_Trees.Tree;\n      Node                  : in Node_Access;\n      Children              : in Boolean                   := False;\n      RHS_Index             : in Boolean                   := False;\n      Node_Numbers          : in Boolean                   := False;\n      Terminal_Node_Numbers : in Boolean                   := False;\n      Line_Numbers          : in Boolean                   := False;\n      Non_Grammar           : in Boolean                   := False;\n      Augmented             : in Boolean                   := False;\n      Expecting             : in Boolean                   := False;\n      Image_Action          : in Syntax_Trees.Image_Action := null)\n     return String;\n   function Image\n     (Tree                  : in Syntax_Trees.Tree;\n      Nodes                 : in Node_Access_Array;\n      RHS_Index             : in Boolean                   := False;\n      Node_Numbers          : in Boolean                   := False;\n      Terminal_Node_Numbers : in Boolean                   := False;\n      Line_Numbers          : in Boolean                   := False;\n      Non_Grammar           : in Boolean                   := False;\n      Augmented             : in Boolean                   := False;\n      Image_Action          : in Syntax_Trees.Image_Action := null)\n     return String;\n\n   function Image\n     (Tree                  : in Syntax_Trees.Tree;\n      Ref                   : in Stream_Node_Ref;\n      First_Terminal        : in Boolean                   := False;\n      Node_Numbers          : in Boolean                   := False;\n      Terminal_Node_Numbers : in Boolean                   := False;\n      Line_Numbers          : in Boolean                   := False;\n      Non_Grammar           : in Boolean                   := False;\n      Augmented             : in Boolean                   := False;\n      Expecting             : in Boolean                   := False;\n      Image_Action          : in Syntax_Trees.Image_Action := null)\n     return String;\n   --  If First_Terminal, show First_Terminal of Ref.Node if Ref is rooted.\n\n   function Image\n     (Tree : in Syntax_Trees.Tree;\n      List : in Valid_Node_Access_Lists.List)\n     return String;\n\n   function Decimal_Image is new SAL.Generic_Decimal_Image (Node_Index);\n   function Trimmed_Image is new SAL.Gen_Trimmed_Image (Node_Index);\n   function Trimmed_Image is new SAL.Gen_Trimmed_Image (Base_Sequential_Index);\n\n   function Get_Node_Index (Node : in Node_Access) return Node_Index;\n   function Get_Node_Index (Tree : in Syntax_Trees.Tree; Node : in Node_Access) return Node_Index;\n   function Get_Node_Index (Element : in Stream_Index) return Node_Index;\n   function Get_Node_Index\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Node_Index\n   with Pre => Element = Invalid_Stream_Index or else Tree.Contains (Stream, Element);\n   --  Version without Tree requires Syntax_Trees.Get_Node_Index. Returns\n   --  Invalid_Node_Index for Invalid_Node_Access.\n\n   function Get_Sequential_Index (Tree : in Syntax_Trees.Tree; Node : in Node_Access) return Base_Sequential_Index\n   with Pre => Node = Invalid_Node_Access or else Tree.Label (Node) in Terminal_Label;\n   --  For convenience, returns Invalid_Sequential_Index if Node =\n   --  Invalid_Node_Access.\n\n   procedure Set_Sequential_Index\n     (Tree  : in Syntax_Trees.Tree;\n      Node  : in Valid_Node_Access;\n      Index : in Base_Sequential_Index)\n   with Pre => Tree.Label (Node) in Terminal_Label;\n\n   function Node_Access_Compare (Left, Right : in Node_Access) return SAL.Compare_Result\n   with Pre => Left /= Invalid_Node_Access and Right /= Invalid_Node_Access;\n   --  Only valid on a batch parsed tree, where Node_Index is ordered and\n   --  unique.\n   --\n   --  Left, Right can't be Valid_Node access because\n   --  SAL.Gen_Unbounded_Sparse_Ordered_Sets requires a valid default\n   --  initialization.\n\n   package Node_Sets is new SAL.Gen_Unbounded_Sparse_Ordered_Sets (Node_Access, Node_Access_Compare);\n\n   function Error_Message\n     (Tree    : in Syntax_Trees.Tree;\n      Node    : in Valid_Node_Access;\n      Message : in String)\n     return String\n   with Pre => Tree.Parents_Set;\n   --  File_Name from Tree.Lexer, line, column from Node\n\n   function Error_Message\n     (Tree    : in Syntax_Trees.Tree;\n      Ref     : in Stream_Node_Ref;\n      Message : in String)\n     return String;\n   --  File_Name from Tree.Lexer, line, column from Node\n\n   type Validate_Node is access procedure\n     (Tree                : in     Syntax_Trees.Tree;\n      Node                : in     Valid_Node_Access;\n      Data                : in out User_Data_Type'Class;\n      Node_Image_Output   : in out Boolean;\n      Node_Error_Reported : in out Boolean);\n   --  Called by Validate_Tree for each node visited; perform checks\n   --  other than parent/child, output to Text_IO.Current_Error.\n   --\n   --  Don't report errors if Node_Error_Reported is already True.\n   --  Set Node_Error_Reported True if any errors are reported.\n   --\n   --  If Node_Image_Output is False, output Image (Tree, Node,\n   --  Node_Numbers => True) once before any error messages.\n\n   procedure Validate_Tree\n     (Tree             : in out Syntax_Trees.Tree;\n      User_Data        : in out User_Data_Type'Class;\n      Error_Reported   : in out Node_Sets.Set;\n      Node_Index_Order : in     Boolean;\n      Root             : in     Node_Access                := Invalid_Node_Access;\n      Validate_Node    : in     Syntax_Trees.Validate_Node := null);\n   --  Verify that no children are Invalid_Node_Access. Verify\n   --  child/parent links. If Node_Index_Order, verify that\n   --  Node.Node_Index > Node.Children.Node_Index (which is true in a\n   --  batch parse tree). Call Validate_Node for each visited node.\n   --  Violations output a message to Text_IO.Current_Error.\n   --  Error_Reported is used to avoid outputing an error for a node more\n   --  than once.\n\n   procedure Sequential_Index_Cleared (Tree : in Syntax_Trees.Tree);\n   --  Raises SAL.Programmer_Error if any node in Tree or Tree.Streams\n   --  has Sequential_Index /= Invalid_Sequential_Index.\n\n   procedure Print_Tree\n     (Tree         : in     Syntax_Trees.Tree;\n      Trace        : in out WisiToken.Trace'Class;\n      Root         : in     Node_Access               := Invalid_Node_Access;\n      Image_Action : in     Syntax_Trees.Image_Action := null;\n      Line_Numbers : in     Boolean                   := False;\n      Non_Grammar  : in     Boolean                   := False);\n   --  Print tree rooted at Root (default Tree.Root) to\n   --  Trace, for debugging.\n   --\n   --  This is the same as Trace.Put_Line (Tree.Image (..., Children =>\n   --  True)), but avoids storing the entire trace image on the stack;\n   --  required for large trees.\n\n   procedure Print_Streams\n     (Tree        : in     Syntax_Trees.Tree;\n      Trace       : in out WisiToken.Trace'Class;\n      Children    : in     Boolean := False;\n      Non_Grammar : in     Boolean := False);\n\n   function Tree_Size_Image (Tree : in Syntax_Trees.Tree) return String;\n   --  For debugging; node counts.\n\nprivate\n   use all type Ada.Containers.Count_Type;\n   use all type Valid_Node_Access_Lists.Cursor;\n\n   type Error_List_Access is access all Error_Data_Lists.List;\n   procedure Free is new Ada.Unchecked_Deallocation (Error_Data_Lists.List, Error_List_Access);\n\n   type Node\n     (Label       : Node_Label;\n      Child_Count : SAL.Base_Peek_Type)\n      --  Descriminants have no default because allocated nodes are\n      --  constrained anyway (ARM 4.8 6/3).\n   is record\n      ID : WisiToken.Token_ID := Invalid_Token_ID;\n\n      Node_Index : Syntax_Trees.Node_Index := 0;\n      --  Used only for debugging. If Terminal_Label, positive, and\n      --  corresponds to text order after initial lex. If Nonterm, negative,\n      --  arbitrary. After a batch parse, node indices are unique within the\n      --  tree, but after incremental editing, they are reused because nodes\n      --  created for unsuccessful parse streams are deleted.\n\n      Parent : Node_Access := Invalid_Node_Access;\n\n      Augmented : Augmented_Class_Access := null;\n\n      Error_List : Error_List_Access;\n      --  We store an access to an error list object in each node, rather\n      --  than a list object, to reduce the size of a node; almost all nodes\n      --  have no errors.\n\n      case Label is\n      when Terminal_Label =>\n         Non_Grammar : aliased Lexer.Token_Arrays.Vector;\n         --  Immediately following Node. In initial lex, this can only be in a\n         --  Source_Terminal node. User Insert_Terminal can move it to a\n         --  Virtual_Terminal node, editing the tree can copy it to a\n         --  Virtual_Identifier node.\n         --\n         --  Not a pointer, because many nodes have non_grammar, and to\n         --  simplify using Tree.Non_Grammar_Var.\n\n         Sequential_Index : Syntax_Trees.Base_Sequential_Index := Invalid_Sequential_Index;\n\n         case Label is\n         when Source_Terminal =>\n            Byte_Region : Buffer_Region := Null_Buffer_Region;\n            Char_Region : Buffer_Region := Null_Buffer_Region;\n            --  Data from lexer. We store the absolute buffer region here to avoid\n            --  storing all whitespace in the tree. Edit_Tree shifts these for\n            --  incremental parse. We don't store Line_Region here, to save space,\n            --  to simplify Edit_Tree, and because it changes when Insert_Terminal\n            --  moves Non_Grammar.\n\n            Following_Deleted : aliased Valid_Node_Access_Lists.List;\n            --  Nodes that follow this terminal that were deleted by error\n            --  recovery.\n            --  FIXME: change to ptr like error_list, for space saving?\n\n         when Virtual_Terminal_Label =>\n            Insert_Location : WisiToken.Insert_Location := Before_Next;\n            --  Overridden Insert_Token can change the default.\n            --  If the node has non_grammar tokens, Insert_Location must be\n            --  Between.\n\n            case Label is\n            when Virtual_Terminal =>\n               null;\n            when Virtual_Identifier =>\n               Identifier : Identifier_Index; -- index into user data\n            when Source_Terminal | Nonterm =>\n               null;\n            end case;\n\n         when Nonterm =>\n            null;\n         end case;\n\n      when Nonterm =>\n         Virtual : Boolean := False;\n         --  True if any child node is Virtual_Terminal or Nonterm with Virtual\n         --  set. Used by In_Parse_Actions and error recover, via\n         --  Contains_Virtual_Terminal.\n\n         RHS_Index : Natural;\n         --  With ID, index into Productions.\n\n         Action : Post_Parse_Action := null;\n\n         Name_Offset : Base_Buffer_Pos := 0;\n         Name_Length : Base_Buffer_Pos := 0;\n         --  Name_* are set and checked by In_Parse_Actions. We use an offset\n         --  from First_Terminal (Node).Byte_Region.First, rather than a\n         --  Buffer_Region, to avoid needing to shift it during Edit_Tree for\n         --  incremental parse. FIXME: generalize for other actions;\n         --  post_parse_augmented, in_parse_augmented.\n\n         Children : Node_Access_Array (1 .. Child_Count);\n         --  We use an explicit array, rather than a pointer to the first\n         --  child, to preserve child indices while editing the tree.\n      end case;\n   end record;\n\n   type Stream_Label is range -2 .. Integer'Last;\n   --  First parser has label 0, for compatibility with tests, and for\n   --  general sanity. There is no practical upper limit; parsing a large\n   --  file spawns and terminates thousands of parsers.\n\n   Invalid_Stream_Label : constant Stream_Label := -2;\n   Shared_Stream_Label  : constant Stream_Label := -1;\n\n   function Trimmed_Image is new SAL.Gen_Trimmed_Image (Stream_Label);\n\n   type Stream_Element is record\n      --  We use separate stream pointers, rather than reusing the nonterm\n      --  child pointers as in [1], to allow each parallel parser to have\n      --  its own stream. This also preserves Child_Index when children are\n      --  deleted during editing.\n      Node : Node_Access  := Invalid_Node_Access;\n\n      State : Unknown_State_Index := Unknown_State;\n      --  Parse state that is on the parse stack with this token.\n      --  Unknown_State in Shared_Stream or a parse stream input.\n   end record;\n\n   package Stream_Element_Lists is new SAL.Gen_Definite_Doubly_Linked_Lists (Stream_Element);\n   use all type Stream_Element_Lists.Cursor;\n\n   type Stream_Index is record\n      Cur : Stream_Element_Lists.Cursor;\n   end record;\n\n   Invalid_Stream_Index : constant Stream_Index := (Cur => Stream_Element_Lists.No_Element);\n\n   type Parse_Stream is record\n      Label : Stream_Label := Invalid_Stream_Label;\n\n      Stack_Top : Stream_Element_Lists.Cursor := Stream_Element_Lists.No_Element;\n      --  The top of the parse stack. The stack is Stack_Top and previous\n      --  elements, the input stream is the following elements, or\n      --  Shared_Stream if Stack_Top.Next is Invalid_Stream_Index. In\n      --  batch parsing with no error correction, this is always Last. In\n      --  Shared_Stream, always Invalid_Stream_Index.\n\n      Shared_Link : Stream_Element_Lists.Cursor := Stream_Element_Lists.No_Element;\n      --  A complete parse stream consists of elements in\n      --  Parse_Stream.Elements, followed by elements in\n      --  Shared_Stream.Elements starting at Shared_Link, terminating in an\n      --  EOI element. EOI is never shifted to the parse stream, but it can\n      --  be copied to the parse stream to add an error. Then Shared_Link is\n      --  No_Element.\n\n      Elements : Stream_Element_Lists.List;\n   end record;\n\n   package Parse_Stream_Lists is new SAL.Gen_Definite_Doubly_Linked_lists (Parse_Stream);\n   use all type Parse_Stream_Lists.Cursor;\n\n   type Stream_ID is record\n      Cur : Parse_Stream_Lists.Cursor;\n   end record;\n\n   Invalid_Stream_ID : constant Stream_ID := (Cur => Parse_Stream_Lists.No_Element);\n\n   Invalid_Stream_Node_Ref : constant Stream_Node_Ref :=\n     (Invalid_Stream_ID, Invalid_Stream_Index, Invalid_Node_Access);\n\n   Invalid_Stream_Node_Parents : constant Stream_Node_Parents := (Invalid_Stream_Node_Ref, Parents => <>);\n\n   package Node_Access_Arrays is new SAL.Gen_Unbounded_Definite_Vectors (Valid_Node_Index, Node_Access, null);\n\n   type Tree is new Base_Tree with record\n      Next_Stream_Label : Stream_Label := Shared_Stream_Label + 1;\n\n      Next_Terminal_Node_Index : Node_Index := 1;\n\n      Root : Node_Access := Invalid_Node_Access;\n      SOI  : Node_Access := Invalid_Node_Access;\n      EOI  : Node_Access := Invalid_Node_Access;\n\n      Streams : Parse_Stream_Lists.List;\n\n      Shared_Stream : Stream_ID;\n\n      Nodes : Node_Access_Arrays.Vector;\n      --  Stores ref to all nodes, for Finalize.\n\n      Traversing : Boolean := False;\n      --  True while traversing tree in Process_Tree.\n      --  Declared in Base_Tree so it is cleared by Finalize.\n\n      Parents_Set : Boolean := False;\n      --  We don't set Node.Parent until after parse is done; see Design\n      --  note above.\n   end record;\n\n   procedure Free is new Ada.Unchecked_Deallocation (Node, Node_Access);\n\n   function Byte_Region (Tree : in Syntax_Trees.Tree; Index : in Stream_Index) return WisiToken.Buffer_Region\n   is (Byte_Region (Tree, Stream_Element_Lists.Constant_Ref (Index.Cur).Node));\n\n   function Child_Count (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return SAL.Base_Peek_Type\n   is (Node.Child_Count);\n\n   function Cleared (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Streams.Length = 0 and Tree.Nodes.Length = 0);\n\n   function Contains\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID;\n      Token  : in Stream_Index)\n     return Boolean\n   is ((Tree.Is_Valid (Stream) and Token /= Invalid_Stream_Index) and then\n         (for some Cur in Tree.Streams (Stream.Cur).Elements.Iterate => Cur = Token.Cur));\n\n   function Correct_Stream_Node\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Boolean\n   is (Ref = Invalid_Stream_Node_Ref or else\n         (Ref.Element /= Invalid_Stream_Index and then\n            (Ref.Node = Invalid_Node_Access or else\n               (not Tree.Parents_Set or else\n                  Tree.Subtree_Root (Ref.Node) = Tree.Get_Node (Ref.Stream, Ref.Element)))));\n\n   function Editable (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Parents_Set and Tree.Streams.Length = 0 and Tree.Shared_Stream.Cur = Parse_Stream_Lists.No_Element);\n\n   function First_Parse_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID\n   is (Cur => Parse_Stream_Lists.Next (Tree.Shared_Stream.Cur));\n\n   function Last_Parse_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID\n   is (Cur => Parse_Stream_Lists.Last (Tree.Streams));\n\n   function Fully_Parsed (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Streams.Length = 2 and then Tree.Stream_Length ((Cur => Tree.Streams.Last)) in 2 .. 3);\n   --  1 stream for Shared, one for the successful parser. Parse stream\n   --  has SOI with start state, parsed tree root, possibly copied EOI\n\n   function Get_Node\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Valid_Node_Access\n   is (Stream_Element_Lists.Constant_Ref (Element.Cur).Node);\n\n   function Get_Node\n     (Element : in Stream_Index)\n     return Valid_Node_Access\n   is (Stream_Element_Lists.Constant_Ref (Element.Cur).Node);\n\n   function Get_Node_Index (Node : in Node_Access) return Node_Index\n   is (if Node = Invalid_Node_Access then Invalid_Node_Index else Node.Node_Index);\n\n   function Get_Node_Index (Tree : in Syntax_Trees.Tree; Node : in Node_Access) return Node_Index\n   is (if Node = Invalid_Node_Access then Invalid_Node_Index else Node.Node_Index);\n\n   function Get_Node_Index (Element : in Stream_Index) return Node_Index\n   is (if Stream_Element_Lists.Has_Element (Element.Cur)\n       then Stream_Element_Lists.Constant_Ref (Element.Cur).Node.Node_Index\n       else Invalid_Node_Index);\n\n   function Get_Node_Index\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Node_Index\n   is (Get_Node_Index (Element));\n\n   function Has_Input\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Boolean\n   is (declare Parse_Stream : Syntax_Trees.Parse_Stream renames Tree.Streams (Stream.Cur);\n       begin Parse_Stream.Stack_Top /= Parse_Stream.Elements.Last);\n\n   function ID\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Token_ID\n   is (Stream_Element_Lists.Constant_Ref (Element.Cur).Node.ID);\n\n   function Is_Empty (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Streams.Length = 0 and Tree.Root = Invalid_Node_Access);\n\n   function Is_Terminal (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Boolean\n   is (Tree.Label (Node) in Terminal_Label);\n\n   function Is_Valid (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return Boolean\n   is (Parse_Stream_Lists.Has_Element (Stream.Cur));\n\n   function Label (Node : in Valid_Node_Access) return Node_Label\n   is (Node.Label);\n\n   function Label (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Node_Label\n   is (Node.Label);\n\n   function Label (Tree : in Syntax_Trees.Tree; Element : in Stream_Index) return Node_Label\n   is (Stream_Element_Lists.Constant_Ref (Element.Cur).Node.Label);\n\n   function Lexable (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Streams.Length = 1 and\n         (Tree.Shared_Stream.Cur /= Parse_Stream_Lists.No_Element and then\n            Tree.Streams (Tree.Shared_Stream.Cur).Elements.Length = 1));\n\n   function Next_Stream_ID_Trimmed_Image (Tree : in Syntax_Trees.Tree) return String\n   is (Trimmed_Image (Tree.Next_Stream_Label));\n\n   function Parents_Set (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Parents_Set);\n\n   function Parents_Valid (Ref : in Stream_Node_Parents) return Boolean\n   is ((Ref.Ref.Element = Invalid_Stream_Index and Ref.Ref.Node = Invalid_Node_Access) or else\n         ((Stream_Element_Lists.Constant_Ref (Ref.Ref.Element.Cur).Node = Ref.Ref.Node or\n             Ref.Ref.Node = Invalid_Node_Access) and Ref.Parents.Is_Empty) or else\n         (Ref.Parents.Depth > 0 and then\n            (for all Item of Ref.Parents => Item /= Invalid_Node_Access and then Item.Label = Nonterm) and then\n            (Ref.Parents.Peek (Ref.Parents.Depth) = Stream_Element_Lists.Constant_Ref (Ref.Ref.Element.Cur).Node and\n               --  we don't check the intervening parent items.\n               (for some Child of Ref.Parents.Peek.Children => Child = Ref.Ref.Node))));\n\n   function Parseable (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Streams.Length = 1);\n\n   function Rooted (Ref : in Stream_Node_Ref) return Boolean\n   is (Stream_Element_Lists.Has_Element (Ref.Element.Cur) and then\n         Stream_Element_Lists.Constant_Ref (Ref.Element.Cur).Node = Ref.Node);\n\n   function Stack_Top\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Stream_Index\n   is ((Cur => Tree.Streams (Stream.Cur).Stack_Top));\n\n   function State\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Unknown_State_Index\n   is (Stream_Element_Lists.Constant_Ref (Element.Cur).State);\n\n   function State (Tree : in Syntax_Trees.Tree; Stream : in Stream_ID) return State_Index\n   is (Stream_Element_Lists.Constant_Ref (Tree.Streams (Stream.Cur).Stack_Top).State);\n\n   function Stream_Count (Tree : in Syntax_Trees.Tree) return Natural\n   is (Natural (Tree.Streams.Length));\n\n   function Stream_Last\n     (Tree   : in Syntax_Trees.Tree;\n      Stream : in Stream_ID)\n     return Stream_Index\n   is ((Cur => Tree.Streams (Stream.Cur).Elements.Last));\n\n   function Stream_Prev\n     (Tree    : in Syntax_Trees.Tree;\n      Stream  : in Stream_ID;\n      Element : in Stream_Index)\n     return Stream_Index\n   is ((Cur => Stream_Element_Lists.Previous (Element.Cur)));\n\n   function Shared_Stream (Tree : in Syntax_Trees.Tree) return Stream_ID\n   is (Tree.Shared_Stream);\n\n   function Single_Terminal (Ref : in Stream_Node_Ref) return Boolean\n   is (declare\n          Element : Stream_Element renames Stream_Element_Lists.Constant_Ref (Ref.Element.Cur);\n       begin\n          Element.Node = Ref.Node and Ref.Node.Label in Terminal_Label);\n\n   function Terminal_Ref_Image (Item : in Syntax_Trees.Terminal_Ref; Aux : in Syntax_Trees.Tree'Class) return String\n   is (Aux.Image (Item));\n\n   function To_Real_Recover_Token (Item : in Stream_Node_Ref) return Real_Recover_Token\n   is ((Virtual      => False,\n        Element_Node => Stream_Element_Lists.Constant_Ref (Item.Element.Cur).Node,\n        Node         => Item.Node));\n\n   function Trimmed_Image (Tree : in Syntax_Trees.Tree; Item : in Stream_ID) return String\n   is (Trimmed_Image (Tree.Streams (Item.Cur).Label));\n\n   function Trimmed_Image (Item : in Stream_Index) return String\n   is (if Item = Invalid_Stream_Index\n       then \"-\"\n       else Trimmed_Image (Stream_Element_Lists.Constant_Ref (Item.Cur).Node.Node_Index));\n\n   function Trimmed_Image (Node : in Node_Access) return String\n   is (if Node = Invalid_Node_Access\n       then \"-\"\n       else Trimmed_Image (Node.Node_Index));\n\n   function Valid_Error_Ref (Error : in Error_Ref) return Boolean\n   is (Error.Node = Invalid_Node_Access or else\n         (Error.Node.Error_List /= null or\n            (Error.Node.Label = Source_Terminal and then\n               (for some Cur in Error.Node.Following_Deleted.Iterate => Cur = Error.Deleted))));\n\n   function Valid_Error_Ref (Error : in Stream_Error_Ref) return Boolean\n   is (Error.Ref.Ref.Node = Invalid_Node_Access or else\n         (Error.Ref.Ref.Node.Error_List /= null or\n            (Error.Ref.Ref.Node.Label = Source_Terminal and then\n               (for some Cur in Error.Ref.Ref.Node.Following_Deleted.Iterate => Cur = Error.Deleted))));\n\n   function Valid_Root (Tree : in Syntax_Trees.Tree) return Boolean\n   is (Tree.Root /= Invalid_Node_Access or Tree.Stream_Count > 0);\n\n   function Valid_Stream_Node\n     (Tree : in Syntax_Trees.Tree;\n      Ref  : in Stream_Node_Ref)\n     return Boolean\n   is (Tree.Contains (Ref.Stream, Ref.Element) and then\n         (if Ref.Node = Invalid_Node_Access\n          then Ref /= Invalid_Stream_Node_Ref\n          else\n            (not Tree.Parents_Set or else\n               Tree.Subtree_Root (Ref.Node) = Tree.Get_Node (Ref.Stream, Ref.Element))));\n\n   Dummy_Node : constant Node_Access := new Node'(Label => Virtual_Identifier, Child_Count => 0, others => <>);\n\n   type Token_Array_Var_Ref (Element : not null access WisiToken.Lexer.Token_Arrays.Vector) is record\n      Dummy : Integer := raise Program_Error with \"uninitialized reference\";\n   end record;\n\n   type Token_Array_Const_Ref (Element : not null access constant WisiToken.Lexer.Token_Arrays.Vector) is record\n      Dummy : Integer := raise Program_Error with \"uninitialized reference\";\n   end record;\n\n   type Valid_Node_Access_List_Var_Ref (List : not null access Valid_Node_Access_Lists.List) is record\n      Dummy : Integer := raise Program_Error with \"uninitialized reference\";\n   end record;\n\n   function Node_Image\n     (Node : in Node_Access;\n      Tree : in Syntax_Trees.Tree'Class)\n     return String\n   is (Tree.Image (Node, Node_Numbers => True));\n\n   function Node_List_Image is new Valid_Node_Access_Lists.Gen_Image_Aux (Tree'Class, Node_Image);\n\n   function Image\n     (Tree : in Syntax_Trees.Tree;\n      List : in Valid_Node_Access_Lists.List)\n     return String\n   is (Node_List_Image (List, Tree));\n\n   ----------\n   --  Errors\n\n   type Error_Data_List_Ref (List : not null access constant Error_Data_Lists.List) is record\n      Dummy : Integer := raise Program_Error;\n   end record;\n\n   function Has_Error (Node : in Valid_Node_Access) return Boolean\n   is (Node.Error_List /= null);\n\n   Empty_Error_List : aliased constant Error_Data_Lists.List := Error_Data_Lists.Empty_List;\n   --  WORKAROUND: with GNAT Community 2021, adding 'aliased' in\n   --  sal-gen_indefinite_doubly_linked_lists.ads doesn't work.\n\n   function Error_List (Tree : in Syntax_Trees.Tree; Node : in Valid_Node_Access) return Error_Data_List_Ref\n   is (Error_Data_List_Ref'\n         (List  => (if Node.Error_List = null then Empty_Error_List'Access else Node.Error_List),\n          Dummy => 1));\n\n   type Error_Data_List_Cursor is record\n      Cur : Error_Data_Lists.Cursor;\n   end record;\n\n   type Error_Constant_Reference_Type (Element : not null access constant Error_Data'Class) is record\n      Dummy : Integer := raise Program_Error with \"uninitialized reference\";\n   end record;\n\n   type Error_Iterator (Tree : not null access constant Syntax_Trees.Tree)\n     is new Error_Iterator_Interfaces.Forward_Iterator with\n     null record;\n\n   overriding function First (Object : Error_Iterator) return Error_Ref;\n\n   overriding function Next\n     (Object   : Error_Iterator;\n      Position : Error_Ref)\n     return Error_Ref;\n\n   type Stream_Error_Cursor is record\n      SER : Stream_Error_Ref;\n   end record;\n\n   Invalid_Stream_Error_Ref : constant Stream_Error_Ref :=\n     (Invalid_Stream_Node_Parents, Valid_Node_Access_Lists.No_Element, Error_Data_Lists.No_Element);\n\n   function Error (Item : in Stream_Error_Cursor) return Stream_Error_Ref\n   is (Item.SER);\n\n   type Stream_Error_Iterator (Tree : not null access constant Syntax_Trees.Tree)\n   is new Stream_Error_Iterator_Interfaces.Forward_Iterator with record\n      Stream : Parse_Stream_Lists.Cursor;\n   end record;\n\n   overriding function First (Object : Stream_Error_Iterator) return Stream_Error_Cursor;\n\n   overriding function Next\n     (Object   : Stream_Error_Iterator;\n      Position : Stream_Error_Cursor)\n     return Stream_Error_Cursor;\n\nend WisiToken.Syntax_Trees;\n"
               }
            }
         },
         "wait": []
      }
   },
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "id": "3",
            "method": "textDocument/definition",
            "params": {
               "textDocument": {"uri": "file:///Projects/org.wisitoken/wisitoken-syntax_trees.ads"},
               "position": {"line": 1273, "character": 12}}
         },
         "wait": [
            {
               "id": "3",
               "result": [
                  {
                     "uri": "file:///Projects/org.wisitoken/wisitoken-syntax_trees.adb",
                     "range": {
                        "start": {"line": 4721, "character": 12},
                         "end": {"line": 4721, "character": 23}
                     }}]}]}},
   {
      "send": {
         "request": {
            "jsonrpc": "2.0",
            "id": "ada-10",
            "method": "shutdown"
         },
         "wait": [
            {
               "id": "ada-10",
               "result": null
            }
         ]
      }
   },
   {
      "stop": {
         "exit_code": 0
      }
   }
]
