--  Abstract :
--
--  See spec.
--
--  Copyright (C) 2018 Stephen Leake.  All Rights Reserved.
--
--  This program is free software; you can redistribute it and/or
--  modify it under terms of the GNU General Public License as
--  published by the Free Software Foundation; either version 3, or (at
--  your option) any later version. This program is distributed in the
--  hope that it will be useful, but WITHOUT ANY WARRANTY; without even
--  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
--  PURPOSE. See the GNU General Public License for more details. You
--  should have received a copy of the GNU General Public License
--  distributed with this program; see file COPYING. If not, write to
--  the Free Software Foundation, 59 Temple Place - Suite 330, Boston,
--  MA 02111-1307, USA.

pragma License (GPL);

with AUnit.Assertions;
with AUnit.Checks;
with Ada.Characters.Latin_1;
with Ada.Characters;
with Ada.Exceptions;
with Ada.Text_IO;
with GNAT.Traceback.Symbolic;
with WisiToken.Gen_Token_Enum;
with WisiToken.Lexer.Regexp;
with WisiToken.Packrat;
with WisiToken.Parse;
with WisiToken.Syntax_Trees;
with WisiToken.Text_IO_Trace;
package body Dragon_4_43_Packrat_Hand is

   --  grammar in eqn (4.21) example 4.42 pg 231

   type Token_Enum_ID is
     (
      --  terminals
      Lower_C_ID,
      Lower_D_ID,
      EOF_ID,

      --  non-terminals
      Accept_ID,
      Upper_S_ID,
      Upper_C_ID);

   package Token_Enum is new WisiToken.Gen_Token_Enum
     (Token_Enum_ID     => Token_Enum_ID,
      First_Terminal    => Lower_C_ID,
      Last_Terminal     => EOF_ID,
      First_Nonterminal => Accept_ID,
      Last_Nonterminal  => Upper_C_ID,
      EOF_ID            => EOF_ID,
      Accept_ID         => Accept_ID,
      Case_Insensitive  => False);
   use Token_Enum;

   Null_Action : WisiToken.Syntax_Trees.Semantic_Action renames WisiToken.Syntax_Trees.Null_Action;

   --  Grammar : constant WisiToken.Productions.Arrays.Vector :=
   --    Accept_ID <= Upper_S_ID & EOF_ID + Null_Action -- 1
   --    and
   --    Upper_S_ID <= Upper_C_ID & Upper_C_ID + Null_Action -- 2
   --    and
   --    Upper_C_ID <= Lower_C_ID & Upper_C_ID + Null_Action -- 3
   --    and
   --    Upper_C_ID <= Lower_D_ID + Null_Action -- 4
   --    ;

   Syntax : constant WisiToken.Lexer.Regexp.Syntax := To_Syntax
     ((
       Lower_C_ID => WisiToken.Lexer.Regexp.Get ("c"),
       Lower_D_ID => WisiToken.Lexer.Regexp.Get ("d"),
       EOF_ID     => WisiToken.Lexer.Regexp.Get ("" & Ada.Characters.Latin_1.EOT)
      ));

   Trace : aliased WisiToken.Text_IO_Trace.Trace (LR1_Descriptor'Access);

   Lexer : constant WisiToken.Lexer.Handle := WisiToken.Lexer.Regexp.New_Lexer (Trace'Access, Syntax);

   use WisiToken;
   use WisiToken.Packrat;

   type Derivs_Type is array (Nonterminal_Enum_ID) of Memos.Vector;

   type Parser_Type is record
      Trace            : access WisiToken.Trace'Class := Dragon_4_43_Packrat_Hand.Trace'Access;
      Lexer            : WisiToken.Lexer.Handle;
      User_Data        : Syntax_Trees.User_Data_Access := null;
      Derivs           : Derivs_Type;
      Terminals        : Base_Token_Arrays.Vector;
      Line_Begin_Token : Line_Begin_Token_Vectors.Vector;
      Base_Tree        : aliased Syntax_Trees.Base_Tree; --  FIXME: only need Base_Tree, unless for error handling?
      Tree             : Syntax_Trees.Tree;
   end record;

   --  The code style here is the same as that generated by
   --  wisi-generate_packrat_parser.adb; this is the prototype for that.
   --
   --  We use gotos and function scope vars rather than nested if/declare
   --  to avoid excessive indenting for long productions.

   function Parse_Upper_S (Parser : in out Parser_Type; Start_Pos : in Token_Index) return Result_Type;
   function Parse_Upper_C (Parser : in out Parser_Type; Start_Pos : in Token_Index) return Result_Type;

   function Parse_Accept (Parser : in out Parser_Type; Start_Pos : in Token_Index) return Result_Type
   is
      Pos      : Token_Index := Start_Pos; -- next token to examine
      Memo_0_1 : Memo_Entry;
      Pos_0_2  : Token_Index;
   begin
      case Parser.Derivs (Accept_ID)(Start_Pos).State is
      when Success =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Accept: memo " & Parser.Tree.Image
                 (Parser.Derivs (Accept_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Upper_S_ID)(Start_Pos);

      when Failure =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line ("Accept: memo fail");
         end if;
         return Parser.Derivs (Upper_S_ID)(Start_Pos);

      when No_Result =>
         null;
      end case;

      --  Accept_ID <= Upper_S_ID EOF_ID
      Memo_0_1 := Parse_Upper_S (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token + 1;
      when Failure =>
         goto RHS_0_Fail;
      end case;

      if Parser.Terminals (Pos).ID = +EOF_ID then
         Pos_0_2 := Pos;
         Pos := Pos + 1;

         Parser.Derivs (Accept_ID).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (+Accept_ID, 0),
                Action          => Null_Action,
                Children        => (1 => Memo_0_1.Result,
               2 => Tree_Index (Pos_0_2)),
                Default_Virtual => False),
             Last_Token         => Pos - 1));

         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Accept_0: " & Parser.Tree.Image
                 (Parser.Derivs (Accept_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Accept_ID)(Start_Pos);
      else
         goto RHS_0_Fail;
      end if;

      <<RHS_0_Fail>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line ("Accept: fail ");
      end if;
      Parser.Derivs (Accept_ID).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (Accept_ID)(Start_Pos);
   end Parse_Accept;

   function Parse_Upper_S (Parser : in out Parser_Type; Start_Pos : in Token_Index) return Result_Type
   is
      Pos      : Token_Index := Start_Pos; -- next token to examine
      Memo_0_1 : Memo_Entry;
      Memo_0_2 : Memo_Entry;
   begin
      case Parser.Derivs (Upper_S_ID)(Start_Pos).State is
      when Success =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Upper_S: memo " & Parser.Tree.Image
                 (Parser.Derivs (Upper_S_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Upper_S_ID)(Start_Pos);
      when Failure =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line ("Upper_S: memo fail");
         end if;
         return Parser.Derivs (Upper_S_ID)(Start_Pos);
      when No_Result =>
         null;
      end case;

      --  Upper_S_ID <= Upper_C_ID & Upper_C_ID + Null_Action -- 2
      --  <<RHS_0_Token_1>>
      Memo_0_1 := Parse_Upper_C (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token + 1;
      when Failure =>
         goto Fail;
      end case;

      Memo_0_2 := Parse_Upper_C (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token + 1;
      when Failure =>
         goto Fail;
      end case;

      Parser.Derivs (Upper_S_ID).Replace_Element
        (Start_Pos,
         (State              => Success,
          Result             => Parser.Tree.Add_Nonterm
            (Production      => (+Upper_S_ID, 0),
             Action          => Null_Action,
             Children        => (Memo_0_1.Result, Memo_0_2.Result),
             Default_Virtual => False),
          Last_Token         => Pos - 1));

         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Upper_S_0: " & Parser.Tree.Image
                 (Parser.Derivs (Upper_S_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
      return Parser.Derivs (Upper_S_ID).Constant_Ref (Start_Pos);

      <<Fail>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line ("Upper_S: fail");
      end if;
      Parser.Derivs (Upper_S_ID).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (Upper_S_ID).Constant_Ref (Start_Pos);

   end Parse_Upper_S;

   function Parse_Upper_C (Parser : in out Parser_Type; Start_Pos : in Token_Index) return Result_Type
   is
      Pos      : Token_Index := Start_Pos;
      Pos_0_1  : Token_Index;
      Memo_0_2 : Memo_Entry;
      Pos_1_1  : Token_Index;
   begin
      case Parser.Derivs (Upper_C_ID)(Start_Pos).State is
      when Success =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Upper_C: memo " & Parser.Tree.Image
                 (Parser.Derivs (Upper_C_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Upper_C_ID)(Start_Pos);
      when Failure =>
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line ("Upper_C: memo fail");
         end if;
         return Parser.Derivs (Upper_C_ID)(Start_Pos);
      when No_Result =>
         null;
      end case;

      --  Upper_C_ID <= Lower_C_ID & Upper_C_ID
      --  RHS_0_Token_1
      if Parser.Terminals (Pos).ID = +Lower_C_ID then
         Pos_0_1 := Pos;
         Pos     := Pos + 1;
      else
         goto RHS_0_Fail;
      end if;

      --  RHS_0_Token_2
      Memo_0_2 := Parse_Upper_C (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token + 1;

         Parser.Derivs (Upper_C_ID).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (+Upper_C_ID, 0),
                Action          => Null_Action,
                Children        => (Tree_Index (Pos_0_1), Memo_0_2.Result),
                Default_Virtual => False),
             Last_Token         => Pos - 1));

         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Upper_C_0: " & Parser.Tree.Image
                 (Parser.Derivs (Upper_C_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Upper_C_ID)(Start_Pos);

      when Failure =>
         goto RHS_0_Fail;
      end case;

      <<RHS_0_Fail>>
      --  Upper_C_ID <= Lower_D_ID
      Pos := Start_Pos;
      if Parser.Terminals (Start_Pos).ID = +Lower_D_ID then
         Pos_1_1 := Pos;
         Pos := Pos + 1;

         Parser.Derivs (Upper_C_ID).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (+Upper_C_ID, 1),
                Action          => Null_Action,
                Children        => (1 => Tree_Index (Pos_1_1)),
                Default_Virtual => False),
          Last_Token         => Pos - 1));

         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line
              ("Upper_C_1: " & Parser.Tree.Image
                 (Parser.Derivs (Upper_C_ID)(Start_Pos).Result, Parser.Trace.Descriptor.all, Include_Children => True));
         end if;
         return Parser.Derivs (Upper_C_ID)(Start_Pos);

      else
         goto RHS_1_Fail;
      end if;

      <<RHS_1_Fail>>

      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line ("Upper_C: fail");
      end if;
      Parser.Derivs (Upper_C_ID).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (Upper_C_ID)(Start_Pos);

   end Parse_Upper_C;

   Parser : Parser_Type;

   procedure Check is new AUnit.Checks.Gen_Check_Discrete (Memo_State);

   ----------
   --  Test procedures

   procedure Test_Parse (T : in out AUnit.Test_Cases.Test_Case'Class)
   is
      pragma Unreferenced (T);

      procedure Execute_Parse
        (Input    : in String;
         Expected : in Result_States)
      is
         Junk : Syntax_Trees.Valid_Node_Index;
         pragma Unreferenced (Junk);
      begin
         if WisiToken.Trace_Parse > Detail then
            Parser.Trace.Put_Line ("input: '" & Input & "'");
         end if;
         Lexer.Reset_With_String (Input);
         Parser.Base_Tree.Clear;
         Parser.Tree.Initialize (Parser.Base_Tree'Access, Flush => True);
         Parse.Lex_All (Lexer, Parser.Terminals, Parser.Line_Begin_Token, Parser.User_Data, Trace'Access);

         if WisiToken.Trace_Parse > Detail then
            Trace.Put_Line (WisiToken.Image (Parser.Terminals, Parser.Trace.Descriptor.all));
         end if;

         for Nonterm in Nonterminal_Enum_ID loop
            Parser.Derivs (Nonterm).Clear;
            Parser.Derivs (Nonterm).Set_First (Parser.Terminals.First_Index);
            Parser.Derivs (Nonterm).Set_Last (Parser.Terminals.Last_Index);
         end loop;

         for Token_Index in Parser.Terminals.First_Index .. Parser.Terminals.Last_Index loop
            Junk := Parser.Tree.Add_Terminal (Token_Index, Parser.Terminals);
            --  FIXME: move this into Lex_All, delete Terminals, just use Syntax_Tree
         end loop;

         declare
            Result : constant Result_Type := Parse_Accept (Parser, Parser.Terminals.First_Index);
         begin
            Check (Input, Result.State, Expected);
            --  FIXME: check syntax_tree
         end;
      exception
      when AUnit.Assertions.Assertion_Error =>
         raise;
      when E : others =>
         Ada.Text_IO.Put_Line
           ("'" & Input & "': exception " & Ada.Exceptions.Exception_Name (E) & " : " &
              Ada.Exceptions.Exception_Message (E));
         Ada.Text_IO.Put (GNAT.Traceback.Symbolic.Symbolic_Traceback (E));
         AUnit.Assertions.Assert (False, "'" & Input & "': " & Ada.Exceptions.Exception_Name (E));
      end Execute_Parse;

   begin
      Execute_Parse ("cdcd", Success);
      Execute_Parse ("ccd", Failure);
      Execute_Parse ("ccdccd", Success);
      Execute_Parse ("d", Failure);
   end Test_Parse;

   ----------
   --  Public subprograms

   overriding function Name (T : Test_Case) return AUnit.Message_String
   is
      pragma Unreferenced (T);
   begin
      return new String'("dragon_4_43_packrat_hand.adb");
   end Name;

   overriding procedure Register_Tests (T : in out Test_Case)
   is
      use AUnit.Test_Cases.Registration;
   begin
      Register_Routine (T, Test_Parse'Access, "Test_Parse");
   end Register_Tests;

end Dragon_4_43_Packrat_Hand;
