$nonterminal_005_opt
  : expression
  | ;; empty
  ;
$nonterminal_004
  : IDENTIFIER EQUAL_GREATER $nonterminal_005_opt
  ;
$nonterminal_003_opt
  : $nonterminal_004
  | expression
  | ;; empty
  ;
$nonterminal_002_opt
  : expression
  | ;; empty
  ;
$nonterminal_001_opt
  : WITH association_list
  | ;; empty
  ;
%code copyright_license %{
;;  Copyright (C) 2017, 2018, 2019 Free Software Foundation, Inc.
;;
;;  Author: Stephen Leake <stephe-leake@stephe-leake.org>
;;
;;  This file is part of WisiToken.
;;
;;  WisiToken is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  WisiToken is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with WisiToken.  If not, see <http://www.gnu.org/licenses/>.
}%
%code actions spec context %{with WisiToken.Text_IO_Trace;}%
%code actions spec post %{
Trace : aliased WisiToken.Text_IO_Trace.Trace (Descriptor'Access);

End_Name_Optional : Boolean := True;

Action_Count : array (Descriptor.First_Nonterminal .. Descriptor.Last_Nonterminal) of Integer := (others => 0);
}%

%generate LALR Ada re2c
%meta_syntax EBNF
%keyword AND "and"
%keyword BEGIN "begin"
%keyword BODY "body"
%keyword CASE "case"
%keyword DECLARE "declare"
%keyword ELSE "else"
%keyword ELSIF "elsif"
%keyword END "end"
%keyword EXIT "exit"
%keyword EXCEPTION "exception"
%keyword FOR "for"
%keyword FUNCTION "function"
%keyword IF "if"
%keyword IN "in"
%keyword IS "is"
%keyword LEFT_PAREN "("
%keyword LOOP "loop"
%keyword NEW "new"
%keyword NOT "not"
%keyword OR "or"
%keyword PACKAGE "package"
%keyword PROCEDURE "procedure"
%keyword RANGE "range"
%keyword RETURN "return"
%keyword RIGHT_PAREN ")"
%keyword SEPARATE "separate"
%keyword THEN "then"
%keyword TYPE "type"
%keyword WHEN "when"
%keyword WITH "with"
%keyword XOR "xor"

%token <punctuation> AMPERSAND "&"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUAL ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> DOT_DOT ".."
%token <punctuation> EQUAL "="
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> GREATER ">"
%token <punctuation> GREATER_EQUAL ">="
%token <punctuation> LESS "<"
%token <punctuation> LESS_EQUAL "<="
%token <punctuation> MINUS "-"
%token <punctuation> PLUS "+"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> SLASH_EQUAL "/="
%token <punctuation> STAR "*"
%token <string-double> STRING_LITERAL  %[ (["][\x20-\x21\x23-\U0010FFFF]*["])+ ]%
%token <number> NUMERIC_LITERAL  %[ [0-9]+ ]%
%token <symbol> IDENTIFIER  %[ [a-zA-Z][0-9a-zA-Z_]* ]%

%non_grammar <non-reporting> WHITESPACE  %[ [ \t] ]%
%non_grammar <new-line> NEW_LINE  %[ [\n] ]%
%non_grammar <comment> COMMENT  %[ "--"[^\n]*[\n] ]%
%start compilation_unit_list

%conflict REDUCE / REDUCE in state actual_parameter_part , actual_parameter_part on token RIGHT_PAREN
%conflict REDUCE / REDUCE in state discrete_subtype_definition , range_list on token RIGHT_PAREN
%conflict REDUCE / REDUCE in state primary , subtype_indication on token RIGHT_PAREN
%conflict SHIFT / REDUCE in state generic_instantiation , generic_instantiation on token IS
%conflict SHIFT / REDUCE in state simple_return_statement , simple_return_statement on token SEMICOLON
%conflict SHIFT / REDUCE in state subprogram_body , subprogram_body on token IS

actual_parameter_part
  : LEFT_PAREN association_list RIGHT_PAREN
  ;
aspect_specification
  : $nonterminal_001_opt
  ;
assignment_statement
  : name COLON_EQUAL $nonterminal_002_opt SEMICOLON
  ;
association
  : $nonterminal_003_opt
  ;
association_list
  : association
 ;; not translated: (rhs_multiple_item, (4134 . 4152))

  ;
binary_adding_operator
  : PLUS
  | MINUS
  | AMPERSAND
  ;
block_label_opt
  : IDENTIFIER COLON    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%
  | ;; empty
  ;
block_statement
  : block_label_opt DECLARE declarative_part BEGIN handled_sequence_of_statements END
 ;; not translated: (rhs_optional_item, (4679 . 4690))
 SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 7, End_Name_Optional);)%
  | block_label_opt BEGIN handled_sequence_of_statements END
 ;; not translated: (rhs_optional_item, (4854 . 4865))
 SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 5, End_Name_Optional);)%
  ;
body_g
  : proper_body
  | body_stub
  ;
body_stub
  : subprogram_body_stub
  ;
case_statement
  : CASE
 ;; not translated: (rhs_optional_item, (5078 . 5089))
 IS case_statement_alternative_list END CASE SEMICOLON
  ;
case_statement_alternative
  : WHEN NUMERIC_LITERAL EQUAL_GREATER sequence_of_statements
  ;
case_statement_alternative_list
  :
 ;; not translated: (rhs_multiple_item, (5388 . 5415))

  ;
compilation_unit
  : library_item
  ;
compilation_unit_list
  :
 ;; not translated: (rhs_multiple_item, (5487 . 5504))

  ;
compound_statement
  : if_statement
  | case_statement
  | loop_statement
  | block_statement
  | extended_return_statement
  ;
constraint
  : RANGE range_g
  | index_constraint
  ;
declaration
  : body_g
  | object_declaration
  | subprogram_declaration
  | type_declaration
  ;
declarative_part
  :
 ;; not translated: (rhs_multiple_item, (5815 . 5827))

  ;
discrete_subtype_definition
  : subtype_indication
  | range_g
  ;
enumeration_type_definition
  : LEFT_PAREN IDENTIFIER
 ;; not translated: (rhs_multiple_item, (5950 . 5967))
 RIGHT_PAREN
  ;
exception_choice
  : name
  ;
exception_handler
  : WHEN exception_choice EQUAL_GREATER sequence_of_statements
  ;
exit_statement
  : EXIT
 ;; not translated: (rhs_optional_item, (6123 . 6134))

 ;; not translated: (rhs_optional_item, (6136 . 6154))
 SEMICOLON
  ;
expression
  : relation
 ;; not translated: (rhs_multiple_item, (6195 . 6208))

  | relation
 ;; not translated: (rhs_multiple_item, (6223 . 6235))

  | relation
 ;; not translated: (rhs_multiple_item, (6250 . 6263))

  ;
extended_return_object_declaration
  : IDENTIFIER COLON subtype_indication
  ;
extended_return_statement
  : RETURN extended_return_object_declaration SEMICOLON
  ;
factor
  : primary
  | NOT primary
  ;
formal_part
  : LEFT_PAREN
 ;; not translated: (rhs_optional_item, (6749 . 6773))

 ;; not translated: (rhs_multiple_item, (6775 . 6809))
 RIGHT_PAREN
  ;
full_type_declaration
  : TYPE IDENTIFIER IS type_definition SEMICOLON
  ;
function_specification
  : FUNCTION name parameter_and_result_profile    %()%
    %(return Propagate_Name (Nonterm, Tokens, 2);)%
  ;
generic_instantiation
  : PACKAGE name IS NEW name SEMICOLON
  | PROCEDURE name IS NEW name SEMICOLON
  ;
handled_sequence_of_statements
  : sequence_of_statements
 ;; not translated: (rhs_optional_item, (7205 . 7235))

  ;
if_statement
  : IF
 ;; not translated: (rhs_optional_item, (7262 . 7273))
 THEN sequence_of_statements
 ;; not translated: (rhs_multiple_item, (7303 . 7350))

 ;; not translated: (rhs_optional_item, (7352 . 7380))
 END IF SEMICOLON
  ;
index_constraint
  : LEFT_PAREN discrete_subtype_definition RIGHT_PAREN
  ;
iteration_scheme
  : FOR IDENTIFIER IN discrete_subtype_definition
  ;
library_item
  : package_body
  | subprogram_declaration
  | subprogram_body
  | generic_instantiation
  ;
loop_statement
  : iteration_scheme LOOP sequence_of_statements END LOOP
 ;; not translated: (rhs_optional_item, (7734 . 7745))
 SEMICOLON
  | LOOP sequence_of_statements END LOOP
 ;; not translated: (rhs_optional_item, (7798 . 7809))
 SEMICOLON
  ;
multiplying_operator
  : STAR
  | SLASH
  ;
name
  : name LEFT_PAREN range_list RIGHT_PAREN
  | name actual_parameter_part
  | IDENTIFIER    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%
  | selected_component    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%
  ;
object_declaration
  : IDENTIFIER COLON subtype_indication
 ;; not translated: (rhs_optional_item, (8225 . 8250))
 SEMICOLON
  ;
package_body
  : PACKAGE BODY name aspect_specification_opt IS declarative_part
 ;; not translated: (rhs_optional_item, (8347 . 8384))
 END
 ;; not translated: (rhs_optional_item, (8390 . 8395))
 SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 3, 10, End_Name_Optional);)%
  ;
parameter_and_result_profile
  : formal_part RETURN IDENTIFIER
  | RETURN IDENTIFIER
  ;
parameter_specification
  : IDENTIFIER COLON IDENTIFIER
 ;; not translated: (rhs_optional_item, (8906 . 8931))

  ;
paren_expression
  : LEFT_PAREN
 ;; not translated: (rhs_optional_item, (8970 . 8981))
 RIGHT_PAREN
  ;
primary
  : NUMERIC_LITERAL
  | STRING_LITERAL
  | name
  | paren_expression
  ;
procedure_call_statement
  : name SEMICOLON
  ;
procedure_specification
  : PROCEDURE name
 ;; not translated: (rhs_optional_item, (9174 . 9192))
    %()%
    %(return Propagate_Name (Nonterm, Tokens, 2);)%
  ;
proper_body
  : package_body
  | subprogram_body
  ;
range_g
  : simple_expression DOT_DOT simple_expression
  ;
range_list
  : range_list COMMA range_g
  | range_g
  ;
relation
  : simple_expression
 ;; not translated: (rhs_optional_item, (9463 . 9501))

  ;
relational_operator
  : EQUAL
  | SLASH_EQUAL
  | LESS
  | LESS_EQUAL
  | GREATER
  | GREATER_EQUAL
  ;
selected_component
  : name DOT IDENTIFIER    %()%
    %(return Merge_Names (Nonterm, Tokens, 1, 3);)%
  ;
sequence_of_statements
  :
 ;; not translated: (rhs_multiple_item, (9794 . 9804))

  ;
simple_expression
  :
 ;; not translated: (rhs_optional_item, (9833 . 9855))

 ;; not translated: (rhs_multiple_item, (9857 . 9885))

  ;
simple_return_statement
  : RETURN
 ;; not translated: (rhs_optional_item, (9927 . 9938))
 SEMICOLON
  ;
simple_statement
  : assignment_statement
  | exit_statement
  | procedure_call_statement
  | simple_return_statement
  ;
statement
  : simple_statement
  | compound_statement
  ;
subprogram_body
  : subprogram_specification aspect_specification_opt IS declarative_part BEGIN handled_sequence_of_statements END
 ;; not translated: (rhs_optional_item, (10272 . 10277))
 SEMICOLON    %(Action_Count (+subprogram_body_ID) := Action_Count (+subprogram_body_ID) + 1;)%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 8, End_Name_Optional);)%
  ;
subprogram_body_stub
  : subprogram_specification IS SEPARATE SEMICOLON
  ;
subprogram_declaration
  : subprogram_specification SEMICOLON
  ;
subprogram_specification
  : procedure_specification    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%
  | function_specification    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%
  ;
subtype_indication
  : name constraint
  | name
  ;
term
  : factor
 ;; not translated: (rhs_multiple_item, (10881 . 10909))

  ;
type_declaration
  : full_type_declaration
  ;
type_definition
  : enumeration_type_definition
  ;
unary_adding_operator
  : PLUS
  | MINUS
  ;
