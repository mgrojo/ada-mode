nonterminal_058_list
  : nonterminal_059
  | nonterminal_058_list nonterminal_059
  ;

nonterminal_059
  : multiplying_operator factor
  ;

nonterminal_057_opt
  : name
  | ;; empty
  ;

nonterminal_056_opt
  : aspect_specification
  | ;; empty
  ;

nonterminal_055_opt
  : expression
  | ;; empty
  ;

nonterminal_053_list
  : nonterminal_054
  | nonterminal_053_list nonterminal_054
  ;

nonterminal_054
  : binary_adding_operator term
  ;

nonterminal_052_opt
  : unary_adding_operator
  | ;; empty
  ;

nonterminal_050_list
  : nonterminal_051
  | nonterminal_050_list nonterminal_051
  ;

nonterminal_051
  : statement
  ;

nonterminal_049_opt
  : relational_operator simple_expression
  | ;; empty
  ;

nonterminal_048_opt
  : formal_part
  | ;; empty
  ;

nonterminal_047_opt
  : expression
  | ;; empty
  ;

nonterminal_046_opt
  : COLON_EQUAL nonterminal_045_opt
  | ;; empty
  ;

nonterminal_045_opt
  : expression
  | ;; empty
  ;

nonterminal_044_opt
  : name
  | ;; empty
  ;

nonterminal_043_opt
  : BEGIN handled_sequence_of_statements
  | ;; empty
  ;

nonterminal_042_opt
  : aspect_specification
  | ;; empty
  ;

nonterminal_041_opt
  : COLON_EQUAL nonterminal_040_opt
  | ;; empty
  ;

nonterminal_040_opt
  : expression
  | ;; empty
  ;

nonterminal_039_opt
  : IDENTIFIER
  | ;; empty
  ;

nonterminal_038_opt
  : IDENTIFIER
  | ;; empty
  ;

nonterminal_037_opt
  : ELSE sequence_of_statements
  | ;; empty
  ;

nonterminal_035_list
  : nonterminal_036
  | nonterminal_035_list nonterminal_036
  ;

nonterminal_036
  : ELSIF nonterminal_034_opt THEN sequence_of_statements
  ;

nonterminal_034_opt
  : expression
  | ;; empty
  ;

nonterminal_033_opt
  : expression
  | ;; empty
  ;

nonterminal_032_opt
  : EXCEPTION nonterminal_030_list
  | ;; empty
  ;

nonterminal_030_list
  : nonterminal_031
  | nonterminal_030_list nonterminal_031
  ;

nonterminal_031
  : exception_handler
  ;

nonterminal_028_list
  : nonterminal_029
  | nonterminal_028_list nonterminal_029
  ;

nonterminal_029
  : SEMICOLON parameter_specification
  ;

nonterminal_027_opt
  : parameter_specification
  | ;; empty
  ;

nonterminal_025_list
  : nonterminal_026
  | nonterminal_025_list nonterminal_026
  ;

nonterminal_026
  : XOR relation
  ;

nonterminal_023_list
  : nonterminal_024
  | nonterminal_023_list nonterminal_024
  ;

nonterminal_024
  : OR relation
  ;

nonterminal_021_list
  : nonterminal_022
  | nonterminal_021_list nonterminal_022
  ;

nonterminal_022
  : AND relation
  ;

nonterminal_020_opt
  : WHEN nonterminal_019_opt
  | ;; empty
  ;

nonterminal_019_opt
  : expression
  | ;; empty
  ;

nonterminal_018_opt
  : IDENTIFIER
  | ;; empty
  ;

nonterminal_016_list
  : nonterminal_017
  | nonterminal_016_list nonterminal_017
  ;

nonterminal_017
  : COMMA IDENTIFIER
  ;

nonterminal_014_list
  : nonterminal_015
  | nonterminal_014_list nonterminal_015
  ;

nonterminal_015
  : declaration
  ;

nonterminal_012_list
  : nonterminal_013
  | nonterminal_012_list nonterminal_013
  ;

nonterminal_013
  : compilation_unit
  ;

nonterminal_010_list
  : nonterminal_011
  | nonterminal_010_list nonterminal_011
  ;

nonterminal_011
  : case_statement_alternative
  ;

nonterminal_009_opt
  : expression
  | ;; empty
  ;

nonterminal_008_opt
  : IDENTIFIER
  | ;; empty
  ;

nonterminal_007_opt
  : IDENTIFIER
  | ;; empty
  ;

nonterminal_005_list
  : nonterminal_006
  | nonterminal_005_list nonterminal_006
  ;

nonterminal_006
  : COMMA association
  ;

nonterminal_004_opt
  : nonterminal_003
  | expression
  | ;; empty
  ;

nonterminal_003
  : IDENTIFIER EQUAL_GREATER nonterminal_002_opt
  ;

nonterminal_002_opt
  : expression
  | ;; empty
  ;

nonterminal_001_opt
  : expression
  | ;; empty
  ;

%code copyright_license %{
;;  Copyright (C) 2017, 2018, 2019 Free Software Foundation, Inc.
;;
;;  Author: Stephen Leake <stephe-leake@stephe-leake.org>
;;
;;  This file is part of WisiToken.
;;
;;  WisiToken is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  WisiToken is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with WisiToken.  If not, see <http://www.gnu.org/licenses/>.
}%
%code actions spec context %{with WisiToken.Text_IO_Trace;}%
%code actions spec post %{
   Trace : aliased WisiToken.Text_IO_Trace.Trace (Descriptor'Access);

   End_Name_Optional : Boolean := True;

   Action_Count : array (Descriptor.First_Nonterminal .. Descriptor.Last_Nonterminal) of Integer := (others => 0);
}%
%generate LALR Ada re2c
%meta_syntax BNF
%keyword AND "and"
%keyword BEGIN "begin"
%keyword BODY "body"
%keyword CASE "case"
%keyword DECLARE "declare"
%keyword ELSE "else"
%keyword ELSIF "elsif"
%keyword END "end"
%keyword EXIT "exit"
%keyword EXCEPTION "exception"
%keyword FOR "for"
%keyword FUNCTION "function"
%keyword IF "if"
%keyword IN "in"
%keyword IS "is"
%keyword LEFT_PAREN "("
%keyword LOOP "loop"
%keyword NEW "new"
%keyword NOT "not"
%keyword OR "or"
%keyword PACKAGE "package"
%keyword PROCEDURE "procedure"
%keyword RANGE "range"
%keyword RETURN "return"
%keyword RIGHT_PAREN ")"
%keyword SEPARATE "separate"
%keyword THEN "then"
%keyword TYPE "type"
%keyword WHEN "when"
%keyword WITH "with"
%keyword XOR "xor"
%token <punctuation> AMPERSAND "&"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUAL ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> DOT_DOT ".."
%token <punctuation> EQUAL "="
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> GREATER ">"
%token <punctuation> GREATER_EQUAL ">="
%token <punctuation> LESS "<"
%token <punctuation> LESS_EQUAL "<="
%token <punctuation> MINUS "-"
%token <punctuation> PLUS "+"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> SLASH_EQUAL "/="
%token <punctuation> STAR "*"
%token <string-double> STRING_LITERAL  %[ (["][\x20-\x21\x23-\U0010FFFF]*["])+ ]%
%token <number> NUMERIC_LITERAL  %[ [0-9]+ ]%
%token <symbol> IDENTIFIER  %[ [a-zA-Z][0-9a-zA-Z_]* ]%
%non_grammar <non-reporting> WHITESPACE  %[ [ \t] ]%
%non_grammar <new-line> NEW_LINE  %[ [\n] ]%
%non_grammar <comment> COMMENT  %[ "--"[^\n]*[\n] ]%
%start compilation_unit_list
%conflict REDUCE / REDUCE in state discrete_subtype_definition , range_list on token RIGHT_PAREN
%conflict SHIFT / REDUCE in state nonterminal_006 , nonterminal_006 on token IDENTIFIER
%conflict SHIFT / REDUCE in state actual_parameter_part , actual_parameter_part on token IDENTIFIER
%conflict SHIFT / REDUCE in state aspect_specification , aspect_specification on token IDENTIFIER
%conflict SHIFT / REDUCE in state extended_return_statement , extended_return_statement on token IDENTIFIER
%conflict SHIFT / REDUCE in state generic_instantiation , generic_instantiation on token IS
%conflict SHIFT / REDUCE in state iteration_scheme , iteration_scheme on token IDENTIFIER
%conflict SHIFT / REDUCE in state subprogram_body , subprogram_body on token IS
actual_parameter_part
  : LEFT_PAREN association_list RIGHT_PAREN
  ;

aspect_specification
  : WITH association_list
  ;

assignment_statement
  : name COLON_EQUAL nonterminal_001_opt SEMICOLON
  ;

association
  : nonterminal_004_opt
  ;

association_list
  : association nonterminal_005_list
  ;

binary_adding_operator
  : PLUS
  | MINUS
  | AMPERSAND
  ;

block_label_opt
  : IDENTIFIER COLON    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%

  | ;; empty
  ;

block_statement
  : block_label_opt DECLARE declarative_part BEGIN handled_sequence_of_statements END nonterminal_007_opt SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 7, End_Name_Optional);)%

  | block_label_opt BEGIN handled_sequence_of_statements END nonterminal_008_opt SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 5, End_Name_Optional);)%

  ;

body_g
  : proper_body
  | body_stub
  ;

body_stub
  : subprogram_body_stub
  ;

case_statement
  : CASE nonterminal_009_opt IS nonterminal_010_list END CASE SEMICOLON
  ;

case_statement_alternative
  : WHEN NUMERIC_LITERAL EQUAL_GREATER sequence_of_statements
  ;

compilation_unit
  : library_item
  ;

compilation_unit_list
  : nonterminal_012_list
  ;

compound_statement
  : if_statement
  | case_statement
  | loop_statement
  | block_statement
  | extended_return_statement
  ;

constraint
  : RANGE range_g
  | index_constraint
  ;

declaration
  : body_g
  | object_declaration
  | subprogram_declaration
  | type_declaration
  ;

declarative_part
  : nonterminal_014_list
  ;

discrete_subtype_definition
  : subtype_indication
  | range_g
  ;

enumeration_type_definition
  : LEFT_PAREN IDENTIFIER nonterminal_016_list RIGHT_PAREN
  ;

exception_choice
  : name
  ;

exception_handler
  : WHEN exception_choice EQUAL_GREATER sequence_of_statements
  ;

exit_statement
  : EXIT nonterminal_018_opt nonterminal_020_opt SEMICOLON
  ;

expression
  : relation nonterminal_021_list
  | relation nonterminal_023_list
  | relation nonterminal_025_list
  ;

extended_return_object_declaration
  : IDENTIFIER COLON subtype_indication
  ;

extended_return_statement
  : RETURN extended_return_object_declaration SEMICOLON
  ;

factor
  : primary
  | NOT primary
  ;

formal_part
  : LEFT_PAREN nonterminal_027_opt nonterminal_028_list RIGHT_PAREN
  ;

full_type_declaration
  : TYPE IDENTIFIER IS type_definition SEMICOLON
  ;

function_specification
  : FUNCTION name parameter_and_result_profile    %()%
    %(return Propagate_Name (Nonterm, Tokens, 2);)%

  ;

generic_instantiation
  : PACKAGE name IS NEW name SEMICOLON
  | PROCEDURE name IS NEW name SEMICOLON
  ;

handled_sequence_of_statements
  : sequence_of_statements nonterminal_032_opt
  ;

if_statement
  : IF nonterminal_033_opt THEN sequence_of_statements nonterminal_035_list nonterminal_037_opt END IF SEMICOLON
  ;

index_constraint
  : LEFT_PAREN discrete_subtype_definition RIGHT_PAREN
  ;

iteration_scheme
  : FOR IDENTIFIER IN discrete_subtype_definition
  ;

library_item
  : package_body
  | subprogram_declaration
  | subprogram_body
  | generic_instantiation
  ;

loop_statement
  : iteration_scheme LOOP sequence_of_statements END LOOP nonterminal_038_opt SEMICOLON
  | LOOP sequence_of_statements END LOOP nonterminal_039_opt SEMICOLON
  ;

multiplying_operator
  : STAR
  | SLASH
  ;

name
  : name LEFT_PAREN range_list RIGHT_PAREN
  | name actual_parameter_part
  | IDENTIFIER    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%

  | selected_component    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%

  ;

object_declaration
  : IDENTIFIER COLON subtype_indication nonterminal_041_opt SEMICOLON
  ;

package_body
  : PACKAGE BODY name nonterminal_042_opt IS declarative_part nonterminal_043_opt END nonterminal_044_opt SEMICOLON    %()%
    %(return Match_Names (Lexer, Descriptor, Tokens, 3, 10, End_Name_Optional);)%

  ;

parameter_and_result_profile
  : formal_part RETURN IDENTIFIER
  | RETURN IDENTIFIER
  ;

parameter_specification
  : IDENTIFIER COLON IDENTIFIER nonterminal_046_opt
  ;

paren_expression
  : LEFT_PAREN nonterminal_047_opt RIGHT_PAREN
  ;

primary
  : NUMERIC_LITERAL
  | STRING_LITERAL
  | name
  | paren_expression
  ;

procedure_call_statement
  : name SEMICOLON
  ;

procedure_specification
  : PROCEDURE name nonterminal_048_opt    %()%
    %(return Propagate_Name (Nonterm, Tokens, 2);)%

  ;

proper_body
  : package_body
  | subprogram_body
  ;

range_g
  : simple_expression DOT_DOT simple_expression
  ;

range_list
  : range_list COMMA range_g
  | range_g
  ;

relation
  : simple_expression nonterminal_049_opt
  ;

relational_operator
  : EQUAL
  | SLASH_EQUAL
  | LESS
  | LESS_EQUAL
  | GREATER
  | GREATER_EQUAL
  ;

selected_component
  : name DOT IDENTIFIER    %()%
    %(return Merge_Names (Nonterm, Tokens, 1, 3);)%

  ;

sequence_of_statements
  : nonterminal_050_list
  ;

simple_expression
  : nonterminal_052_opt term nonterminal_053_list
  ;

simple_return_statement
  : RETURN nonterminal_055_opt SEMICOLON
  ;

simple_statement
  : assignment_statement
  | exit_statement
  | procedure_call_statement
  | simple_return_statement
  ;

statement
  : simple_statement
  | compound_statement
  ;

subprogram_body
  : subprogram_specification nonterminal_056_opt IS declarative_part BEGIN handled_sequence_of_statements END nonterminal_057_opt SEMICOLON    %(Action_Count (+subprogram_body_ID) := Action_Count (+subprogram_body_ID) + 1;)%
    %(return Match_Names (Lexer, Descriptor, Tokens, 1, 8, End_Name_Optional);)%

  ;

subprogram_body_stub
  : subprogram_specification IS SEPARATE SEMICOLON
  ;

subprogram_declaration
  : subprogram_specification SEMICOLON
  ;

subprogram_specification
  : procedure_specification    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%

  | function_specification    %()%
    %(return Propagate_Name (Nonterm, Tokens, 1);)%

  ;

subtype_indication
  : name constraint
  | name
  ;

term
  : factor nonterminal_058_list
  ;

type_declaration
  : full_type_declaration
  ;

type_definition
  : enumeration_type_definition
  ;

unary_adding_operator
  : PLUS
  | MINUS
  ;

