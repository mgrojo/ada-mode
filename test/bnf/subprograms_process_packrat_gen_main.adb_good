--  generated parser support file.
--  command line: wisitoken-bnf-generate.exe  --generate PACKRAT_GEN Ada_Emacs re2c PROCESS ../Test/bnf/subprograms.wy
--

--  Copyright (C) 2013, 2017 - 2019 Stephen Leake.  All Rights Reserved.

--  This program is free software; you can redistribute it and/or
--  modify it under the terms of the GNU General Public License as
--  published by the Free Software Foundation; either version 3, or (at
--  your option) any later version.
--
--  This software is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--  General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

with Subprograms_Process_Actions; use Subprograms_Process_Actions;
with WisiToken.Lexer.re2c;
with subprograms_re2c_c;
with WisiToken.Parse;
package body Subprograms_Process_Packrat_Gen_Main is

   package Lexer is new WisiToken.Lexer.re2c
     (subprograms_re2c_c.New_Lexer,
      subprograms_re2c_c.Free_Lexer,
      subprograms_re2c_c.Reset_Lexer,
      subprograms_re2c_c.Next_Token);

   use WisiToken;
   use WisiToken.Parse.Packrat;
   use WisiToken.Parse.Packrat.Generated;
   function Parse_wisitoken_accept
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_block
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_compilation_unit
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_declarations
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_declaration
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_loop_statement
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_name
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_name_list
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_parameter_list
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_subprogram
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_subtype
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_use_clause
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;

   function Parse_wisitoken_accept
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Pos_0_2  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (20)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (20)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (20, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  20.0: wisitoken_accept <= compilation_unit Wisi_EOI
      Pos := Last_Pos;
      Memo_0_1 := Parse_compilation_unit (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 19 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
         Parser.Derivs (20).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (20, 0),
                Action          => null,
                Children        =>
                 (Memo_0_1.Result,
                  Tree_Index (Pos_0_2)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      Parser.Derivs (20).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (20)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (20)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (20)(Start_Pos);
   end Parse_wisitoken_accept;

   function Parse_block
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Memo_0_2 : Memo_Entry;
      Pos_0_3  : Token_Index;
      Pos_0_4  : Token_Index;
      Memo_0_5 : Memo_Entry;
      Pos_0_6  : Token_Index;
      Pos_1_1  : Token_Index;
      Memo_1_2 : Memo_Entry;
      Pos_1_3  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (21)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (21)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (21, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  21.0: block <= BEGIN loop_statement EXCEPTION WHEN name END
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 3 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_2 := Parse_loop_statement (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 5 then
         Pos := Pos + 1;
         Pos_0_3 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 11 then
         Pos := Pos + 1;
         Pos_0_4 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_5 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_5.State) is
      when Success =>
         Pos := Memo_0_5.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 4 then
         Pos := Pos + 1;
         Pos_0_6 := Pos;
         Parser.Derivs (21).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (21, 0),
                Action          => block_0'Access,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Memo_0_2.Result,
                  Tree_Index (Pos_0_3),
                  Tree_Index (Pos_0_4),
                  Memo_0_5.Result,
                  Tree_Index (Pos_0_6)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      --  21.1: block <= BEGIN loop_statement END
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 3 then
         Pos := Pos + 1;
         Pos_1_1 := Pos;
      else
         goto RHS_1_Fail;
      end if;
      Memo_1_2 := Parse_loop_statement (Parser, Pos);
      case Result_States'(Memo_1_2.State) is
      when Success =>
         Pos := Memo_1_2.Last_Token;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 4 then
         Pos := Pos + 1;
         Pos_1_3 := Pos;
         Parser.Derivs (21).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (21, 1),
                Action          => block_1'Access,
                Children        =>
                 (Tree_Index (Pos_1_1),
                  Memo_1_2.Result,
                  Tree_Index (Pos_1_3)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_1_Fail;
      end if;
      <<RHS_1_Fail>>

      Parser.Derivs (21).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (21)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (21)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (21)(Start_Pos);
   end Parse_block;

   function Parse_compilation_unit
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (22)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (22)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (22, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  22.0: compilation_unit <= declarations
      Pos := Last_Pos;
      Memo_0_1 := Parse_declarations (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
         Parser.Derivs (22).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (22, 0),
                Action          => null,
                Children        => (1 => Memo_0_1.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      Parser.Derivs (22).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (22)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (22)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (22)(Start_Pos);
   end Parse_compilation_unit;

   function Parse_declarations
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Memo_0_2 : Memo_Entry;
      Memo_1_1 : Memo_Entry;
      Pos_Recurse_Last : Base_Token_Index := Last_Pos;
      Result_Recurse   : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (23)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (23)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (23, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      Parser.Derivs (23).Replace_Element (Start_Pos, (State => Failure));
      <<Recurse_Start>>
      --  23.0: declarations <= declarations declaration
      Pos := Last_Pos;
      Memo_0_1 := Parse_declarations (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      Memo_0_2 := Parse_declaration (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (23, 0),
               Action          => null,
               Children        =>
                (Memo_0_1.Result,
                 Memo_0_2.Result),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      --  23.1: declarations <= declaration
      Pos := Last_Pos;
      Memo_1_1 := Parse_declaration (Parser, Pos);
      case Result_States'(Memo_1_1.State) is
      when Success =>
         Pos := Memo_1_1.Last_Token;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (23, 1),
               Action          => null,
               Children        => (1 => Memo_1_1.Result),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      <<RHS_1_Fail>>

      Result_Recurse := (State => Failure);
      <<Finish>>
      if Result_Recurse.State = Success then
         if Pos > Pos_Recurse_Last then
            Parser.Derivs (23).Replace_Element (Start_Pos, Result_Recurse);
            Pos_Recurse_Last := Pos;
            if WisiToken.Trace_Parse > Detail then
               Parser.Trace.Put_Line
                 (Parser.Tree.Image (Result_Recurse.Result, Descriptor, Include_Children => True));
            end if;
            goto Recurse_Start;
         elsif Pos = Pos_Recurse_Last and then Parser.Tree.Is_Empty (Result_Recurse.Result) then
            Parser.Derivs (8).Replace_Element (Start_Pos, Result_Recurse);
         end if;
      end if;

      return Parser.Derivs (23)(Start_Pos);
   end Parse_declarations;

   function Parse_declaration
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Memo_1_1 : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (24)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (24)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (24, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  24.0: declaration <= subprogram
      Pos := Last_Pos;
      Memo_0_1 := Parse_subprogram (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
         Parser.Derivs (24).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (24, 0),
                Action          => null,
                Children        => (1 => Memo_0_1.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      --  24.1: declaration <= use_clause
      Pos := Last_Pos;
      Memo_1_1 := Parse_use_clause (Parser, Pos);
      case Result_States'(Memo_1_1.State) is
      when Success =>
         Pos := Memo_1_1.Last_Token;
         Parser.Derivs (24).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (24, 1),
                Action          => null,
                Children        => (1 => Memo_1_1.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      <<RHS_1_Fail>>

      Parser.Derivs (24).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (24)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (24)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (24)(Start_Pos);
   end Parse_declaration;

   function Parse_loop_statement
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Pos_0_2  : Token_Index;
      Pos_0_3  : Token_Index;
      Memo_0_4 : Memo_Entry;
      Pos_0_5  : Token_Index;
      Pos_0_6  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (25)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (25)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (25, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  25.0: loop_statement <= FOR SYMBOL IN subtype LOOP SEMICOLON
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 6 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 18 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 8 then
         Pos := Pos + 1;
         Pos_0_3 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_4 := Parse_subtype (Parser, Pos);
      case Result_States'(Memo_0_4.State) is
      when Success =>
         Pos := Memo_0_4.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 9 then
         Pos := Pos + 1;
         Pos_0_5 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 17 then
         Pos := Pos + 1;
         Pos_0_6 := Pos;
         Parser.Derivs (25).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (25, 0),
                Action          => loop_statement_0'Access,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Tree_Index (Pos_0_2),
                  Tree_Index (Pos_0_3),
                  Memo_0_4.Result,
                  Tree_Index (Pos_0_5),
                  Tree_Index (Pos_0_6)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      Parser.Derivs (25).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (25)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (25)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (25)(Start_Pos);
   end Parse_loop_statement;

   function Parse_name
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Pos_0_2  : Token_Index;
      Pos_0_3  : Token_Index;
      Pos_1_1  : Token_Index;
      Pos_Recurse_Last : Base_Token_Index := Last_Pos;
      Result_Recurse   : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (26)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (26)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (26, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      Parser.Derivs (26).Replace_Element (Start_Pos, (State => Failure));
      <<Recurse_Start>>
      --  26.0: name <= name DOT SYMBOL
      Pos := Last_Pos;
      Memo_0_1 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 16 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 18 then
         Pos := Pos + 1;
         Pos_0_3 := Pos;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (26, 0),
               Action          => name_0'Access,
               Children        =>
                (Memo_0_1.Result,
                 Tree_Index (Pos_0_2),
                 Tree_Index (Pos_0_3)),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      --  26.1: name <= SYMBOL
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 18 then
         Pos := Pos + 1;
         Pos_1_1 := Pos;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (26, 1),
               Action          => name_1'Access,
               Children        => (1 => Tree_Index (Pos_1_1)),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      else
         goto RHS_1_Fail;
      end if;
      <<RHS_1_Fail>>

      Result_Recurse := (State => Failure);
      <<Finish>>
      if Result_Recurse.State = Success then
         if Pos > Pos_Recurse_Last then
            Parser.Derivs (26).Replace_Element (Start_Pos, Result_Recurse);
            Pos_Recurse_Last := Pos;
            if WisiToken.Trace_Parse > Detail then
               Parser.Trace.Put_Line
                 (Parser.Tree.Image (Result_Recurse.Result, Descriptor, Include_Children => True));
            end if;
            goto Recurse_Start;
         elsif Pos = Pos_Recurse_Last and then Parser.Tree.Is_Empty (Result_Recurse.Result) then
            Parser.Derivs (8).Replace_Element (Start_Pos, Result_Recurse);
         end if;
      end if;

      return Parser.Derivs (26)(Start_Pos);
   end Parse_name;

   function Parse_name_list
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Pos_0_2  : Token_Index;
      Memo_0_3 : Memo_Entry;
      Memo_1_1 : Memo_Entry;
      Pos_Recurse_Last : Base_Token_Index := Last_Pos;
      Result_Recurse   : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (27)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (27)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (27, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      Parser.Derivs (27).Replace_Element (Start_Pos, (State => Failure));
      <<Recurse_Start>>
      --  27.0: name_list <= name_list COMMA name
      Pos := Last_Pos;
      Memo_0_1 := Parse_name_list (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 15 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_3 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_3.State) is
      when Success =>
         Pos := Memo_0_3.Last_Token;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (27, 0),
               Action          => null,
               Children        =>
                (Memo_0_1.Result,
                 Tree_Index (Pos_0_2),
                 Memo_0_3.Result),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      --  27.1: name_list <= name
      Pos := Last_Pos;
      Memo_1_1 := Parse_name (Parser, Pos);
      case Result_States'(Memo_1_1.State) is
      when Success =>
         Pos := Memo_1_1.Last_Token;
         Result_Recurse :=
           (State              => Success,
            Result             => Parser.Tree.Add_Nonterm
              (Production      => (27, 1),
               Action          => null,
               Children        => (1 => Memo_1_1.Result),
               Default_Virtual => False),
            Last_Token      => Pos);
         goto Finish;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      <<RHS_1_Fail>>

      Result_Recurse := (State => Failure);
      <<Finish>>
      if Result_Recurse.State = Success then
         if Pos > Pos_Recurse_Last then
            Parser.Derivs (27).Replace_Element (Start_Pos, Result_Recurse);
            Pos_Recurse_Last := Pos;
            if WisiToken.Trace_Parse > Detail then
               Parser.Trace.Put_Line
                 (Parser.Tree.Image (Result_Recurse.Result, Descriptor, Include_Children => True));
            end if;
            goto Recurse_Start;
         elsif Pos = Pos_Recurse_Last and then Parser.Tree.Is_Empty (Result_Recurse.Result) then
            Parser.Derivs (8).Replace_Element (Start_Pos, Result_Recurse);
         end if;
      end if;

      return Parser.Derivs (27)(Start_Pos);
   end Parse_name_list;

   function Parse_parameter_list
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Pos_0_2  : Token_Index;
      Pos_0_3  : Token_Index;
      Pos_1_1  : Token_Index;
      Pos_1_2  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (28)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (28)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (28, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  28.0: parameter_list <= LEFT_PAREN SYMBOL RIGHT_PAREN
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 13 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 18 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 14 then
         Pos := Pos + 1;
         Pos_0_3 := Pos;
         Parser.Derivs (28).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (28, 0),
                Action          => parameter_list_0'Access,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Tree_Index (Pos_0_2),
                  Tree_Index (Pos_0_3)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      --  28.1: parameter_list <= LEFT_PAREN RIGHT_PAREN
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 13 then
         Pos := Pos + 1;
         Pos_1_1 := Pos;
      else
         goto RHS_1_Fail;
      end if;
      if Parser.Terminals (Pos + 1).ID = 14 then
         Pos := Pos + 1;
         Pos_1_2 := Pos;
         Parser.Derivs (28).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (28, 1),
                Action          => parameter_list_1'Access,
                Children        =>
                 (Tree_Index (Pos_1_1),
                  Tree_Index (Pos_1_2)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_1_Fail;
      end if;
      <<RHS_1_Fail>>

      Parser.Derivs (28).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (28)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (28)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (28)(Start_Pos);
   end Parse_parameter_list;

   function Parse_subprogram
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Memo_0_2 : Memo_Entry;
      Memo_0_3 : Memo_Entry;
      Memo_0_4 : Memo_Entry;
      Pos_0_5  : Token_Index;
      Pos_1_1  : Token_Index;
      Memo_1_2 : Memo_Entry;
      Memo_1_3 : Memo_Entry;
      Pos_1_4  : Token_Index;
      Pos_2_1  : Token_Index;
      Memo_2_2 : Memo_Entry;
      Memo_2_3 : Memo_Entry;
      Pos_2_4  : Token_Index;
      Memo_2_5 : Memo_Entry;
      Pos_2_6  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (29)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (29)(Start_Pos);
         when Failure =>
            goto RHS_2_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (29, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  29.0: subprogram <= FUNCTION name parameter_list block SEMICOLON
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 7 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_2 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      Memo_0_3 := Parse_parameter_list (Parser, Pos);
      case Result_States'(Memo_0_3.State) is
      when Success =>
         Pos := Memo_0_3.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      Memo_0_4 := Parse_block (Parser, Pos);
      case Result_States'(Memo_0_4.State) is
      when Success =>
         Pos := Memo_0_4.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 17 then
         Pos := Pos + 1;
         Pos_0_5 := Pos;
         Parser.Derivs (29).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (29, 0),
                Action          => subprogram_0'Access,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Memo_0_2.Result,
                  Memo_0_3.Result,
                  Memo_0_4.Result,
                  Tree_Index (Pos_0_5)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      --  29.1: subprogram <= FUNCTION name block SEMICOLON
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 7 then
         Pos := Pos + 1;
         Pos_1_1 := Pos;
      else
         goto RHS_1_Fail;
      end if;
      Memo_1_2 := Parse_name (Parser, Pos);
      case Result_States'(Memo_1_2.State) is
      when Success =>
         Pos := Memo_1_2.Last_Token;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      Memo_1_3 := Parse_block (Parser, Pos);
      case Result_States'(Memo_1_3.State) is
      when Success =>
         Pos := Memo_1_3.Last_Token;
      when Failure =>
         goto RHS_1_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 17 then
         Pos := Pos + 1;
         Pos_1_4 := Pos;
         Parser.Derivs (29).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (29, 1),
                Action          => subprogram_1'Access,
                Children        =>
                 (Tree_Index (Pos_1_1),
                  Memo_1_2.Result,
                  Memo_1_3.Result,
                  Tree_Index (Pos_1_4)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_1_Fail;
      end if;
      <<RHS_1_Fail>>

      --  29.2: subprogram <= PROCEDURE name parameter_list END name SEMICOLON
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 10 then
         Pos := Pos + 1;
         Pos_2_1 := Pos;
      else
         goto RHS_2_Fail;
      end if;
      Memo_2_2 := Parse_name (Parser, Pos);
      case Result_States'(Memo_2_2.State) is
      when Success =>
         Pos := Memo_2_2.Last_Token;
      when Failure =>
         goto RHS_2_Fail;
      end case;
      Memo_2_3 := Parse_parameter_list (Parser, Pos);
      case Result_States'(Memo_2_3.State) is
      when Success =>
         Pos := Memo_2_3.Last_Token;
      when Failure =>
         goto RHS_2_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 4 then
         Pos := Pos + 1;
         Pos_2_4 := Pos;
      else
         goto RHS_2_Fail;
      end if;
      Memo_2_5 := Parse_name (Parser, Pos);
      case Result_States'(Memo_2_5.State) is
      when Success =>
         Pos := Memo_2_5.Last_Token;
      when Failure =>
         goto RHS_2_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 17 then
         Pos := Pos + 1;
         Pos_2_6 := Pos;
         Parser.Derivs (29).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (29, 2),
                Action          => subprogram_2'Access,
                Children        =>
                 (Tree_Index (Pos_2_1),
                  Memo_2_2.Result,
                  Memo_2_3.Result,
                  Tree_Index (Pos_2_4),
                  Memo_2_5.Result,
                  Tree_Index (Pos_2_6)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_2_Fail;
      end if;
      <<RHS_2_Fail>>

      Parser.Derivs (29).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (29)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (29)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (29)(Start_Pos);
   end Parse_subprogram;

   function Parse_subtype
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (30)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (30)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (30, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  30.0: subtype <= name
      Pos := Last_Pos;
      Memo_0_1 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
         Parser.Derivs (30).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (30, 0),
                Action          => subtype_0'Access,
                Children        => (1 => Memo_0_1.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      Parser.Derivs (30).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (30)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (30)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (30)(Start_Pos);
   end Parse_subtype;

   function Parse_use_clause
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Memo_0_2 : Memo_Entry;
      Pos_0_3  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (31)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (31)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (31, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  31.0: use_clause <= USE name_list SEMICOLON
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 12 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_2 := Parse_name_list (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 17 then
         Pos := Pos + 1;
         Pos_0_3 := Pos;
         Parser.Derivs (31).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (31, 0),
                Action          => use_clause_0'Access,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Memo_0_2.Result,
                  Tree_Index (Pos_0_3)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      Parser.Derivs (31).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (31)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (31)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (31)(Start_Pos);
   end Parse_use_clause;

   function Parse_wisitoken_accept_1
     (Parser : in out WisiToken.Parse.Base_Parser'Class; Last_Pos : in Base_Token_Index) return Result_Type
   is begin
      return Parse_wisitoken_accept (Generated.Parser (Parser), Last_Pos);
   end Parse_wisitoken_accept_1;

   function Create_Parser
     (Trace     : not null access WisiToken.Trace'Class;
      User_Data : in     WisiToken.Syntax_Trees.User_Data_Access)
     return WisiToken.Parse.Base_Parser'Class
   is begin
      return Parser : WisiToken.Parse.Packrat.Generated.Parser do
         Parser.Trace := Trace;
         Parser.Lexer := Lexer.New_Lexer (Trace.Descriptor);
         Parser.User_Data := User_Data;
         Parser.Parse_WisiToken_Accept := Parse_wisitoken_accept_1'Access;
      end return;
   end Create_Parser;

end Subprograms_Process_Packrat_Gen_Main;
