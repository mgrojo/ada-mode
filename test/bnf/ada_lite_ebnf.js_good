// generated from ada_lite_ebnf.wy -*- buffer-read-only:t -*-
module.exports = grammar({
  name: 'Ada_Lite_Ebnf',
  rules: {
compilation_unit_list: $ => repeat1($.compilation_unit),
AMPERSAND: $ => "&",
COLON: $ => ":",
COLON_EQUAL: $ => ":=",
COMMA: $ => ",",
DOT: $ => ".",
DOT_DOT: $ => "..",
EQUAL: $ => "=",
EQUAL_GREATER: $ => "=>",
GREATER: $ => ">",
GREATER_EQUAL: $ => ">=",
LESS: $ => "<",
LESS_EQUAL: $ => "<=",
MINUS: $ => "-",
PLUS: $ => "+",
SEMICOLON: $ => ";",
SLASH: $ => "/",
SLASH_EQUAL: $ => "/=",
STAR: $ => "*",
STRING_LITERAL: $ => /("[π\x20-\x21\x23-\x7F]*")+/,
IDENTIFIER: $ => /[πa-zA-Z][π0-9a-zA-Z_]*/,
COMMENT: $ => token(seq('--', /.*/)),
NUMERIC_LITERAL: $ => /[0-9]+/,
actual_parameter_part: $ => seq("(", $.association_list, ")"),
aspect_specification: $ => seq("with", $.association_list),
assignment_statement: $ => seq($.name, ":=", $.expression, ";"),
association: $ => seq(optional(seq($.IDENTIFIER, "=>")), $.expression),
association_list: $ => seq($.association, repeat(seq(",", $.association))),
binary_adding_operator: $ => choice("+","-","&"),
block_label_opt: $ => seq($.IDENTIFIER, ":"),
block_statement: $ => seq(optional($.block_label_opt), optional(seq("declare", optional($.declarative_part))), "begin", optional($.handled_sequence_of_statements), "end", optional($.identifier_opt), ";"),
body_g: $ => choice($.proper_body,$.body_stub),
body_stub: $ => $.subprogram_body_stub,
case_statement: $ => seq("case", $.expression, "is", repeat1($.case_statement_alternative), "end", "case", ";"),
case_statement_alternative: $ => seq("when", $.NUMERIC_LITERAL, "=>", optional($.sequence_of_statements)),
compilation_unit: $ => choice($.package_body,$.subprogram_declaration,$.subprogram_body,$.generic_instantiation,$.statement),
compound_statement: $ => choice($.if_statement,$.case_statement,$.loop_statement,$.block_statement,$.extended_return_statement),
constraint: $ => choice(seq("range", $.range_g),$.index_constraint),
declaration: $ => choice($.body_g,$.object_declaration,$.subprogram_declaration,$.type_declaration),
declarative_part: $ => repeat1($.declaration),
discrete_subtype_definition: $ => choice($.subtype_indication,$.range_g),
enumeration_type_definition: $ => seq("(", $.IDENTIFIER, repeat(seq(",", $.IDENTIFIER)), ")"),
exception_choice: $ => $.name,
exception_handler: $ => seq("when", $.exception_choice, "=>", optional($.sequence_of_statements)),
exit_statement: $ => seq("exit", optional($.IDENTIFIER), optional(seq("when", $.expression)), ";"),
expression: $ => choice($.relation,seq($.relation, repeat1(seq("and", $.relation))),seq($.relation, repeat1(seq("or", $.relation))),seq($.relation, repeat1(seq("xor", $.relation)))),
extended_return_object_declaration: $ => seq($.IDENTIFIER, ":", $.subtype_indication),
extended_return_statement: $ => seq("return", $.extended_return_object_declaration, ";"),
factor: $ => choice($.primary,seq("not", $.primary)),
formal_part: $ => seq("(", $.parameter_specification, repeat(seq(";", $.parameter_specification)), ")"),
full_type_declaration: $ => seq("type", $.IDENTIFIER, "is", $.type_definition, ";"),
function_specification: $ => seq("function", $.name, $.parameter_and_result_profile),
generic_instantiation: $ => choice(seq("package", $.name, "is", "new", $.name, ";"),seq("procedure", $.name, "is", "new", $.name, ";")),
handled_sequence_of_statements: $ => seq($.sequence_of_statements, optional(seq("exception", repeat($.exception_handler)))),
identifier_opt: $ => $.IDENTIFIER,
if_statement: $ => seq("if", $.expression, "then", optional($.sequence_of_statements), repeat(seq("elsif", $.expression, "then", optional($.sequence_of_statements))), optional(seq("else", optional($.sequence_of_statements))), "end", "if", ";"),
index_constraint: $ => seq("(", $.discrete_subtype_definition, ")"),
iteration_scheme: $ => seq("for", $.IDENTIFIER, "in", $.discrete_subtype_definition),
loop_statement: $ => seq(optional($.iteration_scheme), "loop", optional($.sequence_of_statements), "end", "loop", optional($.identifier_opt), ";"),
multiplying_operator: $ => choice("*","/"),
name: $ => choice(seq($.name, "(", $.range_list, ")"),seq($.name, $.actual_parameter_part),$.IDENTIFIER,$.selected_component),
name_opt: $ => $.name,
object_declaration: $ => seq($.IDENTIFIER, ":", $.subtype_indication, optional(seq(":=", $.expression)), ";"),
package_body: $ => seq("package", "body", $.name, optional($.aspect_specification), "is", optional($.declarative_part), optional(seq("begin", optional($.handled_sequence_of_statements))), "end", optional($.name_opt), ";"),
parameter_and_result_profile: $ => choice(seq($.formal_part, "return", $.IDENTIFIER),seq("return", $.IDENTIFIER)),
parameter_profile: $ => $.formal_part,
parameter_specification: $ => seq($.IDENTIFIER, ":", $.IDENTIFIER, optional(seq(":=", $.expression))),
paren_expression: $ => seq("(", $.expression, ")"),
primary: $ => choice($.NUMERIC_LITERAL,$.STRING_LITERAL,$.name,$.paren_expression),
procedure_call_statement: $ => seq($.name, ";"),
procedure_specification: $ => seq("procedure", $.name, optional($.parameter_profile)),
proper_body: $ => choice($.package_body,$.subprogram_body),
range_g: $ => seq($.simple_expression, "..", $.simple_expression),
range_list: $ => choice(seq($.range_list, ",", $.range_g),$.range_g),
relation: $ => seq($.simple_expression, optional(seq($.relational_operator, $.simple_expression))),
relational_operator: $ => choice("=","/=","<","<=",">",">="),
selected_component: $ => seq($.name, ".", $.IDENTIFIER),
sequence_of_statements: $ => repeat1($.statement),
simple_expression: $ => seq(optional($.unary_adding_operator), $.term, repeat(seq($.binary_adding_operator, $.term))),
simple_return_statement: $ => seq("return", $.expression, ";"),
simple_statement: $ => choice($.assignment_statement,$.exit_statement,$.procedure_call_statement,$.simple_return_statement),
statement: $ => choice($.simple_statement,$.compound_statement),
subprogram_body: $ => seq($.subprogram_specification, optional($.aspect_specification), "is", optional($.declarative_part), "begin", optional($.handled_sequence_of_statements), "end", optional($.name_opt), ";"),
subprogram_body_stub: $ => seq($.subprogram_specification, "is", "separate", ";"),
subprogram_declaration: $ => seq($.subprogram_specification, ";"),
subprogram_specification: $ => choice($.procedure_specification,$.function_specification),
subtype_indication: $ => choice(seq($.name, $.constraint),$.name),
term: $ => seq($.factor, repeat(seq($.multiplying_operator, $.factor))),
type_declaration: $ => $.full_type_declaration,
type_definition: $ => $.enumeration_type_definition,
unary_adding_operator: $ => choice("+","-"),
  },
  conflicts: $ => [
    [$.primary, $.subtype_indication, ],
    [$.discrete_subtype_definition, $.range_list, ],
    [$.generic_instantiation, $.procedure_specification, ],
  ],
  extras: $ => [
    $.COMMENT,
    /[ \t]/,
    /[\n]/,
  ],
  });
