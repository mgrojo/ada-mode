// generated from ada_lite.wy -*- buffer-read-only:t -*-
module.exports = grammar({
  name: 'Ada_Lite',
  rules: {
compilation_unit_list: $ => choice(seq($.compilation_unit_list, $.compilation_unit),$.compilation_unit),
AMPERSAND: $ => "&",
COLON: $ => ":",
COLON_EQUAL: $ => ":=",
COMMA: $ => ",",
DOT: $ => ".",
DOT_DOT: $ => "..",
EQUAL: $ => "=",
EQUAL_GREATER: $ => "=>",
GREATER: $ => ">",
GREATER_EQUAL: $ => ">=",
LESS: $ => "<",
LESS_EQUAL: $ => "<=",
MINUS: $ => "-",
PLUS: $ => "+",
SEMICOLON: $ => ";",
SLASH: $ => "/",
SLASH_EQUAL: $ => "/=",
STAR: $ => "*",
STRING_LITERAL: $ => /("[π\x20-\x21\x23-\x7F]*")+/,
IDENTIFIER: $ => /[πa-zA-Z][π0-9a-zA-Z_]*/,
COMMENT: $ => token(seq("--", /.*/)),
NUMERIC_LITERAL: $ => /[0-9]+/,
actual_parameter_part: $ => seq("(", $.association_list, ")"),
aspect_specification_opt: $ => seq("with", $.association_list),
assignment_statement: $ => seq($.name, ":=", optional($.expression_opt), ";"),
association_opt: $ => choice(seq($.IDENTIFIER, "=>", optional($.expression_opt)),$.expression),
association_list: $ => choice(seq($.association_list, ",", optional($.association_opt)),$.association_opt),
binary_adding_operator: $ => choice("+","-","&"),
block_label_opt: $ => seq($.IDENTIFIER, ":"),
block_statement: $ => choice(seq(optional($.block_label_opt), "declare", optional($.declarative_part), "begin", $.handled_sequence_of_statements, "end", optional($.identifier_opt), ";"),seq(optional($.block_label_opt), "begin", $.handled_sequence_of_statements, "end", optional($.identifier_opt), ";")),
body_g: $ => choice($.proper_body,$.body_stub),
body_stub: $ => $.subprogram_body_stub,
case_statement: $ => seq("case", optional($.expression_opt), "is", $.case_statement_alternative_list, "end", "case", ";"),
case_statement_alternative: $ => seq("when", $.NUMERIC_LITERAL, "=>", optional($.sequence_of_statements)),
case_statement_alternative_list: $ => choice(seq($.case_statement_alternative_list, $.case_statement_alternative),$.case_statement_alternative),
compilation_unit: $ => choice($.package_specification,$.package_body,$.subprogram_declaration,$.subprogram_body,$.generic_instantiation,$.statement),
compound_statement: $ => choice($.if_statement,$.case_statement,$.loop_statement,$.block_statement,$.extended_return_statement),
constraint: $ => choice(seq("range", $.range_g),$.index_constraint),
declaration: $ => choice($.body_g,$.object_declaration,$.subprogram_declaration,$.type_declaration),
declarations: $ => choice(seq($.declarations, $.declaration),$.declaration),
declarative_part: $ => $.declarations,
discrete_subtype_definition: $ => choice($.subtype_indication,$.range_g),
elsif_statement_item: $ => seq("elsif", optional($.expression_opt), "then", optional($.sequence_of_statements)),
elsif_statement_list: $ => choice(seq($.elsif_statement_list, $.elsif_statement_item),$.elsif_statement_item),
enumeration_literal_list: $ => choice(seq($.enumeration_literal_list, ",", $.IDENTIFIER),$.IDENTIFIER),
enumeration_type_definition: $ => seq("(", $.enumeration_literal_list, ")"),
exception_choice: $ => $.name,
exception_handler: $ => seq("when", $.exception_choice, "=>", optional($.sequence_of_statements)),
exception_handler_list: $ => choice(seq($.exception_handler_list, $.exception_handler),$.exception_handler),
exception_handler_list_opt: $ => $.exception_handler_list,
exit_statement: $ => choice(seq("exit", optional($.identifier_opt), "when", optional($.expression_opt), ";"),seq("exit", optional($.identifier_opt), ";")),
expression: $ => choice($.relation,$.relation_and_list,$.relation_or_list,$.relation_xor_list),
expression_opt: $ => $.expression,
extended_return_object_declaration: $ => seq($.IDENTIFIER, ":", $.subtype_indication),
extended_return_statement: $ => seq("return", $.extended_return_object_declaration, ";"),
factor: $ => choice($.primary,seq("not", $.primary)),
formal_part: $ => seq("(", $.parameter_specification_list, ")"),
full_type_declaration: $ => seq("type", $.IDENTIFIER, "is", $.type_definition, ";"),
function_specification: $ => seq("function", $.name, $.parameter_and_result_profile),
generic_instantiation: $ => choice(seq("package", $.name, "is", "new", $.name, ";"),seq("procedure", $.name, "is", "new", $.name, ";")),
handled_sequence_of_statements: $ => choice(seq(optional($.sequence_of_statements), "exception", optional($.exception_handler_list_opt)),$.sequence_of_statements),
identifier_opt: $ => $.IDENTIFIER,
if_statement: $ => choice(seq("if", optional($.expression_opt), "then", optional($.sequence_of_statements), $.elsif_statement_list, "else", optional($.sequence_of_statements), "end", "if", ";"),seq("if", optional($.expression_opt), "then", optional($.sequence_of_statements), "else", optional($.sequence_of_statements), "end", "if", ";"),seq("if", optional($.expression_opt), "then", optional($.sequence_of_statements), $.elsif_statement_list, "end", "if", ";"),seq("if", optional($.expression_opt), "then", optional($.sequence_of_statements), "end", "if", ";")),
index_constraint: $ => seq("(", $.discrete_subtype_definition, ")"),
iteration_scheme: $ => seq("for", $.IDENTIFIER, "in", $.discrete_subtype_definition),
loop_statement: $ => choice(seq($.iteration_scheme, "loop", optional($.sequence_of_statements), "end", "loop", optional($.identifier_opt), ";"),seq("loop", optional($.sequence_of_statements), "end", "loop", optional($.identifier_opt), ";")),
multiplying_operator: $ => choice("*","/"),
name: $ => choice(seq($.name, "(", $.range_list, ")"),seq($.name, $.actual_parameter_part),$.IDENTIFIER,$.selected_component),
name_opt: $ => $.name,
object_declaration: $ => choice(seq($.IDENTIFIER, ":", $.subtype_indication, ":=", optional($.expression_opt), ";"),seq($.IDENTIFIER, ":", $.subtype_indication, ";")),
package_body: $ => choice(seq("package", "body", $.name, optional($.aspect_specification_opt), "is", optional($.declarative_part), "begin", $.handled_sequence_of_statements, "end", optional($.name_opt), ";"),seq("package", "body", $.name, optional($.aspect_specification_opt), "is", optional($.declarative_part), "end", optional($.name_opt), ";")),
package_specification: $ => seq("package", $.name, optional($.aspect_specification_opt), "is", optional($.declarative_part), "end", optional($.name_opt), ";"),
parameter_and_result_profile: $ => choice(seq($.formal_part, "return", $.IDENTIFIER),seq("return", $.IDENTIFIER)),
parameter_profile_opt: $ => $.formal_part,
parameter_specification: $ => choice(seq($.IDENTIFIER, ":", $.IDENTIFIER, ":=", optional($.expression_opt)),seq($.IDENTIFIER, ":", $.IDENTIFIER)),
parameter_specification_list: $ => choice(seq($.parameter_specification_list, ";", optional($.parameter_specification)),$.parameter_specification),
paren_expression: $ => seq("(", optional($.expression_opt), ")"),
primary: $ => choice($.NUMERIC_LITERAL,$.STRING_LITERAL,$.name,$.paren_expression),
procedure_call_statement: $ => seq($.name, ";"),
procedure_specification: $ => seq("procedure", $.name, optional($.parameter_profile_opt)),
proper_body: $ => choice($.package_body,$.subprogram_body),
range_g: $ => seq($.simple_expression, "..", $.simple_expression),
range_list: $ => choice(seq($.range_list, ",", $.range_g),$.range_g),
relation_and_list: $ => choice(seq($.relation_and_list, "and", $.relation),seq($.relation, "and", $.relation)),
relation_or_list: $ => choice(seq($.relation_or_list, "or", $.relation),seq($.relation, "or", $.relation)),
relation_xor_list: $ => choice(seq($.relation_xor_list, "xor", $.relation),seq($.relation, "xor", $.relation)),
relation: $ => choice(seq($.simple_expression, $.relational_operator, $.simple_expression),$.simple_expression),
relational_operator: $ => choice("=","/=","<","<=",">",">="),
selected_component: $ => seq($.name, ".", $.IDENTIFIER),
sequence_of_statements_list: $ => choice(seq($.sequence_of_statements_list, $.statement),$.statement),
sequence_of_statements: $ => $.sequence_of_statements_list,
simple_expression: $ => choice(seq($.unary_adding_operator, $.term_list),$.term_list),
simple_return_statement: $ => seq("return", optional($.expression_opt), ";"),
simple_statement: $ => choice($.assignment_statement,$.exit_statement,$.procedure_call_statement,$.simple_return_statement),
statement: $ => choice($.simple_statement,$.compound_statement),
subprogram_body: $ => seq($.subprogram_specification, optional($.aspect_specification_opt), "is", optional($.declarative_part), "begin", $.handled_sequence_of_statements, "end", optional($.name_opt), ";"),
subprogram_body_stub: $ => seq($.subprogram_specification, "is", "separate", ";"),
subprogram_declaration: $ => seq($.subprogram_specification, ";"),
subprogram_specification: $ => choice($.procedure_specification,$.function_specification),
subtype_indication: $ => choice(seq($.name, $.constraint),$.name),
term: $ => choice(seq($.term, $.multiplying_operator, $.factor),$.factor),
term_list: $ => choice(seq($.term_list, $.binary_adding_operator, $.term),$.term),
type_declaration: $ => $.full_type_declaration,
type_definition: $ => $.enumeration_type_definition,
unary_adding_operator: $ => choice("+","-"),
  },
  conflicts: $ => [
    [$.generic_instantiation, $.procedure_specification, ],
    [$.generic_instantiation, $.parameter_profile_opt, ],
    [$.subprogram_body_stub, $.aspect_specification_opt, ],
    [$.association_opt, $.parameter_specification, ],
    [$.discrete_subtype_definition, $.range_list, ],
    [$.primary, $.subtype_indication, ],
  ],
  extras: $ => [
    $.COMMENT,
    /[ \t]/,
    /[\n]/,
  ],
  });
