;;; generated from subprograms.wy -*- buffer-read-only:t -*-
;;;
;; Test translate elisp wisi actions to Ada, auto token labels

%code copyright_license %{
;;  Copyright (C) 2013, 2017 - 2021, 2023 Stephen Leake.  All Rights Reserved.

;;  This program is free software; you can redistribute it and/or
;;  modify it under the terms of the GNU General Public License as
;;  published by the Free Software Foundation; either version 3, or (at
;;  your option) any later version.
;;
;;  This software is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;  General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
}%

%meta_syntax BNF

%generate LALR Ada_Emacs re2c Process
%generate Tree_Sitter Ada_Emacs Tree_Sitter Process
;; We don't do packrat here; that would require too many changes to
;; the grammar, breaking what this is testing.

%start compilation_unit

%if parser = LALR
%max_parallel 10

%end if

%keyword BEGIN "begin"
%keyword END "end"
%keyword EXCEPTION "exception"
%keyword FOR "for"
%keyword FUNCTION "function"
%keyword IN "in"
%keyword LOOP "loop"
%keyword OF "of"
%keyword PARALLEL "parallel"
%keyword PROCEDURE "procedure"
%keyword REVERSE "reverse"
%keyword USE "use"
%keyword WHEN "when"

%token <left-paren> LEFT_PAREN "("
%token <right-paren> RIGHT_PAREN ")"

%token <punctuation> COLON ":"
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> SEMICOLON ";"

%if lexer = re2c
%token <symbol> SYMBOL %[ [a-zA-Z][0-9a-zA-Z_]* ]% "bogus_symbol"

%non_grammar <non-reporting> WHITESPACE %[ [ \t] ]%
%non_grammar <new-line> NEW_LINE %[ [\n] ]%

%elsif lexer = Tree_Sitter
%token <symbol> SYMBOL %[ /[a-zA-Z][0-9a-zA-Z_]*/ ]% "bogus_symbol"


%end if

%non_grammar <comment-new-line> COMMENT_1 "--"
%non_grammar <comment-new-line> COMMENT_2 "//"

%if parser = LALR
%conflict SHIFT name | REDUCE in_of on token SYMBOL

%elsif parser = Tree_Sitter
%conflict iteration_scheme in_of%conflict subprogram
%end if

%if parser = LALR
%mckenzie_check_limit 3
%mckenzie_zombie_limit 3
%mckenzie_check_delta_limit 200
%mckenzie_enqueue_limit 10_000
%mckenzie_cost_default 4 4 4 4

%end if

;; elisp names in face actions
%elisp_face font-lock-keyword-face
%elisp_face font-lock-type-face
%elisp_face font-lock-function-name-face
%elisp_face nil

;; language-specific elisp names in indent actions
%elisp_indent subp-indent-function_1 Function_1 2 1
%elisp_indent subp-indent-function_2 Function_2 0
%elisp_indent subp-indent-function_3 Function_2 2 2

;; language-specific elisp action
%elisp_action face wisi-mmmify-token MMMify_Token

;; Auto generated token labels with holes in indent args; preserve one manual label
block
  : name=SYMBOL T2=COLON T3=BEGIN T4=loop_statement T5=EXCEPTION T6=WHEN T7=name T8=END T9=SYMBOL
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | name=SYMBOL T2=COLON T3=BEGIN T4=loop_statement T5=EXCEPTION T6=WHEN T7=name T8=END
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | name=SYMBOL T2=COLON T3=BEGIN T4=loop_statement T8=END T9=SYMBOL
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | name=SYMBOL T2=COLON T3=BEGIN T4=loop_statement T8=END
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | T3=BEGIN T4=loop_statement T5=EXCEPTION T6=WHEN T7=name T8=END T9=SYMBOL
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | T3=BEGIN T4=loop_statement T5=EXCEPTION T6=WHEN T7=name T8=END
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | T3=BEGIN T4=loop_statement T8=END T9=SYMBOL
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  | T3=BEGIN T4=loop_statement T8=END
    %((wisi-statement-action [1 statement-start 3 motion 5 motion 9 motion])
      (wisi-indent-action [nil nil nil subp-indent nil subp-indent nil nil nil]))%
    %((wisi-match-names 1 9))%
  ;

;; No automatic token labels are needed; declaration+ is expanded in
;; this nonterm, and no token is referenced in the action. But
;; wisitoken doesn't examine the action to determine that, and is not
;; smart enough to take advantage of the simple expansion, so it
;; generates an automatic label.
compilation_unit
  : G4=declaration
    %()%
    %((wisi-terminate-partial-parse))%
  | compilation_unit G4=declaration
    %()%
    %((wisi-terminate-partial-parse))%
  | compilation_unit compilation_unit
  ;

declaration
  : subprogram
  | use_clause
  ;

;; No automatic token labels needed; manual labels preserved.
loop_statement
  : iteration_scheme LOOP SEMICOLON
    %((wisi-indent-action [nil 0 nil]))%
  ;

iteration_scheme
  : FOR SYMBOL IN nam=subtype
    %((wisi-face-remove-action [nam])
      (wisi-indent-action [(- subp-indent) 0 (- subp-indent subp-indent-broken) subp-indent]))%
  | T1=PARALLEL T2=LEFT_PAREN T3=chunk_specification T4=RIGHT_PAREN T5=FOR T6=iterator_specification
    %((wisi-indent-action [nil nil nil nil (- subp-indent) nil]]))%
  | T1=PARALLEL T5=FOR T6=iterator_specification
    %((wisi-indent-action [nil nil nil nil (- subp-indent) nil]]))%
  | T5=FOR T6=iterator_specification
    %((wisi-indent-action [nil nil nil nil (- subp-indent) nil]]))%
  ;

in_of
  : IN
  | OF
  ;;; split out for actions

iterator_specification
  : defining_identifier=SYMBOL T2=COLON T3=SYMBOL T4=in_of T5=REVERSE nam=name
    %((wisi-face-remove-action [nam])
      (wisi-indent-action [0 nil nil (- subp-indent subp-indent-broken) nil subp-indent]))%
  | defining_identifier=SYMBOL T2=COLON T3=SYMBOL T4=in_of nam=name
    %((wisi-face-remove-action [nam])
      (wisi-indent-action [0 nil nil (- subp-indent subp-indent-broken) nil subp-indent]))%
  | defining_identifier=SYMBOL T4=in_of T5=REVERSE nam=name
    %((wisi-face-remove-action [nam])
      (wisi-indent-action [0 nil nil (- subp-indent subp-indent-broken) nil subp-indent]))%
  | defining_identifier=SYMBOL T4=in_of nam=name
    %((wisi-face-remove-action [nam])
      (wisi-indent-action [0 nil nil (- subp-indent subp-indent-broken) nil subp-indent]))%
  ;

chunk_specification
  : SYMBOL
  ;

name
  : pre=name T2=DOT suf=SYMBOL
    %((wisi-face-mark-action [pre prefix suf suffix]))%
    %((wisi-merge-names pre suf))%
  | suf=SYMBOL
    %((wisi-face-mark-action [pre prefix suf suffix]))%
    %((wisi-merge-names pre suf))%
  ;

name_list
  : name
    %((wisi-mmmify-token [1]))%
  | name_list COMMA name
    %((wisi-mmmify-token [3])
      (wisi-indent-action [nil
                           0
                           (wisi-hanging 0 java-indent-broken)]))%
  ;

parameter_list
  : T1=LEFT_PAREN T2=SYMBOL T3=RIGHT_PAREN
    %((wisi-statement-action [2 misc])
      (wisi-indent-action [0 (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  | T1=LEFT_PAREN T3=RIGHT_PAREN
    %((wisi-statement-action [2 misc])
      (wisi-indent-action [0 (wisi-anchored 1 1) (wisi-anchored 1 0)]))%
  ;

subprogram
  : fun=FUNCTION nam=name par=parameter_list blo=block sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION nam=name par=parameter_list sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION nam=name blo=block sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION nam=name sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION par=parameter_list blo=block sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION par=parameter_list sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION blo=block sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | fun=FUNCTION sem=SEMICOLON
    %(;; An example of each supported action, with somewhat complex
      ;; parameter syntax, and optional tokens.
      (wisi-statement-action [fun statement-start nam name par misc blo motion sem statement-end])
      (wisi-motion-action [fun [blo EXCEPTION] sem])
      (wisi-face-apply-action [fun nil font-lock-keyword-face nam font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [(fun . 0)
                           (nam . [subp-indent-broken subp-indent-broken])
                           (par . (subp-indent-function_1 nam (* 2 subp-indent-broken)))
                           (blo . 0)
                           (sem . 0)]))%

  | PROCEDURE name parameter_list END name SEMICOLON
;; No manual or automatic token labels
    %((wisi-statement-action [1 statement-start 2 name 6 statement-end])
      (wisi-face-apply-action [1 nil font-lock-keyword-face 2 font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [0 subp-indent-broken subp-indent-broken 0 0 0]))%

  | T1=FUNCTION name=name T3=parameter_list T4=block T5=SEMICOLON
;; Custom elisp indent function and mixed manual and automatic token labels
    %((wisi-indent-action [nil
                           [(subp-indent-function_3 'FUNCTION name) subp-indent-broken]
                           (subp-indent-function_1 name (* 2 subp-indent-broken))
                           (subp-indent-function_2)
                           nil]))%
  | T1=FUNCTION name=name T3=parameter_list T5=SEMICOLON
;; Custom elisp indent function and mixed manual and automatic token labels
    %((wisi-indent-action [nil
                           [(subp-indent-function_3 'FUNCTION name) subp-indent-broken]
                           (subp-indent-function_1 name (* 2 subp-indent-broken))
                           (subp-indent-function_2)
                           nil]))%
  ;

subtype
  : name
    %((wisi-face-apply-action [1 font-lock-type-face font-lock-function-name-face]))%
  ;

use_clause
;; simple group item to test auto token labels
  : T1=USE T2=nonterminal_022 T3=SEMICOLON
    %((wisi-face-apply-list-action [2 font-lock-type-face font-lock-function-name-face])
      (wisi-indent-action [0 subp-indent-broken 0]))%
  ;

;; end of file
nonterminal_022
  : name_list
  ;
