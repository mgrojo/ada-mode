;;; WisiToken grammar for WisiToken grammar, for Emacs wisi-grammar mode.
;;
;;  WisiToken uses the same grammar for parsing .wy files, but with
;;  different actions.
;;  (ediff "wisi_grammar_1.wy" "../org.wisitoken/wisi/wisi_grammar.wy")
;;
;;  The supported syntax is close to Extended Backus-Naur form, as defined by
;;  https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form
;;
;;  Differences from EBNF:
;;  - ':' instead of '='
;;
;;  - Terminating ';' optional in nonterminals.
;;
;;  One requirement is to parse the Python grammar file given at
;;  https://docs.python.org/3.8/reference/grammar.html

%code copyright_license %{
;;  Copyright (C) 2017, 2018 Free Software Foundation, Inc.
;;
;;  Author: Stephen Leake <stephe-leake@stephe-leake.org>
;;
;;  This file is part of GNU Emacs.
;;
;;  GNU Emacs is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation, either version 3 of the License, or
;;  (at your option) any later version.
;;
;;  GNU Emacs is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;;
;;  You should have received a copy of the GNU General Public License
;;  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
}%

;; LR1 for better error correction
%generate LR1 Ada_Emacs re2c Process
%start compilation_unit_list

%no_language_runtime

%keyword CODE "code"
%keyword END "end"
%keyword IF "if"
%keyword KEYWORD "keyword"
%keyword NON_GRAMMAR "non_grammar"
%keyword TOKEN "token"

%token <delimited-text> RAW_CODE "%{" "}%"
%token <delimited-text> REGEXP "%[" "]%"
%token <delimited-text> ACTION "%(" ")%"

%token <punctuation> BAR "|"
%token <punctuation> COLON ":"
%token <punctuation> COMMA ","
%token <punctuation> EQUAL "="
%token <punctuation> GREATER ">"
%token <punctuation> LEFT_BRACKET "["
%token <punctuation> LEFT_PAREN "("
%token <punctuation> LESS "<"
%token <punctuation> PERCENT "%"
%token <punctuation> PLUS "+"
%token <punctuation> RIGHT_BRACKET "]"
%token <punctuation> RIGHT_PAREN ")"
%token <punctuation> SEMICOLON ";"
%token <punctuation> SLASH "/"
%token <punctuation> STAR "*"

%elisp_regexp wisi-number-p %[ [0-9][0-9_]* ]%
%token <number> NUMERIC_LITERAL wisi-number-p
%token <symbol> IDENTIFIER %[ [a-zA-Z][0-9a-zA-Z_-]* ]%

;; In re2c regexps, '...' indicates a case-insensitive match.
;;
;; In nonterminals, '...' indicates a literal, which we translate to a
;; token; case-sensitive is then determined by the 'case_insensitive'
;; declaration.
;;
;; 0x22 = "
;; 0x27 = '
%token <string-double> STRING_LITERAL_1 %[ (["][\x20-\x21\x23-\U0010FFFF]*["])+ ]%
%token <string-single> STRING_LITERAL_2 %[ (['][\x20-\x26\x28-\U0010FFFF]*['])+ ]%

%non_grammar <non-reporting> WHITESPACE %[ [ \t] ]%
%non_grammar <comment> COMMENT %[ ";;"[^\x0a\x04]* ]%
%non_grammar <new-line> NEW_LINE %[ [\x0a]|[\x0d][\x0a] ]%

%elisp_face font-lock-constant-face
%elisp_face font-lock-function-name-face
%elisp_face font-lock-keyword-face
%elisp_face font-lock-string-face
%elisp_face font-lock-type-face
%elisp_face nil

%mckenzie_cost_default 2 2 2 2
%mckenzie_cost_insert SEMICOLON 1
%mckenzie_enqueue_limit 10_000
%mckenzie_check_limit 4

%conflict SHIFT/REDUCE in state declaration, declaration  on token IDENTIFIER
%conflict SHIFT/REDUCE in state declaration_item_list, declaration  on token IDENTIFIER

%conflict SHIFT/REDUCE in state nonterminal, nonterminal  on token IDENTIFIER ( 15)
%conflict SHIFT/REDUCE in state rhs_list, nonterminal  on token PERCENT ( 43)
%conflict SHIFT/REDUCE in state token_list, rhs  on token IDENTIFIER ( 46)
%conflict SHIFT/REDUCE in state rhs_list, rhs_list  on token IDENTIFIER ( 54)

;;;; grammar rules, no particular order

;;EMACSCMD:indent-line-function
;;EMACSRESULT:'mmm-indent-line
;;EMACSCMD:(progn (forward-line 8) (null (mmm-overlay-at (point))))
;;EMACSRESULT:nil
;;EMACSCMD:(progn (forward-line 6) (mmm-update-submode-region) (calculate-lisp-indent (lisp-ppss)))
;;EMACSRESULT:9
declaration
  : PERCENT token_keyword_non_grammar IDENTIFIER declaration_item_list
    %( (progn
         (wisi-statement-action [1 statement-start 3 name])
         (wisi-face-apply-action
          [1 nil font-lock-constant-face
             2 nil font-lock-keyword-face
             3 nil font-lock-function-name-face])) )%
  | PERCENT CODE identifier_list RAW_CODE
  | PERCENT IDENTIFIER declaration_item_list
    %( (wisi-face-apply-action [1 nil font-lock-constant-face 2 nil font-lock-keyword-face]) )%
  | PERCENT IDENTIFIER
    %( (wisi-face-apply-action [1 nil font-lock-constant-face 2 nil font-lock-keyword-face]) )%
  | PERCENT IF IDENTIFIER EQUAL IDENTIFIER
    %( (wisi-face-apply-action [1 nil font-lock-constant-face 2 nil font-lock-keyword-face]) )%
  | PERCENT END IF
    %( (wisi-face-apply-action [1 nil font-lock-constant-face 2 nil font-lock-keyword-face 3 nil
        font-lock-keyword-face]) )%
  ;

token_keyword_non_grammar
  : KEYWORD
  | NON_GRAMMAR LESS IDENTIFIER GREATER
    %( (wisi-face-apply-action [3 nil font-lock-type-face]) )%
  | TOKEN LESS IDENTIFIER GREATER
    %( (wisi-face-apply-action [3 nil font-lock-type-face]) )%
  | TOKEN ;; default <punctuation>
  ;

identifier_list
  : IDENTIFIER
  | identifier_list IDENTIFIER
  ;

declaration_item_list
  : declaration_item
  | declaration_item_list declaration_item
  ;

declaration_item
  : COMMA
  | IDENTIFIER
  | EQUAL
  | NUMERIC_LITERAL
  | REGEXP
  %((wisi-face-apply-action [1 nil font-lock-string-face]))%
  | SLASH
  | STRING_LITERAL_1
  | STRING_LITERAL_2
  | TOKEN
  ;; ",", "token", "/" appear in %conflict declarations
  ;

nonterminal
  : IDENTIFIER COLON rhs_list semicolon_opt
    %( (progn
         (wisi-statement-action [1 statement-start 4 statement-end])
         (wisi-face-apply-action [1 nil font-lock-function-name-face])
         (wisi-indent-action [0 [2 -1] 2 2])) )%
  ;

semicolon_opt : SEMICOLON | ;

rhs_list
  : rhs
  | rhs_list BAR rhs
  | rhs_list PERCENT IF IDENTIFIER EQUAL IDENTIFIER
    %( (wisi-indent-action [0 -2 0 0 0 0]) )%
  | rhs_list PERCENT END IF
    %( (wisi-indent-action [0 -2 0 0]) )%
  ;

rhs
  : ;; empty
  | token_list
  | token_list ACTION
    %( (wisi-indent-action [[(wisi-hanging 0 2) -1] [2 -1]]) )%
  | token_list ACTION ACTION
    %( (wisi-indent-action [[(wisi-hanging 0 2) -1] [2 -1] [2 -1]]) )%
  ;

token_item
  : IDENTIFIER
  | LEFT_BRACKET
  | RIGHT_BRACKET
  | LEFT_PAREN
  | RIGHT_PAREN
  | PLUS
  | STAR
  | STRING_LITERAL_2
  ;

token_list
  : token_item
  | token_list token_item
  ;

;; We don't enforce a complete order, nor require all parts, so
;; partial files can still be parsed successfully.
compilation_unit
  : declaration
  | nonterminal
  ;

compilation_unit_list
  : compilation_unit
  | compilation_unit_list compilation_unit
  ;

;; end of file
