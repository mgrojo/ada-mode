build/Makefile

branches:
org.wisitoken/o.s_l.sal                   - main, used by o.e.a
org.wisitoken.stephe-1/o.s_l.sal.stephe-1 - work, used by o.e.a-2
org.wisitoken.stephe-2/o.s_l.sal.stephe-1 - incremental parse
org.wisitoken.stephe-3/o.s_l.sal.stephe-1 - from o.w.s-2; incremental parse error recover config.input_stream

possible branch tags:
incremental_parse-pre-config.input_stream o.w.s-2

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal")
  (xgit . "/Projects/org.wisitoken")))

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal.stephe-1")
  (xgit . "/Projects/org.wisitoken.stephe-2")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-2")))

update-wisitoken_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-2"        . "../org.wisitoken")))

 current work
incremental parse
    eliminate state in tree node by computing from parse_table, current_state and id shifted.
        wagner graham 1998
        store current_state in config, parser_state

    don't copy entire tree in New_Stream
        bring back set_parents
        shared_stream needs parents for next_shared_Terminal
            same in stream input?!
            store parents in iterator object
        other nodes don't set new parents.
            or change Parent to stream_map_node_access?


        config.input_stream could be real_recover_Token, to cache first_terminal

        edit_tree delete unreachable nodes (from terminated parse streams)
            use mark and sweep

        OR at least delete all nodes in a stream when delete the stream

    run all tests
        t_mck: all pass
        test/test_incremental.adb :
            need left_breakdown (shared_stream) in get_action

        t_all:
./wisitoken-bnf-generate.exe --output_bnf --generate None ../test/bnf/java_ebnf.wy
    doesn't translate token literals; copied shared_terminal nodes not in Data.EBNF_Nodes.

    ada_lite.wy require statement in sequence_of_statements

    test Parser.line_begin_token

    more tests;
        parse_incremental with current_token = empty nonterm
        left_breakdown with first_terminal = virtual
        Mckenzie current_Terminal skip virtual terminals in input and shared
            breakdown virtual nonterms if first is virtual

    error recover delete may need left_breakdown (shared_stream)
        make that expensive, or just don't do it.
        copy to config.input_stream?

    error recover test case:
        mck_ref.parse current_Token; most nested 'end loop' is 'end if' because not changed yet

    edit after error recovery:
        no virtuals adjacent to edits; keep other virtuals

    enhance the parse table to store reduce actions on nonterms as well as terminals?
        ada lr1 is already huge

    review fixmes

    should be two Wisi_EOI in streams

    test partial_parse
        first EOI is at end of parse, not end of shared_stream.

    could merge edit_tree, parse_incremental
        wagner graham 1998
        is edit_tree useful for packrat incremental?
        tree-sitter has edit_tree

    [Wagner Graham 1998] doesn't modify the tree structure for
        Left_Breakdown; it just moves the Current_Token pointer around.
        requires significantly different tree structure.
            child pointers are bastardized as stream pointers.
        rest of parser must understand that.
        requires merge edit_tree into incremental parse
        faster? less allocate/deallocate

    branched parse stack would simplify duplicate_state check?
        but have to move branch point in error recover for push_back, undo_reduce.
            or not; the other parser will do that?

    batch parse is a special case of incremental parse
        edits = all inserted.

    if use partial parse as initial parse for incremental, with
    inserted text before and after, may want to allow error recover to
    push_back over Virtual tokens


Mckenzie parallel gain
    eliminate super access that does not require lock

recover supervisor should provide Put_Trace_line
    to control access to Trace

Nullable can be a boolean array

auto_token_labels
    check for empty statement-action params
        wisitoken_grammar_1_bnf.wy nonterminal_009

doc ebnf vs actions in wisitoken.texi
    autolabel tokens

Docs/error_correction_algorithm.tex
    use mmm-mode for Ada code in lstlisting?
    (mmm-add-classes '((lstlisting-c++
                    :submode js-mode
                    :front "^\\\\begin{lstlisting}"
                    :back  "^\\\\end{lstlisting}"
                    :front-offset (end-of-line 1)
                    :back-offset (beginning-of-line -1))))
    (mmm-add-mode-ext-class 'latex-mode nil 'lstlisting-c++)

    give more detail on base McKenzie; don't use McKenzie notation.

    Plot recover time as a function of task_count

    tree-sitter can't handle ada:
    it's using some very non-linear algorithm to generate the LALR states,
so it takes forever on a language the size of Ada; I killed it after 90
minutes

    bogus input: In general, the error correction hits
the enqueue_limit in cases like this - it enqueues lots of
configurations that try to make progresss, but gets nowhere. The time to
hit that limit is fairly consistent, and the user can set that limit.

    ada-mode/test compare
        tree-sitter java
            https://github.com/tree-sitter/tree-sitter-java
                compare tree-sitter generate time to translating java_ch19.wy
            find java test set on web; some error correction papers mention that
            measure parse time difference correct code vs error correction
            add totally bogus file; gpr file, text file in Ada parser

        Bison?
        ANTLR  https://github.com/Alex-Gamper/Ada-Grammar.git

    Get Ludovic to enable --recover-log, publish real data from production environment.
        email sent 24 Jul
        enhance to capture files

   - ask for review
     - Stefan Monnier - email sent 24 jul
     - Emmanual Briot - LinkedIn message sent 24 jul
     - adacore adalang RaphaÃ«l Amiard raph-amiard - email sent 24 jul
     - Max Brunsfeld tree-sitter - added to issue 693 24 jul
     - ada-mode mailing list - posted 24 jul
     - emacs-devel mailing list - posted 24 jul

   - publish in some ACM journal?
     McKenzie in ACM Transactions on Programming Languages and Systems
     Fischer/Mauney in  Acta Informatica Springer
     Stefan Monnier paper on SMIE in  https://programming-journal.org/

Plot generate time as a function of task_count

generate Tree Sitter C code
    use tree-sitter runtime, and therefore web languages

LR1 algorithm.tex:
    super needs C_Tree to compute unique state numbers.
    w workers
    worker gets N states, returns M new
    of which Md are also found by other workers before wi are processed
    super searches/inserts M states in 1 trees, (M - Md) in w trees.
    when average M << N (later in process), worker search dominates super insert => parallel wins,
    when average M >> N, super insert into w workers dominates worker search
    ada.wy states: 469_463
        rows:     113; initial item sets time: 178.?
        rows:     467; initial item_sets time: 168.460805229, max_row_depth: 14 average_row_depth: 13
        rows:    1877; initial item_sets time: 165.346752806, max_row_depth: 12 average_row_depth: 10
        rows:  62_039; initial item_sets time: 163.757085680, max_row_depth: 9 average_row_depth: 4
        rows: 124_087; initial item_sets time: 161.564576128, max_row_depth: 9 average_row_depth: 2
        rows: 248_177; initial item_sets time: 163.082249550, max_row_depth: 9 average_row_depth: 1

implement %local_keyword?
    for ada_annex_p aspect_mark 'class', some others
    add in-parse action to check identifier in local_keyword set.

need gnat-prep for tree-sitter
    most devels won't have it

add tree-sitter parser, lexer
    ada_lite.wy
        getting syntax errors
            that's just generalized parsing; the lexer is aware of the parser state

    write Ada code to traverse tree-sitter tree
    report errors:
        ts_node_has_error
            traverse tree, checking each node

        find nodes with errors Tree Query for `(ERROR)`; ts_query_new, ts_query_cursor_new
            https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries

        https://github.com/tree-sitter/tree-sitter/issues/255 for adding APIs suited toward user-facing error messages.


    case insensitive:
        alias(/[fF][oO][rR]/, 'for')

    translate tree-sitter parse tree to wisitoken?
        api.h has root, node_children,  etc.

    time parts of w-bnf-generate tree_sitter; seems slow on ada_annex_p

    need to_grammar for actions
        which needs all tokens defined
        and is done before translate_to_tree_sitter is done
        so do subset of translate_to_bnf
            allow to_grammar to call execute_actions and declare the tokens.
            preserve token numbers for actions
            build the actions

improve bnf generation
    copy/preserve trailing comments on ebnf nodes
        ada_ebnf.wy ";; end of file"
        python_ebnf_bnf.wy
            atom: forced terminating semicolon should be before trailing comment

    java_ebnf.wy Statement
        inline expand ()

    java_types_ch19.wy Dims top level is canonical list, list_element = Annotation_list LEFT_BRACKET RIGHT_BRACKET
        requires adding 'empty' to Annotation_list instead of inserting optional rhs
        or first phase of extracting common sequences.

    python.wy
        decorated: decorators (classdef | funcdef | async_funcdef)
            expand group locally
            helps if user needs to copy bnf output to .wy for actions

        testlist_star_expr use names from alt_list for nonterminal

        try_stmt: indent +1 for paren

        classdef: don't copy newline in insert_optional?

   separate pass to eliminate single-token productions
       ada_annex_p explicit_generic_actual_parameter ::= expression
       also have to edit conflicts, or user will be confused
       output substitutions so user can do them

write Python INDENT, DEDENT as re2c code

delete descriptor.case_insensitive?
    used in regexp lexer?
    move to lexer?

syntax_trees.Replace_Child
    update cached data as in Set_Children

-explore.check
         --  FIXME: if there were conflicts, enqueue them; they might yield a
         --  cheaper or same cost solution?
         same code as fast_forward; just use that?

        see if parsing all affects any tests

        item.shift_count not used

String_literal, numeric_literal, identifier are equivalent - only insert one
    minimal_complete does this for expression

test/ada_mode-recover_31.adb
    language_fixes changes char_literal '|-' to string_literal; ok for first call on real error

    but later, it gets a config where Error_Token is set by Parse.Parse
        with min_terminal_index = invalid_token_index, virtual = true

    because in Parse.Parse_One_Item, Current_Token is a Base_Token, which does not have Token_Index
        use parser_state.current_shared_token?
        or change Current_Token to Recover_Token?

redesign parse table to speed recovery
    group identical reduce actions
        ada_mode-recover_02.adb
        only do each reduce once, then insert lots of terminals

rename "semantic checks" to "in-parse actions", others to "post-parse actions".

wisitoken user guide mention concrete syntax tree

terminate duplicate_state missed one
    convert_if_to_case.ada_lite
task 0 3: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (25 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
task 0 2: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (23 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
    should have terminated one!

java-ch19.wy TryStatement has optional statement-end
    need override on previous tokens

improve mismatched paren checks in actions
    maybe just in wisitoken_grammar_mode?
        only active if mmm-mode recognizes action; improve that?
    partial parse in ada.wy?

use duplicate_reduce in text_rep

allow undo_reduce after insert/fast_forward
    in Recover, processing ops
        need test case; ada_mode.recover_25 with language_fix that does not push_back declarative_part_opt
        ada_mode-recover_27.adb uses Undo_Reduce (to allow 'insert loop'), but not after insert.
        if no useful test cases, delete Try_Undo_Reduce, and doc why.
        or add None_At_All (Insert) to try_Undo_Reduce.

test_mckenzie use lr-parser-gen_aunit

make "canonical list" compatible with packrat?
    ie swap rhs_index 0, 1
    better to implement list in packrat

c:/Projects/org.emacs.java-wisi/test/recover_001.java
    don't delete next if minimal_c_a inserted

    minimal_complete_actions isn't globally minimal
        state 245 could use
            classOrInterfaceType <= IDENTIFIER
            lambdaParameters <= IDENTIFIER
            primary <= IDENTIFIER
            classType <= IDENTIFIER

            picks first = classOrInterfaceType => inserts .class,  reduces to primary
            find that in a post-optimize step?

Python
    c:/Projects/org.emacs.python-wisi/python.wy
    need INDENT, DEDENT in lexer
    no other new syntax
    only one state with more than two actions
    reduce conflicts by recognizing canonical list in local_stmt (correctly)
    improve process_main compile time
        reduce number of statements in each subprogram
        or use text_rep

lalr generator bug
    long term fix; reimplement lalr using deremer, penello 1982
    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
                could include sequence of empty nonterms in first_nonterm_set, return two goto_sets
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

re2c now has --location-format <gnu | msvc>
    Apr 2019 in devel, not release

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

enqueue_limit should be for total over all parsers; more consistent max time
    need test case?

Error messages need gen_alg prefix - add to Error_message

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

can generate code for LR parser, rather than using table
    see Google drive/Parsing/notes
    screws up recover because parse stack = cpu stack; not accessible?

try packrat indirect recursion solution
    see paper by laurent, mens
        in ebooks/parsing, google drive
        used in https://tatsu.readthedocs.io/

    https://arxiv.org/abs/2005.06444 pika parser
        bottom-up, right-to-left
            allows error correction
            same as LR?

    http://mousepeg.sourceforge.net
        http://www.romanredz.se/pubs.htm

    docs/indirect_recursion_in_packrat.latex
        finish it

    add "run grammar.wy input" main for -procedural_*?

    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

   - https://arxiv.org/pdf/1806.11150 error recovery for PEG
     compares LPegLabel to ANTLR, on synthetic errors


compare to bison times

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

add packrat error recover
    "d:/Books/eBooks/Parsing/Fischer Mauney 1992 - Simple fast LL1 error repair.pdf"
    assumes no backtracking?
        pg 112: "parser announces error when prediction does not fit next input"

adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 refs
build/release_process.text

d:/Books/eBooks/Parsing/Wagner, Graham 1998 Efficient and Flexible Incremental Parsing.pdf

# end of file
