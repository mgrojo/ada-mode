build/Makefile

branches:
org.wisitoken/o.s_l.sal                   - main, used by o.e.a
org.wisitoken.stephe-1/o.s_l.sal.stephe-1 - work, used by o.e.a-2
org.wisitoken.stephe-2/o.s_l.sal.stephe-1 - incremental parse

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal")
  (xgit . "/Projects/org.wisitoken")))

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal.stephe-1")
  (xgit . "/Projects/org.wisitoken.stephe-2")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

update-wisitoken_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-2"        . "../org.wisitoken")))

 current work
incremental parse
    run_wisitoken_grammar.exe ada_ebnf.wy
        runs

    wisitoken-bnf-generate.exe empty_production_3.wy
        runs

    wisitoken-bnf-generate.exe ada_lite.wy
        runs

    test/test_incremental.adb

    run all tests
        fixing parser, mckenzie_recover

    apply edit:
        wi.parse.lr.incremental?
        kmn list; must also store inserted text
            paper assumes versioned file contents directly available; we don't

        LSP didchangeTextDocumentParams sends changed range, inserted text.
            presumably a delete is represented by a non-null range and an empty insert.

        Parser.line_begin_token must be updated; used in error recover

    review fixmes

    consider switch back to array tree
        measure parse speed, memory use

    branched parse stack eliminates need for duplicate_state check?
        but have to move branch point in error recover for push_back, undo_reduce.
            or not; the other parser will do that?

auto_token_labels
    check for empty statement-action params
        wisitoken_grammar_1_bnf.wy nonterminal_009

doc ebnf vs actions in wisitoken.texi

error_correction_algorithm.tex
    ada-mode/test compare
        Bison?
        ANTLR  https://github.com/Alex-Gamper/Ada-Grammar.git

    Get Ludovic to enable --recover-log, publish real data from production environment.
        email sent 24 Jul
        enhance to capture files

   - ask for review
     - Stefan Monnier - email sent 24 jul
     - Emmanual Briot - LinkedIn message sent 24 jul
     - adacore adalang RaphaÃ«l Amiard raph-amiard - email sent 24 jul
     - Max Brunsfeld tree-sitter - added to issue 693 24 jul
     - ada-mode mailing list - posted 24 jul
     - emacs-devel mailing list - posted 24 jul

   - publish in some ACM journal?
     McKenzie in ACM Transactions on Programming Languages and Systems
     Fischer/Mauney in  Acta Informatica Springer
     Stefan Monnier paper on SMIE in  https://programming-journal.org/

LR1 algorithm.tex:
    super needs C_Tree to compute unique state numbers.
    w workers
    worker gets N states, returns M new
    of which Md are also found by other workers before wi are processed
    super searches/inserts M states in 1 trees, (M - Md) in w trees.
    when average M << N (later in process), worker search dominates super insert => parallel wins,
    when average M >> N, super insert into w workers dominates worker search
    ada.wy states: 469_463
        rows:     113; initial item sets time: 178.?
        rows:     467; initial item_sets time: 168.460805229, max_row_depth: 14 average_row_depth: 13
        rows:    1877; initial item_sets time: 165.346752806, max_row_depth: 12 average_row_depth: 10
        rows:  62_039; initial item_sets time: 163.757085680, max_row_depth: 9 average_row_depth: 4
        rows: 124_087; initial item_sets time: 161.564576128, max_row_depth: 9 average_row_depth: 2
        rows: 248_177; initial item_sets time: 163.082249550, max_row_depth: 9 average_row_depth: 1

implement %local_keyword?
    for ada_annex_p aspect_mark 'class', some others
    add in-parse action to check identifier in local_keyword set.

need gnat-prep for tree-sitter
    most devels won't have it

add tree-sitter parser, lexer
    ada_lite.wy
        getting syntax errors
            that's just generalized parsing; the lexer is aware of the parser state

    write Ada code to traverse tree-sitter tree
    report errors:
        ts_node_has_error
            traverse tree, checking each node

        find nodes with errors Tree Query for `(ERROR)`; ts_query_new, ts_query_cursor_new
            https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries

        https://github.com/tree-sitter/tree-sitter/issues/255 for adding APIs suited toward user-facing error messages.


    case insensitive:
        alias(/[fF][oO][rR]/, 'for')

    translate tree-sitter parse tree to wisitoken?
        api.h has root, node_children,  etc.

    time parts of w-bnf-generate tree_sitter; seems slow on ada_annex_p

    need to_grammar for actions
        which needs all tokens defined
        and is done before translate_to_tree_sitter is done
        so do subset of translate_to_bnf
            allow to_grammar to call execute_actions and declare the tokens.
            preserve token numbers for actions
            build the actions

improve bnf generation
    copy/preserve trailing comments on ebnf nodes
        ada_ebnf.wy ";; end of file"
        python_ebnf_bnf.wy
            atom: forced terminating semicolon should be before trailing comment

    java_ebnf.wy Statement
        inline expand ()

    java_types_ch19.wy Dims top level is canonical list, list_element = Annotation_list LEFT_BRACKET RIGHT_BRACKET
        requires adding 'empty' to Annotation_list instead of inserting optional rhs
        or first phase of extracting common sequences.

    python.wy
        decorated: decorators (classdef | funcdef | async_funcdef)
            expand group locally
            helps if user needs to copy bnf output to .wy for actions

        testlist_star_expr use names from alt_list for nonterminal

        try_stmt: indent +1 for paren

        classdef: don't copy newline in insert_optional?

   separate pass to eliminate single-token productions
       ada_annex_p explicit_generic_actual_parameter ::= expression
       also have to edit conflicts, or user will be confused
       output substitutions so user can do them

write Python INDENT, DEDENT as re2c code

delete descriptor.case_insensitive?
    used in regexp lexer?
    move to lexer?

syntax_trees.Replace_Child
    update cached data as in Set_Children

-explore.check
         --  FIXME: if there were conflicts, enqueue them; they might yield a
         --  cheaper or same cost solution?
         same code as fast_forward; just use that?

        see if parsing all affects any tests

        item.shift_count not used

String_literal, numeric_literal, identifier are equivalent - only insert one
    minimal_complete does this for expression

test/ada_mode-recover_31.adb
    language_fixes changes char_literal '|-' to string_literal; ok for first call on real error

    but later, it gets a config where Error_Token is set by Parse.Parse
        with min_terminal_index = invalid_token_index, virtual = true

    because in Parse.Parse_One_Item, Current_Token is a Base_Token, which does not have Token_Index
        use parser_state.current_shared_token?
        or change Current_Token to Recover_Token?

redesign parse table to speed recovery
    group identical reduce actions
        ada_mode-recover_02.adb
        only do each reduce once, then insert lots of terminals

rename "semantic checks" to "in-parse actions", others to "post-parse actions".

wisitoken user guide mention concrete syntax tree

terminate duplicate_state missed one
    convert_if_to_case.ada_lite
task 0 3: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (25 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
task 0 2: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (23 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
    should have terminated one!

java-ch19.wy TryStatement has optional statement-end
    need override on previous tokens

improve mismatched paren checks in actions
    maybe just in wisitoken_grammar_mode?
        only active if mmm-mode recognizes action; improve that?
    partial parse in ada.wy?

use duplicate_reduce in text_rep

allow undo_reduce after insert/fast_forward
    in Recover, processing ops
        need test case; ada_mode.recover_25 with language_fix that does not push_back declarative_part_opt
        ada_mode-recover_27.adb uses Undo_Reduce (to allow 'insert loop'), but not after insert.
        if no useful test cases, delete Try_Undo_Reduce, and doc why.
        or add None_At_All (Insert) to try_Undo_Reduce.

test_mckenzie use lr-parser-gen_aunit

make "canonical list" compatible with packrat?
    ie swap rhs_index 0, 1
    better to implement list in packrat

c:/Projects/org.emacs.java-wisi/test/recover_001.java
    don't delete next if minimal_c_a inserted

    minimal_complete_actions isn't globally minimal
        state 245 could use
            classOrInterfaceType <= IDENTIFIER
            lambdaParameters <= IDENTIFIER
            primary <= IDENTIFIER
            classType <= IDENTIFIER

            picks first = classOrInterfaceType => inserts .class,  reduces to primary
            find that in a post-optimize step?

Python
    c:/Projects/org.emacs.python-wisi/python.wy
    need INDENT, DEDENT in lexer
    no other new syntax
    only one state with more than two actions
    reduce conflicts by recognizing canonical list in local_stmt (correctly)
    improve process_main compile time
        reduce number of statements in each subprogram
        or use text_rep

lalr generator bug
    long term fix; reimplement lalr using deremer, penello 1982
    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
                could include sequence of empty nonterms in first_nonterm_set, return two goto_sets
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

re2c now has --location-format <gnu | msvc>
    Apr 2019 in devel, not release

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

enqueue_limit should be for total over all parsers; more consistent max time
    need test case?

Error messages need gen_alg prefix - add to Error_message

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

can generate code for LR parser, rather than using table
    see Google drive/Parsing/notes
    screws up recover because parse stack = cpu stack; not accessible?

try packrat indirect recursion solution
    see paper by laurent, mens
        in ebooks/parsing, google drive
        used in https://tatsu.readthedocs.io/

    https://arxiv.org/abs/2005.06444 pika parser
        bottom-up, right-to-left
            allows error correction
            same as LR?

    http://mousepeg.sourceforge.net
        http://www.romanredz.se/pubs.htm

    docs/indirect_recursion_in_packrat.latex
        finish it

    add "run grammar.wy input" main for -procedural_*?

    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

   - https://arxiv.org/pdf/1806.11150 error recovery for PEG
     compares LPegLabel to ANTLR, on synthetic errors


compare to bison times

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

add packrat error recover
    "d:/Books/eBooks/Parsing/Fischer Mauney 1992 - Simple fast LL1 error repair.pdf"
    assumes no backtracking?
        pg 112: "parser announces error when prediction does not fit next input"

adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
