build/Makefile

branches:
org.wisitoken          - working, used by o.e.a.s-2
org.wisitoken.stephe-1 - available

(dvc-state-multiple
'((xmtn . "/Projects/org.stephe_leake.makerules")
  (xmtn . "/Projects/org.stephe_leake.aunit_ext")
  (xmtn . "/Projects/org.stephe_leake.sal.stephe-1")
  (xmtn . "/Projects/org.wisitoken.stephe-1")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
different lr1_items lookahead structure
    descriptor:
        just one class; set propagate_id to invalid_token_id
            then just do tok_id = desc.prop_id
            don't do lookaheads (prop_id) without prev check

    wisitoken.to_lookahead is a bottleneck

    operations:
        to_lookahead (token_id)

        for tok_id of lookaheads loop
            if tok_id /= propagate_id
            call add_action (tok_id)

        if lookaheads (tok_id) then

        new_item := (... , lookaheads => old_item.lookaheads)

        new_item := (... , lookaheads => null_lookaheads)
        new_item := (... , lookaheads => propagate_lookahead)

        include: add tok_id to lookaheads

        lookaheads /= lookaheads

    allow optimize away all range checks

get profile on generate lr1 ada_lite
    make generate_ada_lite_lr1.gprof

    top low level times:
  6.31      3.80     0.33                             wisitoken__lr__lr1_items__include__4.constprop.100
  4.21      4.02     0.22 146677379     0.00     0.00  wisitoken__lr__lr1_items__item_lists__next__4
  2.87      4.17     0.15  4608786     0.00     0.00  wisitoken__lr__lr1_generate__lr1_goto_transitions
  2.68      4.31     0.14  7454674     0.00     0.00  wisitoken__lr__lr1_items__find__2
  2.10      4.42     0.11  4821257     0.00     0.00  wisitoken__to_lookahead

    call graph:
[5]     16.2    0.03    0.82       1         wisitoken__lr__lr1_generate__lr1_item_sets [5]
                0.15    0.49 4608786/4608786     wisitoken__lr__lr1_generate__lr1_goto_transitions [7]
                0.09    0.04  141101/141101      wisitoken__lr__lr1_items__find__4 [13]

[7]     12.2    0.15    0.49 4608786         wisitoken__lr__lr1_generate__lr1_goto_transitions [7]
                0.06    0.22  141101/141102      wisitoken__lr__lr1_items__closure [11]
                0.05    0.00 30558582/146677379     wisitoken__lr__lr1_items__item_lists__next__4 [12]

[11]     5.3    0.06    0.22  141102         wisitoken__lr__lr1_items__closure [11]
                0.11    0.00 4821256/4821257     wisitoken__to_lookahead [14]
                0.02    0.00 1017248/1019702     wisitoken__token_id_arrays__iterate [27]
                0.00    0.02 7454674/7510152     wisitoken__token_id_arrays__first [29]
                0.02    0.00 11502839/38812715     wisitoken__token_id_arrays__element__2 [15]
                0.01    0.00 3166945/3166945     wisitoken__lr__lr1_items__item_lists__reference [39]
                0.01    0.00 3184462/3185644     wisitoken__token_id_arrays__next__4 [38]
                0.01    0.00 4201710/4205346     wisitoken__token_id_arrays__has_element [51]
                0.01    0.00 3184462/3187533     wisitoken__token_id_arrays__constant_ref__2 [37]
                0.01    0.00 2214682/2239218     wisitoken__productions__prod_arrays__constant_ref [40]

time wisi-generate ada_lite, ada
    rebuild with no debug (ie do recursive-clean); factor of 3

    time ./wisi-generate.exe --time --generate LALR Ada re2c ../wisi/test/ada_lite.wy
        o.w     0m0.212s 0m0.217s
        o.w.s-1 0m0.838s 0m0.836s
        improve find item in item_list  0.549 0.514
        replace loop with grammar (lhs) 0.395
        use first_terminal_sequence     0.327
            (oops; had debug options turned on)
        delete lookaheads=null from find    0.174
        change Descriptors to non-tagged, Last_Lookahead 0.174

    time ./wisi-generate.exe --generate LR1 Ada re2c ../wisi/test/ada_lite.wy
        o.w     ada_lite_lr1.wy     0m28.034s 0m27.237s
        o.w.s-1                     1m37.592s
        item_set_tree               0m34.085s
        improve set_tree_key_less   0m33.990s 0m33.040s
        improve find item in item_list  0m34.105s 0m34.584s  34.418 34.695
        replace loop with grammar (lhs) 10.672
        use first_terminal_sequence     4.660
            (oops; had debug options turned on)
        delete lookaheads=null from find    3.793
        change Descriptors to non-tagged, Last_Lookahead 3.726

    time ./wisi-generate.exe --generate LALR Ada re2c ../../org.emacs.ada-mode.stephe-4/ada.wy
        o.e.a_m.s-2                 0m16.739s 0m16.166s
        o.e.a_m.s-4                 0m15.983s 0m16.006s
        item_set_tree               0m11.276s
        improve set_tree_key_less   0m11.558s 0m11.557s
        improve find item in item_list  0m11.597s 0m11.442s 0m11.414s 0m11.378s 0m11.589s  11.449
        replace loop with grammar (lhs) 8.482
        use first_terminal_sequence     7.548
            (oops; had debug options turned on)
        delete lookaheads=null from find 3.288
        change Descriptors to non-tagged, Last_Lookahead 3.251

effect of lr1/lalr on mckenzie
    wisi/ada_lite_lalr_run.exe -v 0 -m 1 ../wisi/test/ada_lite_recover.input > ada_lite_lalr_recover.log
    wisi/ada_lite_lr1_run.exe  -v 0 -m 1 ../wisi/test/ada_lite_recover.input > ada_lite_lr1_recover.log

    lr1 finds significantly better solutions significantly quicker

propagate to main

better constrain_terminals:
    o.w.s-1
    when constrain_Terminals_Pred True, map (state) => (set of terminals to insert)
    store kernel (set of prod with dot)
    store set of first terminal of minimial_completing_terminal_sequence for each kernel

    apply when error token is :=
        language predicate for when to apply?

add delete to config heap, use when configuration_access is abandoned?

try indirect recursion solution
    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    docs/indirect_recursion_in_packrat.latex

    add "run grammar.wy input" main for -procedural_*?

    Solution to left recurse is merge into one expression. See how
    that evaluates, make recursive do the same - use memo instead of
    apply rule.

    Need recurse_pos in case possibly empty nonterm is not empty -
    call apply rule if memo empty.

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


review fixmes

Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

propagate to main

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

Wisi syntax is not bison-like; it is BNF augmented with declarations, regexp, actions

add packrat error recover

compile ada_process_main still very slow on Debian
    compare to libadalang; larger files!
    one subprogram per state?w

dragon_4_43_packrat_gen.adb
    --  FIXME: why does Trace need a Descriptor?
    if it's just a convenient place to put it, move up to Parser
        check mckenzie first

delete action from tree.node?
    use table.productions.action
        table.productions not present in lalr no_recover, packrat
        may change to kernels in lalr recover?

    decouples actions from tree
        action params are tree nodes, but action can be declared in wisitoken.parse.

    adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

add *, +, ? to wisi_grammar?
    re-write to current syntax?
    closer to Ada appendix P

    * does not need recursion; shorter syntax tree
        require lalr, packrat generate same syntax tree so actions are the same
        option to violate that if not doing one or the other.

reorganize package hierarchy?
    wisitoken - truly common stuff
    wisitoken.parse - parser runtime
        .glr
        .packrat
            https://pdos.csail.mit.edu/~baford/packrat/thesis/
            http://bford.info/packrat/

    wisitoken.generate - represent grammar as production list, generate parse table
        .lalr
        .lr1 (still need to make it faster)
        .ll ?
    wisitoken.wisi - translate .wy files into production list, source code

    wisitoken.lexer - as now

    wisitoken.syntax_tree

constrain_terminals
    cache shift, reduce counts in table
    use dot
        store dot with productions in parse_state; lr1_item
    handle conflicts

    derive from LALR formalism?

update-wisi_grammar

change configure_access to persistent_ref record with container, node components;
    allow ref.delete to abort config; saves copying

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

update NEWS.text

do google search for "ada parser generator"
    add wisitoken to those sites

Fixed size stack speed mckenzie?
    init current to 50 was slightly slower

if full parse fails, go back to successful error recover and find more expensive solutions
    save full config_heap after successful error recover

do multi-cpu parsing?
    benefit depends on density, duration of conflicts
    errors are when speed is noticeable
    make shared_terminals task-safe; protected object for access to .Last_Index, Add
    move lexer data to shared_terminals


cache recover for subsequent parse?

still losing memory?
    possibly Augmented_Token_Array
        deallocation thru root class type?

    run_ada_lite_parser wisi/test/ada_lite.input with gnatmem
        no change in leaks from repeat count 1 to repeat count 2

    run ada on gnatcoll-xref
        allocation root 1 increased by (- 167.88 165.12) = 2.76 kilobytes

    run ada_mode_wisi_parse on test/gnatcoll-xref.adb
        (setq ada-process-parse-exec "c:/Projects/org.emacs.ada-mode.stephe-2/exec_pro/ada_mode_wisi_parse.exe")
        (setq wisi-process--alist nil)
        (setq ada-process-parse-exec "ada_mode_wisi_parse")
        doesn't create gmem.out; using wrong exec!
            need to rerun ada-mode, not just parse
            still wrong! using cached parser wisi-process--alist on label Ada
            still no gmem.out

        running wisi-parse-buffer and watching task manager shows no memory increase. sigh.
        watch memory while editing other files
        wait for compute indent in ada

improve mckenzie
    focus on real use cases that are slow; document in ada-mode/test

    exec_pro/ada_lite_run.exe 10 c:/Projects/org.emacs.ada-mode.stephe-2/test/slow_recover_1.adb
         1: mckenzie enqueue 540, check  69; succeed : 8, (18 : IDENTIFIER, )|OR|/THEN, IF, IDENTIFIER/
         1: mckenzie enqueue 1373, check  181; succeed : 8, (196 : END, )|IDENTIFIER|/IF, SEMICOLON, END, IF, SEMICOLON, END/
        ada_lite-slow_recover_1.profile
            top total time functions:
  0.00      0.09     0.00   231856     0.00     0.00  wisitoken__parser__lr__parser_stacks__element_arrays__finalize__2
  0.00      0.09     0.00   231855     0.00     0.00  wisitoken__parser__lr__parser_stacks__stack_typeDF__2

    try lr1 ada_lite
        slow but tolerable wisi-generate time
            83 rules, 1 actions, 2612 states, 20615 table entries
            0 accept/reduce conflicts, 3 shift/reduce conflicts, 6 reduce/reduce conflicts
        gcc gives up; gnat1.exe: out of memory allocating 4072 bytes
            need to read table from file.

    include current state and current token in cost function:
        cost of "125 | then | elsif" = 0
        125 implied by trying 'then' without preceding 'if'

    config_queue:
        Fibonacci heap

    for each state, pre-compute shortest list of tokens (term/nonterm) to finish each nonterm
        test/terminal_sequences_1.adb
        If any contain next token, queue that fragment.
        use case: start typing a statement, hit enter
            => error correction finishes statement with minimum token count.
            but this case is not slow now;
                'if a = 5 then' => queue 90

    prune duplicate/higher cost configs?
        only needed for higher cost levels

    cost for pop empty nonterm should be zero
        need byte_range in parser
            could get it from semantic_state, unless pending.
        wait til we find a test case that needs it


new test cases:

    ----------
    target : constant string := "
        triggers face parse

    ----------
    Target : constant Unbounded_Wide_String := To_Unbounded_Wide_String "&ndash;";
        two errors close together?


    ----------
   procedure Process_Text_File (File_Name ; in String);
   is
   begin
   end Process_Text_File;
   noticeable delay: mckenzie (max cost 12) enqueue 138756, check  10931; fail
    correct solution is delete ';', insert ':' - cost 8, then later delete ;
    two errors too close together
    check_limit = 2 fixes it; set that in projects.text


----------

some tokens don't count towards check_limit, because we should always check the next token:
    END, DOT
    covers 'end if/loop/case/return/name', name.name

if hit enqueue_limit, use config that has highest check_token_count
    save in config

Emacs_ada does not need descriptor.image?

next change in wisi/test/*.good_parse_table
    don't output mckenzie if default

Merge cursor, parser_node_access

replace wisitoken.token.list with token_array
    or not; changes generate?
    ditto production.list

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


other mckenzie stuff
    search dpa backwards from elsif; insert 'if then'
        same result as Grune 326 graph search; do that?

        terminal_sequences_2.adb
        states that shift ELSIF:
            168 if_statement <= IF expression_opt THEN sequence_of_statements_opt ^ elsif_statement_list
            187 elsif_statement_list <= elsif_statement_list ^ elsif_statement_list
            need list/tree/hash of states that shift ID, sorted on ID

        'goto state 187' is in 168 on elsif_statement_list

        'goto state 168' is in
            159 if_statement <= IF expression_opt THEN ^ sequence_of_statements_opt * on sequence_of_statements_opt
            need list/tree/hash of states that goto state, sorted on goto state

        'goto state 159' is in 128 'if_statement <=' on shift THEN => insert THEN
            ditto

        'goto state 128' is in 100 'if_statement <= IF ^ ' on expression_opt
            ditto

        'goto state 100' is in many, on 'shift IF' => insert IF, terminate

        search all productions in 'declarations', 'statements'?
            start with final terminal, work backward to first

    test lr1 vs lalr tables
        ada_lite.lr1_parse_table
        10 times the states, table entries

    include actual token count in nonterminal pop cost?
        requires cumulative token count on parser stack

speed up
    profile parsing gnatcoll-xref

    stack compare
        override "=" to start comparison at stack top; most likely to be different

    replace look on ID calling action_for with iterate action list for state

    use tasks for multi-processor?

    compress parser table via default reduce?

    set initial capacity on stacks

    check_reduce does not need to copy stack
        just keep track of current top separately, pointer into reduced top

    during parallel error recovery, if one parser finds a solution, limit cost of others to solution cost + 2?
        doesn't help if first parser fails

automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

wisi-generate accept two output languages
    a lot is shared
    only need ada_output, but it doesn't hurt

wisi-generate lr1 way too slow for Ada
    time lalr generating Ada
    time lr1 generating ada_lite
    time lr1 generating Ada to first 1000 states; increase as it gets better

    implement profile, get data

    lookahead list vs boolean array:

    closure needs:
        use multiple CPUs?

    LR1_Item_Sets needs:
        fast find (set, states)
            => Store state_index in red/black tree sorted on concat prod_count/LHS/RHS/dot position
                first try done; need better key?
                get histogram of full closure set

    need more warm-fuzzy
    command line option
    dots for "adding state n", n every 100
    dots for "lookaheads state n", n every 100?
    dynamically monitor how long things take, keep dot time period constant
        everything slows down as more states added

integrate with emacs module

 build/release_process.text

# end of file
