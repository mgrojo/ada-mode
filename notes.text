build/Makefile

branches:
org.wisitoken/o.s_l.sal                   - main, used by o.e.a
org.wisitoken.stephe-1/o.s_l.sal.stephe-1 - misc devel for o.w, o.e.a.s-* ; delete support for out_of_order_ops
org.wisitoken.stephe-2/o.s_l.sal.stephe-1 - implement syntax_trees.Insert_Token

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext.stephe-1")
  (xgit . "/Projects/org.stephe_leake.sal.stephe-1")
  (xgit . "/Projects/org.wisitoken.stephe-1")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

update-wisitoken_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
compile with GNAT Pro 21.0w 20200426
    but use gnat 20.2 for gpr_query, ada_parse
        wisi-prj can't cope with that

    (gnat-pro-21.0w-20200426)
    (shell-bash)
    (sal-standard)

    in shell:
    export GPR_PROJECT_PATH="/Projects/org.stephe_leake.sal.stephe-1/build:/Projects/org.stephe_leake.aunit_ext.stephe-1/build:/Projects/org.stephe_leake.makerules"
    cd build
    make t_all
    build/Makefile - set project


wisitoken-generate-lr.adb Add_Actions FIXME:
    doesn't use Goto_List for terminals!
    Goto_List _does_ contain terminals
        use them instead of other code in Add_Actions

-explore.check
         --  FIXME: if there were conflicts, enqueue them; they might yield a
         --  cheaper or same cost solution?
         same code as fast_forward; just use that?

        see if parsing all affects any tests

        item.shift_count not used

String_literal, numeric_literal, identifier are equivalent - only insert one
    minimal_complete does this for expression

test/ada_mode-recover_31.adb
    language_fixes changes char_literal '|-' to string_literal; ok for first call on real error

    but later, it gets a config where Error_Token is set by Parse.Parse
        with min_terminal_index = invalid_token_index, virtual = true

    because in Parse.Parse_One_Item, Current_Token is a Base_Token, which does not have Token_Index
        use parser_state.current_shared_token?
        or change Current_Token to Recover_Token?


error_correction_algorithm.tex
    full vs partial_recursion
        java_expressions_antlr_lr1
        full:
            state 34 mca => RPAREN 30.4
            state 56, 126, 140 Minimal_Complete_Action => (RPAREN 30.4, DOT 31.4)
        partial
            state 34 mca => (RPAREN 30.4, DOT 31.4)
            state 56, 126140    Minimal_Complete_Action => RPAREN 30.4
                31.4 appears to be other_left

    forbid push_back:
        if push_back over insert/delete, get duplicate results
        can push_back into fast-forward:
            1 do large push_back, insert/delete there
            2 fast forward to orig error point
            3 do small push_back, insert/delete there
                useful for fixing 'end *;' errors in Ada.
                t_mck Error_3.

    doc Just_Pushed_Back_Or_Deleted
        required because do insert last
        try_delete also checks for just_inserted
        check multiple ops
        duplicate_state does not eliminate these because '(delete
            end)(insert end)' replaces a real token with a virtual
            token, which changes the buffer region on the nonterms.

    explain check_reduce_to_start

    In Check, "made some progress" does _not_ mean "closer to
    Resume_Token_Goal than _original_ config"; it means "moved away
    from the edit point".
        if the "progress" is only shifting tokens that were previously
        pushed_back, that's a waste. Which is why we don't check
        configs that would lead to that.

    redo examples with partial recursion
        causes problems?

    doc Minimal_Complete done?

    see comments in .tex file

    test and/or prove Nullable

    redo compare using lr1 for wisitoken-tokens
        add ANTLR  https://github.com/Alex-Gamper/Ada-Grammar.git
        add tree-sitter https://tree-sitter.github.io/tree-sitter/using-parsers
            has python parser
            java?
            add ada parser

    compare size of ada_lr1.txt

    compare speed of recover

    LALR vs LR1
        test_mckenzie_recover
            String_Quote_2
            String_Quote_5
            Two_Missing_Ends enqueue 50 vs 101
            Do_Delete_First 280 vs 202
            Two_Parsers 18 vs 55
            Match_Selected_Component_1

    Get Ludovic to enable --recover-log, publish real data from production environment.

   - search Google scholar for partial parse

   - ask for review
     - Stefan Monnier
     - Emmanual Briot
     - adacore adalang people
     - Laurent? peg/packrat expert

   - publish in some ACM journal?
     McKenzie in ACM Transactions on Programming Languages and Systems
     Fischer/Mauney in  Acta Informatica Springer

wisitoken user guide mention concrete syntax tree

terminate duplicate_state missed one
    convert_if_to_case.ada_lite
task 0 3: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (25 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
task 0 2: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (23 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
    should have terminated one!

If state has multiple identicle reduce, just reduce - don't try all reduce, shift; most waste of time.
    Use different action representation?

Parse for font wants a faster error correction algorithm
    do push back & delete nonterm

recover.Explore.Insert_From_Action_List
    if multiple identical reductions, just reduce
        test_mckenzie_recover.adb Zombie_In_Resume

ada_lite LALR state 149 inserts recursive token!
    String_Quote_4 got a lot more enqueue
            because it doesn't know it's the recursive token
            length_after_dot is correct
            if change to Other, it will be done at runtime anyway

            following inserts make it more expensive, but don't follow recursion, because it's not minimal

        recursion loop:
        60.0: association_opt <= IDENTIFIER EQUAL_GREATER expression_opt ; ( 3 => Other_Right)
        88.0: expression_opt <= expression ; ( 1 => Other_Left)
        87.0: expression <= relation ; ( 1 => Other_Left)
        122.1: relation <= simple_expression ; ( 1 => Other_Left)
        127.1: simple_expression <= term_list ; ( 1 => Other_Left)
        137.1: term_list <= term ; ( 1 => Other_Left)
        136.1: term <= factor ; ( 1 => Other_Left)
        91.0: factor <= primary ; ( 1 => Other_Left)
        113.2: primary <= name ; ( 1 => Other_Left)
        103.1: name <= name actual_parameter_part ; ( 1 => Direct_Left,  2 => Direct_Right)
        57.0: actual_parameter_part <= LEFT_PAREN association_list RIGHT_PAREN ; ( 2 => Other)
        61.1: association_list <= association_opt ; ( 1 => Other_Left)

        break recursion - look for alternate RHS for each LHS in recursion:
        60.2: association_opt <=
        88.1: expression_opt <=
        113.0: primary <= NUMERIC_LITERAL
        149: 103.2:name <= IDENTIFIER ^

    ada_lite 154 all left recursive

    ada_lite_ebnf_lalr.parse_table same
        state 110, 130, 152, 186, 264

        state 157 currently has no action; should be 95.0

    case_expression_lalr_re2c.parse_table, _lr1
        state 4, 9

    body_instantiation_conflict_lr1.parse_table
        state 7, 17

    java_expressions_antlr_lr1.parse_table
        state 19 should drop 32.0
        state 28 29.x reduces to primary; 31.3 ultimately shorter
        state 97 all direct_left
        state 140 keep 31.4?


improve mismatched paren checks in actions
    maybe just in wisitoken_grammar_mode?
        only active if mmm-mode recognizes action; improve that?
    partial parse in ada.wy?

use duplicate_reduce in text_rep

allow undo_reduce after insert/fast_forward
    in Recover, processing ops
        need test case; ada_mode.recover_25 with language_fix that does not push_back declarative_part_opt
        ada_mode-recover_27.adb uses Undo_Reduce (to allow 'insert loop'), but not after insert.
        if no useful test cases, delete Try_Undo_Reduce, and doc why.
        or add None_At_All (Insert) to try_Undo_Reduce.

check should check all conflicts, enqueue conflicts on success
    otherwise we are ignoring possible solutions.

test_mckenzie use lr-parser-gen_aunit

change to incremental parse
    integrate with tree-sitter?

make "canonical list" compatible with packrat?
    ie swap rhs_index 0, 1
    better to implement list in packrat

c:/Projects/org.emacs.java-wisi/test/recover_001.java
    don't delete next if minimal_c_a inserted

    minimal_complete_actions isn't globally minimal
        state 245 could use
            classOrInterfaceType <= IDENTIFIER
            lambdaParameters <= IDENTIFIER
            primary <= IDENTIFIER
            classType <= IDENTIFIER

            picks first = classOrInterfaceType => inserts .class,  reduces to primary
            find that in a post-optimize step?

Python
    c:/Projects/org.emacs.python-wisi/python.wy
    need INDENT, DEDENT in lexer
    no other new syntax
    only one state with more than two actions
    reduce conflicts by recognizing canonical list in local_stmt (correctly)
    improve process_main compile time
        reduce number of statements in each subprogram
        or use text_rep

lalr generator bug
    long term fix; reimplement lalr using deremer, penello 1982
    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
                could include sequence of empty nonterms in first_nonterm_set, return two goto_sets
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

re2c now has --location-format <gnu | msvc>
    Apr 2019 in devel, not release

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

enqueue_limit should be for total over all parsers; more consistent max time
    need test case?

Error messages need gen_alg prefix - add to Error_message

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

can generate code for LR parser, rather than using table
    see Google drive/Parsing/notes
    screws up recover because parse stack = cpu stack; not accessible?

try packrat indirect recursion solution
    see paper by laurent, mens
        in ebooks/parsing, google drive
        used in https://tatsu.readthedocs.io/

    docs/indirect_recursion_in_packrat.latex
        finish it

    add "run grammar.wy input" main for -procedural_*?

    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

   - https://arxiv.org/pdf/1806.11150 error recovery for PEG
     compares LPegLabel to ANTLR, on synthetic errors


compare to bison times

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

add packrat error recover
    "d:/Books/eBooks/Parsing/Fischer Mauney 1992 - Simple fast LL1 error repair.pdf"
    assumes no backtracking?
        pg 112: "parser announces error when prediction does not fit next input"

adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
