build/Makefile

 current work
better syntax error handling
    "d:/Books/eBooks/Parsing/Grune 321 - Error repair in shift reduce parsers.pdf"

    rename mckenzie to dpa_explore?
        dpa = deterministic parsing automata (McKenzie)
            = Deterministic Pushdown Automata (Wikipedia, Grune)

        aflex uses "dfa" deterministic finite automata
        grune also uses 'deterministic fs automata' (Finite State)

        includes special rules

    t_one RUN_ARGS=1
        Error_5
            deleted 'if then'

            new algorithm 1:
                if error symbol is in a terminal sequence:
                        need fast lookup; use linear search for now
                    find first terminal in sequence that is in follow (current state)
                    insert that terminal, subsequent to error sybmol

                code data structure for output of terminal_sequences by hand for if_statement
                code special function, see if it works

            new algorithm 2:
                adjust mckenzie costs to include terminal sequences
                include current_token in cost function
                    cost of "if then | elsif" = 0.0

                include current state and current token in cost function:
                    cost of "125 | then | elsif" = 0
                    125 implied by trying 'then' without preceding 'if'


            two ways to build terminal sequences:
                search dpa backwards from elsif; insert 'if then'
                    the only state that shifts elsif is 184 elsif_statement_list <=
                    the only 'goto state 184' is in 165 'if_statement <=' on elsif_statement_list
                    the only 'goto state 165' is in 156 'if_statement <=' on sequence_of_statements_opt
                    sequence_of_statements_opt includes empty, ... if_statement
                    the only goto 156 is in 125 'if_statement <=' on shift THEN => insert THEN
                    the only goto 125 is in 97  'if_statement <=' on expression_opt
                    expression_opt includes empty
                    many 'goto state 97'; all on 'shift IF' => insert IF, terminate

                    search all non-first keywords in 'declarations', 'statements'?

                process grammar to generate keyword sequences separated by empty nonterms
                    terminal_sequences.adb
                    need to recurse into nonterms
                        ie insert "elsif then" in 'if_statement'

    test with parallel parsers
        force a conflict
        don't terminate any if all fail
        _dont_ exit recover with first success; all parsers may succeed

    cache recover for subsequent parse

    test lr1 vs lalr tables
        ada_lite.lr1_parse_table
        10 times the states, table entries

    then to elisp parser?

    or Emacs module parser
        elisp lexer supports utf-8, other encodings; tick/char_literal

    Leaves some sections unindented - OK if not user line (not typical editing case).
        not uncached; if indent is not computed, cache is 0
        If indent cache 0, use previous line?
        see how it works in practice

    speed up
        replace look on ID calling action_for with iterate action list for state

        use tasks for multi-processor?

        compress parser table via default reduce?

wisi-generate accept two output languages
    a lot is shared
    only need ada_output, but it doesn't hurt

move output_ada_emacs, output_elisp to ada-mode source tree?
    extendable dispatch?

wisi-generate lr1 way too slow for Ada
    time lalr generating Ada
    time lr1 generating ada_lite (1634 states, tens of seconds)
    time lr1 generating Ada to first 1000 states; increase as it gets better

    implement profile, get data

    don't iterate on non-reporting

    lookahead list vs boolean array:
        time opentoken vs fasttoken
        or old fasttoken

    closure needs:
        fast access to all productions that have dot_id as the LHS
            => array (nonterminal) of list of prod

        fast access to First (beta) => array (nonterminal) of list of terminal

        use multiple threads?

    lr1_goto_transitions needs:
        fast closure
        cache?

        use optimizations from lalr_goto_transitions?

    LR1_Item_Sets needs:
        fast goto_transitions (state, token)
            => use cache; invalidate when ?

        fast find (set, states)
            => Store states in red/black tree sorted on concat LHS/dot position
                or hash table on that key
                    keeps changing, not clear if it's worth finding a perfect hash table
                each node has a list of states that differ only in lookahead
                => one for LALR

            c:/org.stephe-leake.misc/source/rb_tree_V0_1
                bounded, not generic, but proved by Spark
                at least use key_trees-test.adb Tree_Invariant for test
                use to generate test cases?

            c:/org.stephe-leake.sal/source/sal-gen_red_black.ads
                write tests

        no 'free'; don't allocate item on heap until we know we need it

    lalr_goto_transitions needs:
        fast find prod, dot in goto_set
            null result is common
            small set; linear search of list sorted on lhs

        fast access to all productions where:
            (Dot_ID = Nonterminal.ID (Prod.LHS) or First (Dot_ID)(Nonterminal.ID (Prod.LHS))) and
                       (RHS.first /= Null_Iterator and then ID (RHS.first) = Symbol)
            => array (nonterminal) of list of productions, sorted on rhs.first

    lalr_kernels needs:
        same as lr1_item_sets

    need more warm-fuzzy
    command line option
    dots for "adding state n", n every 100
    dots for "lookaheads state n", n every 100?
    dynamically monitor how long things take, keep dot time period constant
        everything slows down as more states added

    rename to opentoken7
        _not_ "fast" :(
        or speed it up

integrate with emacs module
    split out ada_grammar from ada_grammar_process, _module

some .wy in wisi_wy_test.adb, some in rules.make
    be more consistent
        easier to update in rules.make

ada_grammar.adb very slow to compile
    eliminating all but one action subprograms; not much help

    read state transitions from text file?
    -> .exe is independent of language

need better lexer for wisitoken
    handle tick character literal
    handle utf-8

    lexer used by libadalang?

need case insensitive flag in .wy
    use for keywords
    pass to lexers

Test case gathering - wisi fallback email first use each day.

lalr calls closure on each kernel more than once!
    save the closure the first time?

need to_token_wy_name
    for reporting conflicts

Ada lexer
    number:
        add _
        add leading integer to distinguish 16 from identifier

    identifier: add leading letter

review FIXME
    ./fasttoken-parser-lalr-parser.adb:346:            --  FIXME: free everything
        add Controlled to stuff

change dragon examples
    lexer.regexp; should be easy

    lexer.aflex/wisi-generate
        need support for different actions
        move code from tokens to actions
        change .wy action syntax to require {} (for elisp as well)
        use Ada code in actions; reference New_Token, Source, To_ID
            or whatever than changes to
        add Ada output language to wisi-generate
            just copy text between {} to action function
                add constant space prefix to each line; source must meet style check

change wisi tests to use Ada code?

 aflex
    /Projects/aflex/build/Makefile
    /Projects/aflex/aflex.adb
    source from http://sourceforge.net/projects/p2ada/

    better error messages; gnu syntax

    regenerate aflex.l
        start with flex.l?

# end of file
