build/Makefile

branches:
org.wisitoken          - main, used by o.e.a
org.wisitoken.stephe-1 - misc devel for o.w, o.e.a.s-*
org.wisitoken.stephe-2 - add EBNF syntax to .wy parser

(dvc-state-multiple
'((xmtn . "/Projects/org.stephe_leake.makerules")
  (xmtn . "/Projects/org.stephe_leake.aunit_ext")
  (xmtn . "/Projects/org.stephe_leake.sal.stephe-1")
  (xmtn . "/Projects/org.wisitoken.stephe-1")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

update-wisi_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
lalr generator bug
    lalr_generator_bug_01.wy
    trace generate

re2c now has --location-format <gnu | msvc>

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

delete "assume ignore semantic check is a solution"; only language_fixes knows that
    provide subprog to enqueue that in language_fixes

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

compare to bison

try packrat indirect recursion solution
    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    docs/indirect_recursion_in_packrat.latex

    add "run grammar.wy input" main for -procedural_*?

    Solution to left recurse is merge into one expression. See how
    that evaluates, make recursive do the same - use memo instead of
    apply rule.

    Need recurse_pos in case possibly empty nonterm is not empty -
    call apply rule if memo empty.

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

    adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

add packrat error recover

add *, +, ? to wisitoken_grammar
    o.w.s-2
    re-write to current syntax?
    closer to Ada appendix P

    * does not need recursion; shorter syntax tree
        require lalr, packrat generate same syntax tree so actions are the same
        option to violate that if not doing one or the other.

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
