build/Makefile

branches:
org.wisitoken          - main, used by o.e.a
org.wisitoken.stephe-1 - misc devel for o.w, o.e.a.s-*
org.wisitoken.stephe-2 - add EBNF syntax to .wy parser

(dvc-state-multiple
'((xmtn . "/Projects/org.stephe_leake.makerules")
  (xmtn . "/Projects/org.stephe_leake.aunit_ext")
  (xmtn . "/Projects/org.stephe_leake.sal.stephe-1")
  (xmtn . "/Projects/org.wisitoken.stephe-1")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

update-wisi_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
lalr generator bug
    short term fix; catch bad state, change action to error; o.w.s-1

    long term fix; reimplement lalr using deremer, penello 1982

    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

 0: 0:  1:(PROCEDURE, (1 . 9)) : shift and goto state 1
 [1 : PROCEDURE]
 0: 1:  2:(IDENTIFIER, (11 . 16)) : shift and goto state 5
 [5 : IDENTIFIER, 1 : PROCEDURE]
 0: 5:  3:(IS, (18 . 19)) : reduce 1 tokens to name
 [6 : name, 1 : PROCEDURE]
 0: 6:  3:(IS, (18 . 19)) : shift and goto state 10
 [10 : IS, 6 : name, 1 : PROCEDURE]
 0: 10:  4:(BEGIN, (21 . 25)) : shift and goto state 16
 [16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 0: 16:  5:(IDENTIFIER, (30 . 35)) : shift and goto state 5
 [5 : IDENTIFIER, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 0: 5:  6:(LEFT_PAREN, (37 . 37)) : reduce 1 tokens to name
 [30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 0: 30:  6:(LEFT_PAREN, (37 . 37)) : shift and goto state 11
 [11 : LEFT_PAREN, 30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 0: 11:  7:(IDENTIFIER, (38 . 38)) : spawn 1, (2 active)

 1: 11:  7:(IDENTIFIER, (38 . 38)) : reduce 0 tokens to unary_adding_operator_opt
 [26 : unary_adding_operator_opt, 11 : LEFT_PAREN, 30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 1: 26:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 5
 [5 : IDENTIFIER, 26 : unary_adding_operator_opt, 11 : LEFT_PAREN, 30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 1: 5:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name
 [36 : name, 26 : unary_adding_operator_opt, 11 : LEFT_PAREN, 30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]

 0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 19
 [19 : IDENTIFIER, 11 : LEFT_PAREN, 30 : name, 16 : BEGIN, 10 : IS, 6 : name, 1 : PROCEDURE]
 0: 19:  8:(RIGHT_PAREN, (39 . 39)) : error


        State 18:
             19.0:association <= IDENTIFIER ^ EQUAL_GREATER expression, RIGHT_PAREN
             23.1:name <= IDENTIFIER ^, LEFT_PAREN/RIGHT_PAREN

        bison does not have this state

        State 22:
         23.0:name <= name ^ actual_parameter_part, LEFT_PAREN/RIGHT_PAREN
         25.0:primary <= name ^, RIGHT_PAREN

    lalr_generator_bug_02.wy => no error
        parser 0 looking for         19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ... (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : ERROR

        State 18:
             19.0:association <= IDENTIFIER ^ EQUAL_GREATER expression, RIGHT_PAREN
             23.1:name <= IDENTIFIER ^, LEFT_PAREN/RIGHT_PAREN

        State 22:
             23.0:name <= name ^ actual_parameter_part,


    generator not chasing production chain far enough

re2c now has --location-format <gnu | msvc>

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

delete "assume ignore semantic check is a solution"; only language_fixes knows that
    provide subprog to enqueue that in language_fixes

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

compare to bison

try packrat indirect recursion solution
    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    docs/indirect_recursion_in_packrat.latex

    add "run grammar.wy input" main for -procedural_*?

    Solution to left recurse is merge into one expression. See how
    that evaluates, make recursive do the same - use memo instead of
    apply rule.

    Need recurse_pos in case possibly empty nonterm is not empty -
    call apply rule if memo empty.

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

    adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

add packrat error recover

add *, +, ? to wisitoken_grammar
    o.w.s-2
    re-write to current syntax?
    closer to Ada appendix P

    * does not need recursion; shorter syntax tree
        require lalr, packrat generate same syntax tree so actions are the same
        option to violate that if not doing one or the other.

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
