build/Makefile

branches:
org.wisitoken          - main, used by o.e.a
org.wisitoken.stephe-1 - misc devel for o.w, o.e.a.s-*
org.wisitoken.stephe-2 - add EBNF syntax to .wy parser

(dvc-state-multiple
'((xmtn . "/Projects/org.stephe_leake.makerules")
  (xmtn . "/Projects/org.stephe_leake.aunit_ext")
  (xmtn . "/Projects/org.stephe_leake.sal.stephe-1")
  (xmtn . "/Projects/org.wisitoken.stephe-2")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-2")))

update-wisi_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
add EBNF
    handle deeply nested ebnf nodes; see FIXME

    replace %keywords with string literals

    add ANTLR syntax for java

    add ? syntax for Python

lalr generator bug
    long term fix; reimplement lalr using deremer, penello 1982
    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

re2c now has --location-format <gnu | msvc>

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

test_mckenzie use lr-parser-gen_aunit

recover still hanging on exception in worker_task
    but get no output in *Ada_wisi_parse*, not even parse command
    only symptom is "not getting more text", several times, from jit-lock
    some previous command hung, later commands wiped its output?
        parser-busy is supposed to prevent that

declare recover tasks at package level
    reuse them in recover
    o.w.s-1

take Dot into account when finding min?
    best metric is min remaining to insert
        won't make much difference; only matters when dot is not near beginning, but then don't have multiple productions (they all must have same prefix)

delete "assume ignore semantic check is a solution"; only language_fixes knows that
    provide subprog to enqueue that in language_fixes

enqueue_limit should be for total over all parsers; more consistent max time
    need test case?

hint in grammar to prefer "null;" over "return;" in minimal-terminal-sequence?
    ada: IDENTIFIER for 'name', not string_literal = operator
    %prefer_minimum_terminal <nonterm> <terminal>


Error messages need gen_alg prefix - add to Error_message

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

compare to bison

set lines_per_subr on wisitoken command line
    optimize for ada_lite, ada

lr1 only store kernels?
    find other documentation of lr1 algorithm
    just adding 'filter in_kernel' in lr1_item_sets causes infinite loop or big slowdown.

distinquish between reset for lex, reset for execute_actions.
    wisi_grammar don't reset command line args?

add delete to config heap, use when configuration_access is abandoned?

can generate code for LR parser, rather than using table
    see Google drive/Parsing/notes

try packrat indirect recursion solution
    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    docs/indirect_recursion_in_packrat.latex

    add "run grammar.wy input" main for -procedural_*?

    Solution to left recurse is merge into one expression. See how
    that evaluates, make recursive do the same - use memo instead of
    apply rule.

    Need recurse_pos in case possibly empty nonterm is not empty -
    call apply rule if memo empty.

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

compare to bison times

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

add packrat error recover

adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
