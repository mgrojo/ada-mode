build/Makefile

branches:
org.wisitoken/o.s_l.sal                   - main, used by o.e.a
org.wisitoken.stephe-1/o.s_l.sal.stephe-1 - speed up lr1
org.wisitoken.stephe-2/o.s_l.sal.stephe-1 - Translate_EBNF recognize more canonical lists

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal")
  (xgit . "/Projects/org.wisitoken")))

(dvc-state-multiple
'((xgit . "/Projects/org.stephe_leake.makerules")
  (xgit . "/Projects/org.stephe_leake.aunit_ext")
  (xgit . "/Projects/org.stephe_leake.sal.stephe-1")
  (xgit . "/Projects/org.wisitoken.stephe-2")))

(dvc-propagate-multiple
 '(("../org.stephe_leake.sal" . "../org.stephe_leake.sal.stephe-1")
   ("../org.wisitoken"        . "../org.wisitoken.stephe-1")))

update-wisitoken_grammar
(dvc-propagate-multiple
 '(("../org.stephe_leake.sal.stephe-1" . "../org.stephe_leake.sal")
   ("../org.wisitoken.stephe-1"        . "../org.wisitoken")))

 current work
error_correction_algorithm.tex
    need title
        \title, \author not working!?

    get mckenzie log of figure 3 recursive_length_after_dot
        minimal_complete_recursive_length_after_dot.java_exp_ch19
        treatment of recursion changed since that text was written

    recursion in minimal_complete
        Here the production is labeled \code{recursive}, because it is part of
        a recursion cycle in the grammar. The grammar in this example is a
        subset of Java; the productions involved in this recursion cycle are:
        \begin{verbatim}
        Assignment           <= LeftHandSide ^ EQUAL Expression
        Expression           <= LambdaExpression  | AssignmentExpression
        AssignmentExpression <= AdditiveExpression | Assignment
        \end{verbatim}
        This says that an \code{Expression} in this grammar can be \code{A :=
          B := C := 1}. Thus it makes no sense for \code{Minimal\_Complete} to
        insert \code{:=}; that will never result in a minimal length. In
        general, recursive productions are never minimal length, so
        \code{Minimal\_Complete} drops them when computing the actions, unless
        all the productions in a kernel are recursive. Then the recursion is
        ignored, and all the actions are queued; one of the later states will
        break the recursion. Note that since we normally set
        the cost of a \code{Minimal\_Complete} step negative, we cannot rely
        on cost to eliminate recursive productions.

    full vs partial_recursion
        java_expressions_antlr_lr1
        full:
            state 34 mca => RPAREN 30.4
            state 56, 126, 140 Minimal_Complete_Action => (RPAREN 30.4, DOT 31.4)
        partial
            state 34 mca => (RPAREN 30.4, DOT 31.4)
            state 56, 126140    Minimal_Complete_Action => RPAREN 30.4
                31.4 appears to be other_left

    forbid push_back:
        if push_back over insert/delete, get duplicate results
        can push_back into fast-forward:
            1 do large push_back, insert/delete there
            2 fast forward to orig error point
            3 do small push_back, insert/delete there
                useful for fixing 'end *;' errors in Ada.
                t_mck Error_3.

    doc Just_Pushed_Back_Or_Deleted
        required because do insert last
        try_delete also checks for just_inserted
        check multiple ops
        duplicate_state does not eliminate these because '(delete
            end)(insert end)' replaces a real token with a virtual
            token, which changes the buffer region on the nonterms.

    explain check_reduce_to_start

    In Check, "made some progress" does _not_ mean "closer to
    Resume_Token_Goal than _original_ config"; it means "moved away
    from the edit point".
        if the "progress" is only shifting tokens that were previously
        pushed_back, that's a waste. Which is why we don't check
        configs that would lead to that.

    redo examples with partial recursion
        causes problems?

    doc Minimal_Complete done?

    see comments in .tex file

    test and/or prove Nullable

    redo compare using lr1 for wisitoken-tokens
        wisitoken both ada.wy and ada_annex_p.wy
        Bison?
        add ANTLR  https://github.com/Alex-Gamper/Ada-Grammar.git
        add tree-sitter https://tree-sitter.github.io/tree-sitter/using-parsers
            has python parser
            java?
            add ada parser, both ada.wy and ada_annex_p.wy

    compare size of ada_lr1.txt

    compare speed of recover

    LALR vs LR1
        test_mckenzie_recover
            String_Quote_2
            String_Quote_5
            Two_Missing_Ends enqueue 50 vs 101
            Do_Delete_First 280 vs 202
            Two_Parsers 18 vs 55
            Match_Selected_Component_1

    Get Ludovic to enable --recover-log, publish real data from production environment.

   - search Google scholar for partial parse

   - ask for review
     - Stefan Monnier
     - Emmanual Briot
     - adacore adalang people
     - Laurent? peg/packrat expert

   - publish in some ACM journal?
     McKenzie in ACM Transactions on Programming Languages and Systems
     Fischer/Mauney in  Acta Informatica Springer
     Stefan Monnier paper on SMIE in  https://programming-journal.org/

LR1 algorithm.tex:
    super needs C_Tree to compute unique state numbers.
    w workers
    worker gets N states, returns M new
    of which Md are also found by other workers before wi are processed
    super searches/inserts M states in 1 trees, (M - Md) in w trees.
    when average M << N (later in process), worker search dominates super insert => parallel wins,
    when average M >> N, super insert into w workers dominates worker search
    ada.wy states: 469_463
        rows:     113; initial item sets time: 178.?
        rows:     467; initial item_sets time: 168.460805229, max_row_depth: 14 average_row_depth: 13
        rows:    1877; initial item_sets time: 165.346752806, max_row_depth: 12 average_row_depth: 10
        rows:  62_039; initial item_sets time: 163.757085680, max_row_depth: 9 average_row_depth: 4
        rows: 124_087; initial item_sets time: 161.564576128, max_row_depth: 9 average_row_depth: 2
        rows: 248_177; initial item_sets time: 163.082249550, max_row_depth: 9 average_row_depth: 1

output min_complete fraction in .parse_table - changed when recursion blew up?

Syntax tree nonterm node child array in two pieces - fixed for <5 and dynamic for >5

need gnat-prep for tree-sitter
    most devels won't have it

add tree-sitter parser, lexer
    tree-sitter still not getting comments right
        try updating tree-sitter from github
        try 'tree-sitter parse'

    tree-sitter generate supposed to report conflicts
        then w-b-g needs to declare conflicts with 'conflicts:' in grammar

    translate tree-sitter parse tree to wisitoken?
        api.h has root, node_children,  etc.

    time parts of generate tree_sitter; seems slow on ada_annex_p

    need to_grammar for actions
        which needs all tokens defined
        and is done before translate_to_tree_sitter is done
        so do subset of translate_to_bnf
            allow to_grammar to call execute_actions and declare the tokens.
            preserve token numbers for actions
            build the actions

improve bnf generation
    copy/preserve trailing comments on ebnf nodes
        ada_ebnf.wy ";; end of file"
        python_ebnf_bnf.wy
            atom: forced terminating semicolon should be before trailing comment

    java_ebnf.wy Statement
        inline expand ()

    java_types_ch19.wy Dims top level is canonical list, list_element = Annotation_list LEFT_BRACKET RIGHT_BRACKET
        requires adding 'empty' to Annotation_list instead of inserting optional rhs
        or first phase of extracting common sequences.

    python.wy
        decorated: decorators (classdef | funcdef | async_funcdef)
            expand group locally
            helps if user needs to copy bnf output to .wy for actions

        testlist_star_expr use names from alt_list for nonterminal

        try_stmt: indent +1 for paren

        classdef: don't copy newline in insert_optional?

   separate pass to eliminate single-token productions
       ada_annex_p explicit_generic_actual_parameter ::= expression
       also have to edit conflicts, or user will be confused
       output substitutions so user can do them

write Python INDENT, DEDENT as re2c code

delete descriptor.case_insensitive?
    used in regexp lexer?
    move to lexer?

syntax_trees.Replace_Child
    update cached data as in Set_Children

-explore.check
         --  FIXME: if there were conflicts, enqueue them; they might yield a
         --  cheaper or same cost solution?
         same code as fast_forward; just use that?

        see if parsing all affects any tests

        item.shift_count not used

String_literal, numeric_literal, identifier are equivalent - only insert one
    minimal_complete does this for expression

test/ada_mode-recover_31.adb
    language_fixes changes char_literal '|-' to string_literal; ok for first call on real error

    but later, it gets a config where Error_Token is set by Parse.Parse
        with min_terminal_index = invalid_token_index, virtual = true

    because in Parse.Parse_One_Item, Current_Token is a Base_Token, which does not have Token_Index
        use parser_state.current_shared_token?
        or change Current_Token to Recover_Token?

redesign parse table to speed recovery
    group identical reduce actions
        ada_mode-recover_02.adb
        only do each reduce once, then insert lots of terminals

rename "semantic checks" to "in-parse actions", others to "post-parse actions".

wisitoken user guide mention concrete syntax tree

terminate duplicate_state missed one
    convert_if_to_case.ada_lite
task 0 3: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (25 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
task 0 2: (2891 : 20:(SEMICOLON, (145 . 145)), 2865 : 19:(IF, (143 . 144)), 2817 : 18:(END, (139 . 141)), 2724 :(sequence_of_statements, (97 . 137)), 2646 : 13:(ELSE, (89 . 92)), 2505 :(sequence_of_statements, (49 . 87)), 2351 : 7:(THEN, (41 . 44)), 2090 :(expression_opt, (23 . 39)), 1701 :(IF), 1216 :(EQUAL_GREATER), 783 :(NUMERIC_LITERAL), 368 :(WHEN), 169 : 3:(IS, (20 . 21)), 45 :(expression_opt, (6 . 18)), 1 : 1:(CASE, (1 . 4)), 0 :)
    should have terminated one!

java-ch19.wy TryStatement has optional statement-end
    need override on previous tokens

improve mismatched paren checks in actions
    maybe just in wisitoken_grammar_mode?
        only active if mmm-mode recognizes action; improve that?
    partial parse in ada.wy?

use duplicate_reduce in text_rep

allow undo_reduce after insert/fast_forward
    in Recover, processing ops
        need test case; ada_mode.recover_25 with language_fix that does not push_back declarative_part_opt
        ada_mode-recover_27.adb uses Undo_Reduce (to allow 'insert loop'), but not after insert.
        if no useful test cases, delete Try_Undo_Reduce, and doc why.
        or add None_At_All (Insert) to try_Undo_Reduce.

test_mckenzie use lr-parser-gen_aunit

change to incremental parse
    integrate with tree-sitter?

    change syntax tree; store lists in a single node
        what does tree_sitter do?
        needs syntax in .wy to indicate a list
            ebnf recognize canonical list might be enough
        fewer nodes in syntax tree; should be faster (for large files)
            push_back part of a list?
        simplifies syntax tree editing (translate_ebnf)

make "canonical list" compatible with packrat?
    ie swap rhs_index 0, 1
    better to implement list in packrat

c:/Projects/org.emacs.java-wisi/test/recover_001.java
    don't delete next if minimal_c_a inserted

    minimal_complete_actions isn't globally minimal
        state 245 could use
            classOrInterfaceType <= IDENTIFIER
            lambdaParameters <= IDENTIFIER
            primary <= IDENTIFIER
            classType <= IDENTIFIER

            picks first = classOrInterfaceType => inserts .class,  reduces to primary
            find that in a post-optimize step?

Python
    c:/Projects/org.emacs.python-wisi/python.wy
    need INDENT, DEDENT in lexer
    no other new syntax
    only one state with more than two actions
    reduce conflicts by recognizing canonical list in local_stmt (correctly)
    improve process_main compile time
        reduce number of statements in each subprogram
        or use text_rep

lalr generator bug
    long term fix; reimplement lalr using deremer, penello 1982
    lalr_generator_bug_01.wy => error
        parser 0 looking for 19.0:association <= identifier => expression
         0: 10:  7:(IDENTIFIER, (38 . 38)) : shift and goto state 18
         0: 18:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to name ...   (state 10) goto state 22
         0: 22:  8:(RIGHT_PAREN, (39 . 39)) : reduce 1 tokens to primary... (state 10) goto state -1

        state 10 missing goto for primary, because that's an error;
        the only choice would be goto state 36, but there's no
        unary_adding_operator_opt on the stack.

        state 22 should not have both 23.0 and 25.0
            but lalr_goto_transitions clearly does that
                could include sequence of empty nonterms in first_nonterm_set, return two goto_sets
            compare to bison lalr_generator_bug_01.bison_table
            parse .input using bison table
            bison state 36 is the same

re2c now has --location-format <gnu | msvc>
    Apr 2019 in devel, not release

c:/eurocontrol/query_display-flight_operations.adb
    errors cause huge slowdown in parse speed
        due to parallel parse, delete_dup?

    do multi-cpu parsing?
        benefit depends on density, duration of conflicts
        errors are when speed is noticeable

enqueue_limit should be for total over all parsers; more consistent max time
    need test case?

Error messages need gen_alg prefix - add to Error_message

capture diff between lr1, lalr recover
    ./ada_lite_lalr_run.exe -m 1 -t 1
    ada_lite_recover_repeatable.input:45:
        package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;
        lr1: reports syntax error, all 4 parsers find solutions quickly
        lalr: reports match_names_error, two parsers fail on cost

        similar on line 47; lalr finds no solutions

can generate code for LR parser, rather than using table
    see Google drive/Parsing/notes
    screws up recover because parse stack = cpu stack; not accessible?

try packrat indirect recursion solution
    see paper by laurent, mens
        in ebooks/parsing, google drive
        used in https://tatsu.readthedocs.io/

    docs/indirect_recursion_in_packrat.latex
        finish it

    add "run grammar.wy input" main for -procedural_*?

    adding head, grow_set to Parser
        must be on a stack for nested recursion?

    test with optional unary minus

    warth_left_recurse_expr_1.adb : Test_Parse_Proc

    trying to implement full warth, but it's missing stuff, and some makes no sense
        try https://github.com/alexwarth/ometa-js
        or figure out what it must do; ie understand the algorithm

    try S Medeiros, F Mascarenhas, R Ierusalimschy 2014 Left recursion in parsing expression grammars.pdf
        very similar, mentions "memoization scope", doesn't say how to detect recursion

    or adapt langkit with pre-computed indirect


Implement Redziejowski language hiding check

add packrat to ada-mode s-4
    time, compare to langkit

   - https://arxiv.org/pdf/1806.11150 error recovery for PEG
     compares LPegLabel to ANTLR, on synthetic errors


compare to bison times

implement IELR?
    merges states like LALR, but only if that doesn't introduce new conflicts
        => faster than LR1
        for Ada, would only add 1 state

    IELR and LALR merge states with different lookaheads; it is the lookaheads that determine error correction
        define some other state merging criteria for error correction?

packrat space use
    can free low level derivs; they will never be evaled
        derive condition
        use free list in syntax tree

add packrat error recover
    "d:/Books/eBooks/Parsing/Fischer Mauney 1992 - Simple fast LL1 error repair.pdf"
    assumes no backtracking?
        pg 112: "parser announces error when prediction does not fit next input"

adacore langkit_support.packrat implements one row of the derivs table
        it only stores 16 most recently computed items; enough to compute a typical subroutine?
            slows down error recovery if have to go back more than 16 (not likely)
            clearly adequate given fast performance
            compare performance to a sparse vector
        libadalang.analysis.parsers Parser_Private_Part_Type stores all the rows

use wisi-gen_output_ada_common.adb Append in wisi-output_ada, _emacs.

do google search for "ada parser generator"
    add wisitoken to those sites

rename mckenzie to dpa_explore?
    dpa = deterministic parsing automata (McKenzie)
        = Deterministic Pushdown Automata (Wikipedia, Grune)

    aflex uses "dfa" deterministic finite automata
    grune also uses 'deterministic fs automata' (Finite State)

    includes special rules


automatically augment grammar with empty productions
    anything not a keyword is optional
    may create too many conflicts

integrate with emacs module

 build/release_process.text

# end of file
