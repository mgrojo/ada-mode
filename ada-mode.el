;;; ada-mode.el --- major-mode for editing Ada sources  -*- lexical-binding:t -*-
;;
;; Copyright (C) 1994, 1995, 1997 - 2019  Free Software Foundation, Inc.
;;
;; Author: Stephen Leake <stephen_leake@stephe-leake.org>
;; Maintainer: Stephen Leake <stephen_leake@stephe-leake.org>
;; Keywords: languages
;;  ada
;; Version: 6.2.1
;; package-requires: ((uniquify-files "1.0.1") (wisi "2.2.1") (emacs "25.0"))
;; url: http://www.nongnu.org/ada-mode/
;;
;; This file is part of GNU Emacs.
;;
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;
;;; Usage:
;;
;; Emacs should enter Ada mode automatically when you load an Ada
;; file, based on the file extension.  The default extensions for Ada
;; files are .ads, .adb; use ada-add-extensions to add other
;; extensions.
;;
;; By default, ada-mode is configured to take full advantage of the
;; GNAT compiler.  If you are using another compiler, you
;; should load that compiler's ada-* file first; that will define
;; ada-compiler as a feature, so ada-gnat.el will not be loaded.
;;
;; See the user guide (info "ada-mode"), built from ada-mode.texi.

;;; Design:
;;
;; In order to support multiple compilers, we use indirect function
;; calls for all operations that depend on the compiler.
;;
;; We also support a cross reference tool (also called xref tool) that
;; is different from the compiler. For example, you can use a local
;; GNAT compiler to generate and access cross-reference information,
;; while using a cross-compiler for compiling the final executable.
;;
;; Other functions are lumped with the choice of xref tool; mapping
;; Ada names to file names, creating package bodies; any tool function
;; that does not create executable code.
;;
;; The indentation engine and skeleton tools are also called
;; indirectly, to allow parallel development of new versions of these
;; tools (inspired by experience with ada-smie and ada-wisi).
;;
;; We also support using different compilers for different projects;
;; `ada-compiler' can be set in Ada mode project files.  Note that
;; there is only one project active at a time; the most recently
;; selected one. All Ada files are assumed to belong to this project
;; (which is not correct, but works well in practice; the user is
;; typically only concerned about files that belong to the current
;; project).
;;
;; There are several styles of indirect calls:
;;
;; - scalar global variable set during load
;;
;;   Appropriate when the choice of implementation is fixed at load
;;   time; it does not depend on the current Ada project. Used for
;;   indentation and skeleton functions.
;;
;; - scalar global variable set during project select
;;
;;   Appropriate when the choice of implementation is determined by
;;   the choice of compiler or xref tool, which is per-project.  The
;;   user sets the compiler choice in the project file, but not the
;;   lower-level redirect choice.
;;
;;   For example, `ada-file-name-from-ada-name' depends on the naming
;;   convention used by the compiler. If the project file sets
;;   ada_compiler to 'gnat (either directly or by default),
;;   ada-gnat-select-prj sets `ada-file-name-from-ada-name' to
;;   `ada-gnat-file-name-from-ada-name'.
;;
;; - scalar buffer-local variable set during project select or file open
;;
;;   Appropriate when choice of implementation is normally
;;   per-project, but can be per-buffer.
;;
;;   For example, `ada-case-strict' will normally be set by the
;;   project, but some files may deviate from the project standard (if
;;   they are generated by -fdumpspec, for example). Those files set
;;   `ada-case-strict' in a file local variable comment.
;;
;; - scalar buffer-local variable set by ada-mode or ada-mode-hook
;;   function
;;
;;   Appropriate when the variable is a non-Ada mode variable, also
;;   used by other modes, and choice should not affect those modes.
;;
;;   `indent-line-function', `comment-indent-function' use this style
;;
;; - alist global variable indexed by ada-compiler
;;
;;   Appropriate when the choice of implementation is determined by
;;   the compiler, but the function is invoked during project parse,
;;   so we can't depend on a value set by project select.
;;
;;   alist entries are set during load by the implementation elisp files.
;;
;;   `ada-prj-default-compiler-alist' uses this style.

;;; History:
;;
;; The first Ada mode for GNU Emacs was written by V. Broman in
;; 1985. He based his work on the already existing Modula-2 mode.
;; This was distributed as ada.el in versions of Emacs prior to 19.29.
;;
;; Lynn Slater wrote an extensive Ada mode in 1989. It consisted of
;; several files with support for dired commands and other nice
;; things.
;;
;; The probably very first Ada mode (called electric-ada.el) was
;; written by Steven D. Litvintchouk and Steven M. Rosen for the
;; Gosling Emacs. L. Slater based his development on ada.el and
;; electric-ada.el.
;;
;; A complete rewrite by Rolf Ebert <ebert@inf.enst.fr> and Markus
;; Heritsch <Markus.Heritsch@studbox.uni-stuttgart.de> was done at
;; some point.  Some ideas from the Ada mode mailing list have been
;; added.  Some of the functionality of L. Slater's mode has not (yet)
;; been recoded in this new mode.
;;
;; A complete rewrite for Emacs-20 / GNAT-3.11 was done by Emmanuel
;; Briot <briot@gnat.com> at Ada Core Technologies.
;;
;; A complete rewrite, to restructure the code more orthogonally, and
;; to use wisi for the indentation engine, was done in 2012 - 2013 by
;; Stephen Leake <stephen_leake@stephe-leake.org>.

;;; Credits:
;;
;;   Many thanks to John McCabe <john@assen.demon.co.uk> for sending so
;;     many patches included in this package.
;;   Christian Egli <Christian.Egli@hcsd.hac.com>:
;;     ada-imenu-generic-expression
;;   Many thanks also to the following persons that have contributed
;;   to the ada-mode
;;     Philippe Waroquiers (PW) <philippe@cfmu.eurocontrol.be> in particular,
;;     woodruff@stc.llnl.gov (John Woodruff)
;;     jj@ddci.dk (Jesper Joergensen)
;;     gse@ocsystems.com (Scott Evans)
;;     comar@gnat.com (Cyrille Comar)
;;     robin-reply@reagans.org
;;    and others for their valuable hints.

(require 'ada-core)
(require 'ada-skel)
(require 'align)
(require 'cl-lib)
(require 'compile)
(require 'find-file)
(require 'wisi) ;; FIXME: rewrite to assume wisi

(defun ada-mode-version ()
  "Return Ada mode version."
  (interactive)
  (let ((version-string "6.2.1"))
    (if (called-interactively-p 'interactive)
	(message version-string)
      version-string)))

;;;;; User variables

(defcustom ada-fill-comment-prefix "-- "
  "Comment fill prefix."
  :group 'ada
  :type 'string)
(make-variable-buffer-local 'ada-fill-comment-prefix)

(defcustom ada-fill-comment-postfix " --"
  "Comment fill postfix."
  :group 'ada
  :type 'string)
(make-variable-buffer-local 'ada-fill-comment-postfix)

(defcustom ada-fill-comment-adaptive nil
  "If non-nil, comments are filled to the same width (not including indentation),
rather than to the same column."
  :group 'ada
  :type 'boolean
  :safe #'booleanp)

;;;; keymap and menus

(defvar ada-mode-map
  (let ((map (make-sparse-keymap)))
    ;; C-c <letter> are reserved for users

    ;; global-map has C-x ` 'next-error
    (define-key map [return] 	 'ada-case-adjust-interactive)
    (define-key map "\C-c`" 	 'ada-show-secondary-error)
    (define-key map "\C-c;"      (lambda () (error "use M-; instead"))) ; comment-dwim
    (define-key map "\C-c<" 	 'ada-goto-declaration-start)
    (define-key map "\C-c>" 	 'ada-goto-declaration-end)
    (define-key map "\C-c\M-`" 	 'ada-fix-compiler-error)
    (define-key map "\C-c\C-a" 	 'ada-align)
    (define-key map "\C-c\C-b" 	 'ada-make-subprogram-body)
    (define-key map "\C-c\C-c"   'ada-build-make)
    (define-key map "\C-c\C-d" 	 'ada-goto-declaration)
    (define-key map "\C-c\M-d" 	 'ada-show-declaration-parents)
    (define-key map "\C-c\C-e" 	 'ada-skel-expand)
    (define-key map "\C-c\C-f" 	 'ada-show-parse-error)
    (define-key map "\C-c\C-i" 	 'ada-indent-statement)
    (define-key map "\C-c\C-l" 	 'ada-show-local-references)
    (define-key map "\C-c\C-m"   'ada-build-set-make)
    (define-key map "\C-c\C-n" 	 'forward-sexp)
    (define-key map "\C-c\M-n" 	 'ada-skel-next-placeholder)
    (define-key map "\C-c\C-o" 	 'ada-find-other-file)
    (define-key map "\C-c\M-o" 	 'ada-find-other-file-noset)
    (define-key map "\C-c\C-p" 	 'backward-sexp)
    (define-key map "\C-c\M-p" 	 'ada-skel-prev-placeholder)
    (define-key map "\C-c\C-q" 	 'ada-xref-refresh)
    (define-key map "\C-c\C-r" 	 'ada-show-references)
    (define-key map "\C-c\M-r" 	 'ada-build-run)
    (define-key map "\C-c\C-s"   'ada-goto-previous-pos)
    (define-key map "\C-c\C-v"   'ada-build-check)
    (define-key map "\C-c\C-w" 	 'ada-case-adjust-at-point)
    (define-key map "\C-c\C-x"   'ada-show-overriding)
    (define-key map "\C-c\M-x"   'ada-show-overridden)
    (define-key map "\C-c\C-y" 	 'ada-case-create-exception)
    (define-key map "\C-c\C-\M-y" 'ada-case-create-partial-exception)
    (define-key map [C-down-mouse-3] 'ada-popup-menu)

    (ada-case-activate-keys map)

    map
  )  "Local keymap used for Ada mode.")

(defvar ada-mode-menu (make-sparse-keymap "Ada"))
(easy-menu-define ada-mode-menu ada-mode-map "Menu keymap for Ada mode"
  '("Ada"
    ("Help"
     ["Ada Mode"             (info "ada-mode") t]
     ["Ada Reference Manual" (info "arm2012") t]
     ["Key bindings"         describe-bindings t]
     )
    ["Customize"                  (customize-group 'ada)    t]
    ("Project files"
     ["Find and select project ..."   ada-build-prompt-select-prj-file t]
     ["Select project ..."            ada-prj-select                   t]
     ["Show project"                  ada-prj-show                     t]
     ["Show project file search path" ada-prj-show-prj-path            t]
     ["Show source file search path"  ada-prj-show-src-path            t]
     ["Delete project ..."            ada-prj-delete                   t]
    )
    ("Build"
     ["Next compilation error"     next-error                t]
     ["Show secondary error"       ada-show-secondary-error  t]
     ["Fix compilation error"      ada-fix-compiler-error    t]
     ["Show last parse error"      ada-show-parse-error      t]
     ["Check syntax"               ada-build-check       t]
     ["Show main"                  ada-build-show-main   t]
     ["Build"                      ada-build-make        t]
     ["Set main and Build"         ada-build-set-make    t]
     ["Run"                        ada-build-run         t]
     )
    ("Navigate"
     ["Other file"                    ada-find-other-file          t]
     ["Other file don't find decl"    ada-find-other-file-noset    t]
     ["Find file in project"          ada-find-file                t]
     ["Goto declaration/body"         ada-goto-declaration         t]
     ["Goto next statement keyword"   forward-sexp   t]
     ["Goto prev statement keyword"   backward-sexp   t]
     ["Goto declarative region start" ada-goto-declarative-region-start   t]
     ["Goto declaration start"        ada-goto-declaration-start   t]
     ["Goto declaration end"          ada-goto-declaration-end     t]
     ["Show parent declarations"      ada-show-declaration-parents t]
     ["Show references"               ada-show-references          t]
     ["Show overriding"               ada-show-overriding          t]
     ["Show overridden"               ada-show-overridden          t]
     ["Goto secondary error"          ada-show-secondary-error     t]
     ["Goto prev position"            ada-goto-previous-pos        t]
     ["Next placeholder"              ada-next-placeholder    t]
     ["Previous placeholder"          ada-prev-placeholder    t]
     )
    ("Edit"
     ["Expand skeleton"             ada-skel-expand              t]
     ["Indent line or selection"    indent-for-tab-command  t]
     ["Indent current statement"    ada-indent-statement    t]
     ["Indent lines in file"        (indent-region (point-min) (point-max))  t]
     ["Align"                       ada-align               t]
     ["Comment/uncomment selection" comment-dwim            t]
     ["Fill comment paragraph"         ada-fill-comment-paragraph           t]
     ["Fill comment paragraph justify" (ada-fill-comment-paragraph 'full)   t]
     ["Fill comment paragraph postfix" (ada-fill-comment-paragraph 'full t) t]
     ["Make body for subprogram"    ada-make-subprogram-body     t]
     )
    ("Refactor"
     ["Method (Object) => Object.Method"   ada-wisi-refactor-1 t]
     ["Object.Method   => Method (Object)" ada-wisi-refactor-2 t]
     ["Element (Object, Index) => Object (Index)" ada-wisi-refactor-3 t]
     ["Object (Index) => Element (Object, Index)" ada-wisi-refactor-4 t]
     )
    ("Casing"
     ["Create full exception"       ada-case-create-exception t]
     ["Create partial exception"    ada-case-create-partial-exception t]
     ["Adjust case at point"        ada-case-adjust-at-point  t]
     ["Adjust case region"          ada-case-adjust-region    t]
     ["Adjust case buffer"          ada-case-adjust-buffer    t]
     ["Show casing files list"      ada-case-show-files       t]
     )
    ("Misc"
     ["Show last parse error"         ada-show-parse-error         t]
     ["Show xref tool buffer"         ada-show-xref-tool-buffer    t]
     ["Refresh cross reference cache" ada-xref-refresh             t]
     ["Reset parser"                  ada-reset-parser             t]
     )))

(defun ada-project-menu-install ()
  "Install the Ada project menu as a submenu."
  (when (eq major-mode 'ada-mode)
    (lookup-key ada-mode-map [menu-bar Ada]) ;; map to put menu in
    [ada-prj-select]          ;; key to insert (a menu entry)
    (easy-menu-binding
     (easy-menu-create-menu
      "Select Project"
      (ada-project-menu-compute)));; binding
    nil;; after

    ;; IMPROVEME: this doesn’t work for ’after’; "Select Project" is at end
    ;; (lookup-key ada-mode-map [menu-bar Ada Build])
    ))

(easy-menu-define ada-context-menu nil
  "Context menu keymap for Ada mode"
  '("Ada"
    ["Goto declaration/body"         ada-goto-declaration         t]
    ["Show parent declarations"      ada-show-declaration-parents t]
    ["Goto declarative region start" ada-goto-declarative-region-start   t]
    ["Goto declaration start"        ada-goto-declaration-start   t]
    ["Goto declaration end"          ada-goto-declaration-end     t]
    ["Show parent declarations"      ada-show-declaration-parents t]
    ["Show references"               ada-show-references          t]
    ["Show overriding"               ada-show-overriding          t]
    ["Show overridden"               ada-show-overridden          t]
    ["Goto next statement keyword"   forward-sexp   t]
    ["Goto prev statement keyword"   backward-sexp   t]

    ["-"                nil nil]

    ["Align"			      ada-align                  t]
    ["Comment/uncomment selection"    comment-dwim               t]
    ["Fill comment paragraph"	      ada-fill-comment-paragraph           (ada-in-comment-p)]
    ["Fill comment paragraph justify" (ada-fill-comment-paragraph 'full)   (ada-in-comment-p)]
    ["Fill comment paragraph postfix" (ada-fill-comment-paragraph 'full t) (ada-in-comment-p)]
    ["Adjust case at point"	      ada-case-adjust-at-point             (not (use-region-p))]
    ["Adjust case region"	      ada-case-adjust-region               (use-region-p)]
    ["Create full case exception"     ada-case-create-exception         t]
    ["Create partial case exception"  ada-case-create-partial-exception t]
    ["Indent current statement"	      ada-indent-statement              t]
    ["Expand skeleton"		      ada-skel-expand                   t]
    ["Make body for subprogram"	      ada-make-subprogram-body          t]
    ))

(defun				      ada-popup-menu ()
  "Pops up `ada-context-menu'.
When a function from the menu is called, point is where the mouse
button was clicked."
  (interactive)
  (mouse-set-point last-input-event)
  (popup-menu ada-context-menu)
  )

(easy-menu-define ada-refactor-menu nil
  "Context menu keymap for Ada mode refactor commands."
  '("Ada refactor"
    ["Method (Object) => Object.Method"   ada-wisi-refactor-1 t]
    ["Object.Method   => Method (Object)" ada-wisi-refactor-2 t]
    ["Element (Object, Index) => Object (Index)" ada-wisi-refactor-3 t]
    ["Object (Index) => Element (Object, Index)" ada-wisi-refactor-4 t]
    ))

(defun ada-refactor-menu-popup ()
  "Pops up `ada-refactor-menu'."
  (interactive)
  (mouse-set-point last-input-event)
  (popup-menu ada-refactor-menu))

(defun ada-indent-newline-indent ()
  "insert a newline, indent the old and new lines."
  (interactive "*")
  ;; point may be in the middle of a word, so insert newline first,
  ;; then go back and indent.
  (insert "\n")
  (unless (and (wisi-partial-parse-p (line-beginning-position) (line-end-position))
	       (save-excursion (progn (forward-char -1)(looking-back "begin\\|else" (line-beginning-position)))))
    ;; Partial parse may think 'begin' is just the start of a
    ;; statement, when it's actually part of a larger declaration. So
    ;; don't indent 'begin'. Similarly for 'else'; error recovery will
    ;; probably insert 'if then' immediately before it
    (forward-char -1)
    (funcall indent-line-function)
    (forward-char 1))
  (funcall indent-line-function))

(defvar ada-indent-statement nil
  ;; indentation function
  "Function to indent the statement/declaration point is in or after.
Function is called with no arguments.")

(defun ada-indent-statement ()
  "Indent current statement."
  (interactive)
  (when ada-indent-statement
    (funcall ada-indent-statement)))

(defvar ada-reset-parser nil
  ;; Supplied by indentation engine parser
  "Function to reset parser, to clear confused state."
  )

(defun ada-reset-parser ()
  "See variable ’ada-reset-parser’."
  (interactive)
  (when ada-reset-parser
    (funcall ada-reset-parser)))

(defvar ada-show-parse-error nil
  ;; Supplied by indentation engine parser
  "Function to show last error reported by indentation parser."
  )

(defun ada-show-parse-error ()
  (interactive)
  (when ada-show-parse-error
    (funcall ada-show-parse-error)))

;;;; syntax properties

(defvar ada-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; (info "(elisp)Syntax Class Table" "*info syntax class table*")
    ;; make-syntax-table sets all alphanumeric to w, etc; so we only
    ;; have to add ada-specific things.

    ;; string brackets. `%' is the obsolete alternative string
    ;; bracket (arm J.2); if we make it syntax class ", it throws
    ;; font-lock and indentation off the track, so we use syntax class
    ;; $.
    (modify-syntax-entry ?%  "$" table)
    (modify-syntax-entry ?\" "\"" table)

    ;; punctuation; operators etc
    (modify-syntax-entry ?#  "." table); based number
    (modify-syntax-entry ?&  "." table)
    (modify-syntax-entry ?*  "." table)
    (modify-syntax-entry ?+  "." table)
    (modify-syntax-entry ?-  "." table); operator; see ada-syntax-propertize for double hyphen as comment
    (modify-syntax-entry ?. "." table)
    (modify-syntax-entry ?/  "." table)
    (modify-syntax-entry ?:  "." table)
    (modify-syntax-entry ?<  "." table)
    (modify-syntax-entry ?=  "." table)
    (modify-syntax-entry ?>  "." table)
    (modify-syntax-entry ?\' "." table); attribute; see ada-syntax-propertize for character literal
    (modify-syntax-entry ?\; "." table)
    (modify-syntax-entry ?\\ "." table); default is escape; not correct for Ada strings
    (modify-syntax-entry ?\|  "." table)

    ;; \f and \n end a comment.
    ;; comment start set in ada-syntax-propertize.
    ;; flag ’s’ experimental; end unterminated string at newline.
    (modify-syntax-entry ?\f  "> s" table)
    (modify-syntax-entry ?\n  "> s" table)

    (modify-syntax-entry ?_ "_" table); symbol constituents, not word.

    (modify-syntax-entry ?\( "()" table)
    (modify-syntax-entry ?\) ")(" table)

    ;; skeleton placeholder delimiters; see ada-skel.el. We use generic
    ;; comment delimiter class, not comment starter/comment ender, so
    ;; these can be distinguished from line end.
    (modify-syntax-entry ?{ "!" table)
    (modify-syntax-entry ?} "!" table)

    table
    )
  "Syntax table to be used for editing Ada source code.")

(defun ada-syntax-propertize (start end)
  "For `syntax-propertize-function'.
Assign `syntax-table' properties in region START .. END.
In particular, character constants are set to have string syntax.
Runs `ada-syntax-propertize-hook'."
  ;; (info "(elisp)Syntax Properties")
  ;;
  ;; called from `syntax-propertize', inside save-excursion with-silent-modifications
  (let ((inhibit-read-only t)
	(inhibit-point-motion-hooks t))
    (goto-char start)
    (save-match-data
      (while (re-search-forward
	      (concat
	       "[^a-zA-Z0-9)]\\('\\)[^'\n]\\('\\)"; 1, 2: character literal, not attribute
	       "\\|[^a-zA-Z0-9)]\\('''\\)"; 3: character literal '''
	       "\\|\\(--\\)"; 4: comment start
	       )
	      end t)
	;; syntax-propertize-extend-region-functions is set to
	;; syntax-propertize-wholelines by default. We assume no
	;; coding standard will permit a character literal at the
	;; start of a line (not preceded by whitespace).
	(cond
	 ((match-beginning 1)
	  (put-text-property
	   (match-beginning 1) (match-end 1) 'syntax-table '(7 . ?'))
	  (put-text-property
	   (match-beginning 2) (match-end 2) 'syntax-table '(7 . ?')))
	 ((match-beginning 3)
	  (put-text-property
	   (match-beginning 3) (1+ (match-beginning 3)) 'syntax-table '(7 . ?'))
	  (put-text-property
	   (1- (match-end 3)) (match-end 3) 'syntax-table '(7 . ?')))
	 ((match-beginning 4)
	  (put-text-property
	   (match-beginning 4) (match-end 4) 'syntax-table '(11 . nil)))
	 )))
    (run-hook-with-args 'ada-syntax-propertize-hook start end))
  )

;;;; navigation within and between files

(defvar ada-body-suffixes '(".adb")
  "List of possible suffixes for Ada body files.
The extensions should include a `.' if needed.")

(defvar ada-spec-suffixes '(".ads")
  "List of possible suffixes for Ada spec files.
The extensions should include a `.' if needed.")

(defvar ada-other-file-alist
  '(("\\.ads$" (".adb"))
    ("\\.adb$" (".ads")))
  "Alist used by `find-file' to find the name of the other package.
See `ff-other-file-alist'.")

(defconst ada-parent-name-regexp
  "\\([a-zA-Z0-9_\\.]+\\)\\.[a-zA-Z0-9_]+"
  "Regexp for extracting the parent name from fully-qualified name.")

(defun ada-ff-special-extract-parent ()
  (setq ff-function-name (match-string 1))
  (file-name-nondirectory
   (or
    (ff-get-file-name
     compilation-search-path
     (ada-file-name-from-ada-name ff-function-name)
     ada-spec-suffixes)
    (error "parent '%s' not found; set project file?" ff-function-name))))

(defun ada-ff-special-with ()
  (let ((package-name (match-string 1)))
    (setq ff-function-name (concat "^\\(function\\|procedure\\|package\\)\\s-+" package-name "\\([^_]\\|$\\)"))
    (file-name-nondirectory
     (or
      (ff-get-file-name
       compilation-search-path
       (ada-file-name-from-ada-name package-name)
       (append ada-spec-suffixes ada-body-suffixes))
      (error "package '%s' not found; set project file?" package-name)))
    ))

(defun ada-set-ff-special-constructs ()
  "Add Ada-specific pairs to `ff-special-constructs'."
  (set (make-local-variable 'ff-special-constructs) nil)
  (mapc (lambda (pair) (add-to-list 'ff-special-constructs pair))
	;; Each car is a regexp; if it matches at point, the cdr is invoked.
	;; Each cdr should set ff-function-name to a string or regexp
	;; for ada-set-point-accordingly, and return the file name
	;; (sans directory, must include suffix) to go to.
	(list
	 ;; Top level child package declaration (not body), or child
	 ;; subprogram declaration or body; go to the parent package.
	 (cons (concat "^\\(?:private[ \t]+\\)?\\(?:package\\|procedure\\|function\\)[ \t]+"
		       ada-parent-name-regexp "\\(?:;\\|[ \t]+\\|$\\)")
	       'ada-ff-special-extract-parent)

	 ;; A "with" clause. Note that it may refer to a procedure body, as well as a spec
	 (cons (concat "^\\(?:limited[ \t]+\\)?\\(?:private[ \t]+\\)?with[ \t]+" ada-name-regexp)
	       'ada-ff-special-with)
	 )))

(defvar ada-which-function nil
  ;; supplied by indentation engine
  ;;
  ;; This is run from ff-pre-load-hook, so ff-function-name may have
  ;; been set by ff-treat-special; don't reset it.
  "Function called with one parameter (INCLUDE-TYPE); it should
return the name of the package, protected type, subprogram,
entry, or task type whose definition/declaration point is in, or
for declarations that don't have declarative regions, just after;
or nil.

If INCLUDE-TYPE is non-nil, include type names.

In addition, if `ff-function-name' is non-nil, store in
`ff-function-name' a regexp that will find the function in the
other file.")

(defun ada-which-function (&optional include-type)
  "See `ada-which-function' variable."
  (when ada-which-function
    (funcall ada-which-function include-type)))

(defvar ada-on-context-clause nil
  ;; supplied by indentation engine
  "Function called with no parameters; it should return non-nil
  if point is on a context clause.")

(defun ada-on-context-clause ()
  "See `ada-on-context-clause' variable."
  (interactive)
  (when ada-on-context-clause
    (funcall ada-on-context-clause)))

(defvar ada-goto-subunit-name nil
  ;; supplied by indentation engine
  "Function called with no parameters; if the current buffer
  contains a subunit, move point to the subunit name (for
  `ada-goto-declaration'), return t; otherwise leave point alone,
  return nil.")

(defun ada-goto-subunit-name ()
  "See `ada-goto-subunit-name' variable."
  (interactive)
  (when ada-goto-subunit-name
    (funcall ada-goto-subunit-name)))

(defun ada-add-log-current-function ()
  "For `add-log-current-defun-function'."
  ;; add-log-current-defun is typically called with point at the start
  ;; of an ediff change section, which is before the start of the
  ;; declaration of a new item. So go to the start of the current line
  ;; first
  (save-excursion
    (back-to-indentation)
    (ada-which-function t)))

(defun ada-set-point-accordingly ()
  "Move to the string specified in `ff-function-name', which may be a regexp,
previously set by a file navigation command."
  (when ff-function-name
    (let ((done nil)
	  (found nil))
      (goto-char (point-min))
      ;; We are looking for an Ada declaration, so don't stop for strings or comments
      ;;
      ;; This will still be confused by multiple references; we need
      ;; to use compiler cross reference info for more precision.
      (while (not done)
	(if (search-forward-regexp ff-function-name nil t)
	    (setq found (match-beginning 0))
	  ;; not in remainder of buffer
	  (setq done t))
	(if (ada-in-string-or-comment-p)
	    (setq found nil)
	  (setq done t)))
      (when found
	(goto-char found)
	;; different parsers find different points on the line; normalize here
	(back-to-indentation))
      (setq ff-function-name nil))))

(defun ada-find-other-file ()
  "Move to the corresponding declaration in another file.

- If region is active, assume it contains a package name;
  position point on that package declaration.

- If point is in the start line of a non-nested child package or
  subprogram declaration, position point on the corresponding
  parent package specification.

- If point is in a context clause line, position point on the
  first package declaration that is mentioned.

- If point is in a separate body, position point on the
  corresponding specification.

- If point is in a subprogram body or specification, position point
  on the corresponding specification or body."

  ;; ff-get-file, ff-find-other file first process
  ;; ff-special-constructs, then run the following hooks:
  ;;
  ;; ff-pre-load-hook      set to ada-which-function
  ;; ff-file-created-hook  set to ada-ff-create-body
  ;; ff-post-load-hook     set to ada-set-point-accordingly,
  ;;                       or to a compiler-specific function that
  ;;                       uses compiler-generated cross reference
  ;;                       information

  (interactive)
  (ada-check-current-project (buffer-file-name))

  ;; clear ff-function-name, so either ff-special-constructs or
  ;; ada-which-function will set it.
  (setq ff-function-name nil)

  (cond
   (mark-active
    (setq ff-function-name (buffer-substring-no-properties (point) (mark)))
    (ff-get-file
     compilation-search-path
     (ada-file-name-from-ada-name ff-function-name)
     ada-spec-suffixes
     nil);; other-window
    (deactivate-mark))

   ((and (not (ada-on-context-clause))
	 (ada-goto-subunit-name))
    (ada-goto-declaration))

   (t
    (ff-find-other-file)))
  )

(defun ada-find-file (filename)
  ;; we assume compliation-search-path is set, either by an
  ;; ada-mode project, or by some other means.
  (interactive (list (completing-read "File: "
				      (apply-partially
				       'locate-file-completion-table
				       compilation-search-path nil))))
  (find-file (locate-file filename compilation-search-path))
  )


;; This is autoloaded because it may be used in ~/.emacs
;;;###autoload
(defun ada-add-extensions (spec body)
  "Define SPEC and BODY as being valid extensions for Ada files.
SPEC and BODY are two regular expressions that must match against
the file name."
  (let* ((reg (concat (regexp-quote body) "$"))
	 (tmp (assoc reg ada-other-file-alist)))
    (if tmp
	(setcdr tmp (list (cons spec (cadr tmp))))
      (add-to-list 'ada-other-file-alist (list reg (list spec)))))

  (let* ((reg (concat (regexp-quote spec) "$"))
	 (tmp (assoc reg ada-other-file-alist)))
    (if tmp
	(setcdr tmp (list (cons body (cadr tmp))))
      (add-to-list 'ada-other-file-alist (list reg (list body)))))

  (add-to-list 'auto-mode-alist
	       (cons (concat (regexp-quote spec) "\\'") 'ada-mode))
  (add-to-list 'auto-mode-alist
	       (cons (concat (regexp-quote body) "\\'") 'ada-mode))

  (add-to-list 'ada-spec-suffixes spec)
  (add-to-list 'ada-body-suffixes body)

  (when (fboundp 'speedbar-add-supported-extension)
    (speedbar-add-supported-extension spec)
    (speedbar-add-supported-extension body))
  )

(defun ada-show-secondary-error ()
  "Show the next secondary file reference in the compilation buffer.
A secondary file reference is defined by text having text
property `ada-secondary-error'.  These can be set by
compiler-specific compilation filters."
  (interactive)

  ;; preserving the current window works only if the frame
  ;; doesn't change, at least on Windows.
  (let ((start-buffer (current-buffer))
	pos item file)
    ;; We use `pop-to-buffer', not `set-buffer', so `forward-line'
    ;; works. But that might eat an `other-frame-window-mode' prefix,
    ;; which the user means to apply to ’ada-goto-source’ below;
    ;; disable that temporarily.
    (let ((display-buffer-overriding-action nil))
      (pop-to-buffer compilation-last-buffer nil t)
      (setq pos (next-single-property-change (point) 'ada-secondary-error))
      (when pos
	(setq item (get-text-property pos 'ada-secondary-error))
	;; file-relative-name handles absolute Windows paths from
	;; g++. Do this in compilation buffer to get correct
	;; default-directory.
	(setq file (file-relative-name (nth 0 item)))

	;; Set point in compilation buffer past this secondary error, so
	;; user can easily go to the next one.
	(goto-char pos)
	(forward-line 1))

      (pop-to-buffer start-buffer nil t);; for windowing history
      )
    (when item
      (ada-goto-source
       file
       (nth 1 item); line
       (nth 2 item); column
       ))
    ))

(defvar ada-goto-declaration-start nil
  ;; Supplied by indentation engine.
  ;;
  "For `beginning-of-defun-function'. Function to move point to
start of the generic, package, protected, subprogram, or task
declaration point is currently in or just after.  Called with no
parameters.")

(defun ada-goto-declaration-start ()
  "Call `ada-goto-declaration-start'."
  (interactive)
  (when ada-goto-declaration-start
    (funcall ada-goto-declaration-start)))

(defvar ada-goto-declaration-end nil
  ;; supplied by indentation engine
  "For `end-of-defun-function'. Function to move point to end of
current declaration.")

(defun ada-goto-declaration-end ()
  "See `ada-goto-declaration-end' variable."
  (interactive)
  (when ada-goto-declaration-end
    (funcall ada-goto-declaration-end)))

(defvar ada-goto-end nil
  ;; Supplied by indentation engine
  "Function to move point to end of the declaration or statement point is in or before.
Called with no parameters.")

(defun ada-goto-end ()
  "Call `ada-goto-end'."
  (when ada-goto-end
    (funcall ada-goto-end)))

;;;; fill-comment

(defvar wisi-inhibit-parse nil);; in wisi.el; so far that's the only parser we use.

(defun ada-fill-comment-paragraph (&optional justify postfix)
  "Fill the current comment paragraph.
If JUSTIFY is non-nil, each line is justified as well.
If POSTFIX and JUSTIFY are non-nil, `ada-fill-comment-postfix' is appended
to each line filled and justified.
The ident for the paragraph is taken from the first line."
  (interactive "P")
  (if (not (or (ada-in-comment-p)
               (looking-at "[ \t]*--")))
      (error "Not inside comment"))

  ;; fill-region-as-paragraph leaves comment text exposed (without
  ;; comment prefix) when inserting a newline; don't trigger a parse
  ;; because of that (in particular, jit-lock requires a parse; other
  ;; hooks may as well).
  (let* ((wisi-inhibit-parse t)
	 indent from to
	 (opos (point-marker))
	 ;; we bind `fill-prefix' here rather than in ada-mode because
	 ;; setting it in ada-mode causes indent-region to use it for
	 ;; all indentation.
	 ;; FIXME: use comment-start, comment-padding
	 (fill-prefix ada-fill-comment-prefix)
	 (fill-column (if ada-fill-comment-adaptive
			  (save-excursion
			    (back-to-indentation)
			    (+ (current-column) fill-column))
			(current-fill-column))))

    ;;  Find end of comment paragraph
    (back-to-indentation)
    (while (and (not (eobp)) (looking-at ".*--[ \t]*[^ \t\n]"))
      (forward-line 1)

      ;;  If we were at the last line in the buffer, create a dummy empty
      ;;  line at the end of the buffer.
      (if (eobp)
	  (insert "\n")
	(back-to-indentation)))
    (beginning-of-line)
    (setq to (point-marker))
    (goto-char opos)

    ;;  Find beginning of paragraph
    (back-to-indentation)
    (while (and (not (bobp)) (looking-at ".*--[ \t]*[^ \t\n]"))
      (forward-line -1)
      (back-to-indentation))

    (unless (bobp)
      (forward-line 1))
    (beginning-of-line)
    (setq from (point-marker))

    ;;  Calculate the indentation we will need for the paragraph
    (back-to-indentation)
    (setq indent (current-column))
    ;;  unindent the first line of the paragraph
    (delete-region from (point))

    ;;  Remove the old postfixes
    (goto-char from)
    (while (re-search-forward (concat "\\(" ada-fill-comment-postfix "\\)" "\n") to t)
      (delete-region (match-beginning 1) (match-end 1)))

    (goto-char (1- to))
    (setq to (point-marker))

    ;;  Indent and justify the paragraph
    (set-left-margin from to indent)
    (if postfix
	(setq fill-column (- fill-column (length ada-fill-comment-postfix))))

    (fill-region-as-paragraph from to justify)

    ;;  Add the postfixes if required
    (if postfix
	(save-restriction
	  (goto-char from)
	  (narrow-to-region from to)
	  (while (not (eobp))
	    (end-of-line)
	    (insert-char ?  (- fill-column (current-column)))
	    (insert ada-fill-comment-postfix)
	    (forward-line))
	  ))

    (goto-char opos)))

;;;; support for font-lock.el

(defconst ada-83-keywords
  '("abort" "abs" "accept" "access" "all" "and" "array" "at" "begin"
    "body" "case" "constant" "declare" "delay" "delta" "digits" "do"
    "else" "elsif" "end" "entry" "exception" "exit" "for" "function"
    "generic" "goto" "if" "in" "is" "limited" "loop" "mod" "new"
    "not" "null" "of" "or" "others" "out" "package" "pragma" "private"
    "procedure" "raise" "range" "record" "rem" "renames" "return"
    "reverse" "select" "separate" "subtype" "task" "terminate" "then"
    "type" "use" "when" "while" "with" "xor")
  "List of Ada 83 keywords.")

(defconst ada-95-keywords
  '("abstract" "aliased" "protected" "requeue" "tagged" "until")
  "List of keywords new in Ada 95.")

(defconst ada-2005-keywords
  '("interface" "overriding" "synchronized")
  "List of keywords new in Ada 2005.")

(defconst ada-2012-keywords
  '("some")
  "List of keywords new in Ada 2012.")

(defun ada-font-lock-keywords ()
  "Return Ada mode value for `font-lock-keywords', depending on `ada-language-version'."
   ;; Grammar actions set `font-lock-face' property for all
   ;; non-keyword tokens that need it.
  (list
   (list (concat "\\_<" (regexp-opt ada-keywords t) "\\_>") '(0 font-lock-keyword-face))
   ))

(defvar which-func-functions nil) ;; which-func.el
(defvar which-func-non-auto-modes nil) ;; ""

;;;; ada-mode

;; ada-mode does not derive from prog-mode, because we need to call
;; ada-mode-post-local-vars, and prog-mode does not provide a way to
;; do that (at least before emacs 26).
;;
;; autoload required by automatic mode setting
;;;###autoload
(defun ada-mode ()
  "The major mode for editing Ada code."
  ;; the other ada-*.el files add to ada-mode-hook for their setup

  (interactive)
  (kill-all-local-variables)
  (setq major-mode 'ada-mode)
  (setq mode-name "Ada")
  (use-local-map ada-mode-map)

  (set-syntax-table ada-mode-syntax-table)
  (define-abbrev-table 'ada-mode-abbrev-table ())
  (setq local-abbrev-table ada-mode-abbrev-table)

  (set (make-local-variable 'syntax-propertize-function) 'ada-syntax-propertize)
  (syntax-ppss-flush-cache (point-min));; reparse with new function

  (when (boundp 'syntax-begin-function)
    ;; default ‘beginning-of-defun’ in emacs-24.2; we need it nil
    ;; obsolete in 25.1
    (set (make-local-variable 'syntax-begin-function) nil))
  (set (make-local-variable 'parse-sexp-ignore-comments) t)
  (set (make-local-variable 'parse-sexp-lookup-properties) t)
  (set 'case-fold-search t); Ada is case insensitive; the syntax parsing requires this setting
  (set (make-local-variable 'comment-start) "--")
  (set (make-local-variable 'comment-end) "")
  (set (make-local-variable 'comment-start-skip) "---*[ \t]*")
  (set (make-local-variable 'comment-multi-line) nil)

  ;; we _don't_ set `fill-prefix' here because that causes
  ;; indent-region to use it for all indentation. See
  ;; ada-fill-comment-paragraph.

  ;; AdaCore standard style (enforced by -gnaty) requires two spaces
  ;; after '--' in comments; this makes it easier to distinguish
  ;; special comments that have something else after '--'
  ;; FIXME: this means we don't need ada-fill-comment-prefix
  (set (make-local-variable 'comment-padding) "  ")

  (set (make-local-variable 'require-final-newline) t)

  (setq font-lock-defaults
	'(ada-font-lock-keywords ;; keywords
	  nil ;; keywords only; comment, string faces not set by wisi parser
	  t ;; case-fold
	  ((?\_ . "w")))); treat underscore as a word component

  (set (make-local-variable 'ff-other-file-alist)
       'ada-other-file-alist)
  (setq ff-post-load-hook    #'ada-set-point-accordingly
	ff-file-created-hook #'ada-ff-create-body)
  (add-hook 'ff-pre-load-hook #'ada-goto-push-pos)
  (add-hook 'ff-pre-load-hook #'ada-which-function)
  (setq ff-search-directories 'compilation-search-path)
  (when (null (car compilation-search-path))
    ;; find-file doesn't handle nil in search path
    (setq compilation-search-path (list (if buffer-file-name
                                            (file-name-directory (buffer-file-name))
                                          "."))))
  (ada-set-ff-special-constructs)

  (set (make-local-variable 'add-log-current-defun-function)
       #'ada-add-log-current-function)

  ;; We set this even if which-func.el is not loaded, because if it is
  ;; loaded later, it will use the add-log which-function, which
  ;; forces a navigate parse.
  (add-hook 'which-func-functions #'ada-which-function nil t)
  (add-to-list 'which-func-non-auto-modes 'ada-mode)

  ;;  Support for align
  (add-to-list 'align-dq-string-modes 'ada-mode)
  (add-to-list 'align-open-comment-modes 'ada-mode)
  (set (make-local-variable 'align-region-separate) ada-align-region-separate)
  (set (make-local-variable 'align-indent-before-aligning) t)

  ;; Exclude comments alone on line from alignment.
  (add-to-list 'align-exclude-rules-list
	       '(ada-solo-comment
		 (regexp  . "^\\(\\s-*\\)--")
		 (modes   . '(ada-mode))))
  (add-to-list 'align-exclude-rules-list
	       '(ada-solo-use
		 (regexp  . "^\\(\\s-*\\)\\_<use\\_>")
		 (modes   . '(ada-mode))))

  (setq align-mode-rules-list ada-align-rules)

  (easy-menu-add ada-mode-menu ada-mode-map)

  (run-mode-hooks 'ada-mode-hook)

  (when (< emacs-major-version 25) (syntax-propertize (point-max)))

  (if (<= emacs-major-version 25)
      ;; run-mode-hooks does _not_ call hack-local-variables
      (add-hook 'hack-local-variables-hook 'ada-mode-post-local-vars nil t)
    ;; >= 26; run-mode-hooks _does_ call hack-local-variables, after the hook functions
    (ada-mode-post-local-vars))
  )

(defun ada-mode-post-local-vars ()
  ;; These are run after ada-mode-hook and file local variables
  ;; because users or *.ad? files might set the relevant
  ;; variable inside the hook or file local variables.

  ;; This means to fully set ada-mode interactively, user must
  ;; do M-x ada-mode M-; (hack-local-variables)

  (setq hack-local-variables-hook (delq 'ada-mode-post-local-vars hack-local-variables-hook))

  ;; fill-region-as-paragraph in ada-fill-comment-paragraph does not
  ;; call syntax-propertize, so set comment syntax on
  ;; ada-fill-comment-prefix. In post-local because user may want to
  ;; set it per-file. IMPROVEME: only in emacs < 25? FIXME: use comment-start
  (put-text-property 0 2 'syntax-table '(11 . nil) ada-fill-comment-prefix)

  (cl-case ada-language-version
   (ada83
    (setq ada-keywords ada-83-keywords))

   (ada95
    (setq ada-keywords
	  (append ada-83-keywords
		  ada-95-keywords)))

   (ada2005
    (setq ada-keywords
	  (append ada-83-keywords
		  ada-95-keywords
		  ada-2005-keywords)))
   (ada2012
    (setq ada-keywords
	  (append ada-83-keywords
		  ada-95-keywords
		  ada-2005-keywords
		  ada-2012-keywords))))

  (when global-font-lock-mode
    ;; This calls ada-font-lock-keywords, which depends on
    ;; ada-keywords
    (font-lock-refresh-defaults))

  (when ada-goto-declaration-start
    (set (make-local-variable 'beginning-of-defun-function) ada-goto-declaration-start))

  (when ada-goto-declaration-end
    (set (make-local-variable 'end-of-defun-function) ada-goto-declaration-end))

  (unless ada-prj-current-project
    (setq ada-prj-current-project (ada-prj-default)))
  )

(put 'ada-mode 'custom-mode-group 'ada)

(defvar ada-parser 'process
  "Indicate parser and lexer to use for Ada buffers:

process : external process lexer and parser specified
  by ‘ada-process-parse-exec ’.
"
  ;; As of ada-mode version 6.2, we no longer support the elisp
  ;; parser. We may add a module implementation at some point.
  )

(defvar ada-fallback 'simple
  "Indicate fallback indentation engine for Ada buffers.

simple: indent to previous line.")

(provide 'ada-mode)

;;;;; Global initializations

(add-hook 'menu-bar-update-hook #'ada-project-menu-install)

(require 'ada-wisi)

(cl-case ada-xref-tool
  (gnat (require 'ada-gnat-xref))
  (gpr_query (require 'gpr-query))
  (t
   (if (locate-file "gpr_query" exec-path '("" ".exe"))
       (progn
         (require 'gpr-query)
         (setq ada-xref-tool 'gpr_query))
     (require 'ada-gnat-xref)
     (setq ada-xref-tool 'gnat)))
  )

(unless (featurep 'ada-compiler)
  (require 'ada-gnat-compile))

(unless (featurep 'ada-skeletons)
  (require 'ada-skel))

(when (featurep 'imenu)
  (require 'ada-imenu))

;;; ada-mode.el ends here
