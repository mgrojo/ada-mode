--  Abstract :
--
--  Root package for Wisi grammar compiler; see [2]
--
--  "wisi" used to be short for "Wisent Indentation engine", but now
--  it's just a name. The Emacs 'wisi' package implements an
--  indentation engine based on a parser table generated by
--  'wisi-generate' (written in Ada) and compiled by 'wisi-compile'
--  (written in elisp)..
--
--  The input file syntax is based on Gnu bison syntax [1] with
--  some additions. See [2] for the syntax accepted by wisi-generate
--  (the Ada code) and wisi-compile (elisp code).
--
--  Reference :
--
--  [1] http://www.gnu.org/software/bison/manual/ (info "(bison)Top")
--  [2] http://www.nongnu.org/ada-mode/wisi/wisi-user_guide.html, (info "(wisi-user_guide)Top")
--
--  Copyright (C) 2012 - 2015, 2017 Stephen Leake.  All Rights Reserved.
--
--  The FastToken package is free software; you can redistribute it
--  and/or modify it under terms of the GNU General Public License as
--  published by the Free Software Foundation; either version 3, or
--  (at your option) any later version. This library is distributed in
--  the hope that it will be useful, but WITHOUT ANY WARRANTY; without
--  even the implied warranty of MERCHANTABILITY or FITNESS FOR A
--  PARTICULAR PURPOSE.
--
--  As a special exception under Section 7 of GPL version 3, you are granted
--  additional permissions described in the GCC Runtime Library Exception,
--  version 3.1, as published by the Free Software Foundation.

pragma License (Modified_GPL);

with Ada.Characters.Handling;
with Ada.Containers.Doubly_Linked_Lists;
with Ada.Containers.Indefinite_Doubly_Linked_Lists;
with Ada.Strings.Unbounded;
with Ada.Text_IO;
package Wisi is

   User_Error : exception; -- error in command line options or parameters

   Syntax_Error : exception; -- Error in user input file

   Not_Found : exception;
   --  something not found; should be handled and converted to Syntax_ or Programmer_Error

   Programmer_Error : exception; -- Error in Wisi Ada code

   type Parser_Algorithm_Type is (None, LALR, LR1, LALR_LR1);
   subtype Valid_Parser_Algorithm is Parser_Algorithm_Type range LALR .. LALR_LR1;
   subtype Single_Parser_Algorithm is Parser_Algorithm_Type range LALR .. LR1;

   type Output_Language_Type is (None, Ada, Ada_Emacs, Elisp);
   subtype Valid_Output_Language is Output_Language_Type range Ada .. Elisp;
   subtype Ada_Output_Language is Output_Language_Type range Ada .. Ada_Emacs;

   type Lexer_Type is (None, Aflex_Lexer, Elisp_Lexer, Regexp_Lexer);
   subtype Valid_Lexer is Lexer_Type range Aflex_Lexer .. Regexp_Lexer;
   --  We append "_Lexer" to these names to avoid colliding with the
   --  similarly-named FastToken packages. In the grammar file, they
   --  are named by:
   Lexer_Names : constant array (Valid_Lexer) of access constant String :=
     (Aflex_Lexer  => new String'("aflex"),
      Elisp_Lexer  => new String'("elisp"),
      Regexp_Lexer => new String'("regexp"));

   function To_Lexer (Item : in String) return Lexer_Type;
   --  Raises User_Error for invalid Item

   type Interface_Type is (None, Process, Module);
   subtype Valid_Interface is Interface_Type range Process .. Module;

   type Generate_Param_Type is record
      --  Set by grammar file declarations. Error recover parameters
      --  are elsewhere.
      Output_Language    : Output_Language_Type  := None;
      Parser_Algorithm   : Parser_Algorithm_Type := None;
      Lexer              : Lexer_Type            := None;
      Interface_Kind     : Interface_Type        := None;
      First_State_Index  : Integer               := 0;
      First_Parser_Label : Integer               := 0;
      Start_Token        : Standard.Ada.Strings.Unbounded.Unbounded_String;
   end record;

   type String_Pair_Type is record
      Name  : Standard.Ada.Strings.Unbounded.Unbounded_String;
      Value : Standard.Ada.Strings.Unbounded.Unbounded_String;
   end record;

   package String_Pair_Lists is new Standard.Ada.Containers.Doubly_Linked_Lists (String_Pair_Type);

   type McKenzie_Recover_Param_Type is record
      Default_Insert : Float   := 0.0;
      Default_Delete : Float   := 0.0;
      Insert         : String_Pair_Lists.List;
      Enqueue_Limit  : Integer := Integer'Last;

      --  For special rules
      Dot_ID        : Standard.Ada.Strings.Unbounded.Unbounded_String;
      Identifier_ID : Standard.Ada.Strings.Unbounded.Unbounded_String;
   end record;

   type Token_Kind_Type is record
      Kind   : Standard.Ada.Strings.Unbounded.Unbounded_String;
      Tokens : String_Pair_Lists.List;
   end record;

   package Token_Lists is new Standard.Ada.Containers.Doubly_Linked_Lists (Token_Kind_Type);

   function Count (Tokens : in Token_Lists.List) return Integer;

   procedure Add_Token
     (Tokens : in out Token_Lists.List;
      Kind   : in     String;
      Name   : in     String;
      Value  : in     String);
   --  Add Name, Value to Kind list in Tokens.

   function Is_In (Tokens : in Token_Lists.List; Kind : in String) return Boolean;
   function Is_In
     (Tokens : in Token_Lists.List;
      Kind   : in String;
      Value  : in String)
     return Boolean;

   type Conflict is record
      Action_A    : Standard.Ada.Strings.Unbounded.Unbounded_String;
      LHS_A       : Standard.Ada.Strings.Unbounded.Unbounded_String;
      Action_B    : Standard.Ada.Strings.Unbounded.Unbounded_String;
      LHS_B       : Standard.Ada.Strings.Unbounded.Unbounded_String;
      On          : Standard.Ada.Strings.Unbounded.Unbounded_String;
   end record;

   package Conflict_Lists is new Standard.Ada.Containers.Doubly_Linked_Lists (Conflict);

   package String_Lists is new Standard.Ada.Containers.Indefinite_Doubly_Linked_Lists (String);

   type RHS_Type is record
      Production : String_Lists.List; -- Tokens
      Action     : String_Lists.List; -- one string per line
   end record;
   package RHS_Lists is new Standard.Ada.Containers.Doubly_Linked_Lists (RHS_Type, "=");

   type Rule_Type is record
      Left_Hand_Side   : Standard.Ada.Strings.Unbounded.Unbounded_String;
      Right_Hand_Sides : RHS_Lists.List;
      Source_Line      : Standard.Ada.Text_IO.Positive_Count;
   end record;

   package Rule_Lists is new Standard.Ada.Containers.Doubly_Linked_Lists (Rule_Type);

   function "+" (Item : in String) return Standard.Ada.Strings.Unbounded.Unbounded_String
     renames Standard.Ada.Strings.Unbounded.To_Unbounded_String;

   function "-" (Item : in Standard.Ada.Strings.Unbounded.Unbounded_String) return String
     renames Standard.Ada.Strings.Unbounded.To_String;

   function To_Lower (Item : in String) return String
     renames Standard.Ada.Characters.Handling.To_Lower;

   function To_Upper (Item : in String) return String
     renames Standard.Ada.Characters.Handling.To_Upper;

   function To_Upper (Item : in Character) return Character
     renames Standard.Ada.Characters.Handling.To_Upper;

   function "+" (List : in String_Lists.List; Item : in String) return String_Lists.List;

   function String_To_String_List (Item : in String) return String_Lists.List;
   function "+" (Item : in String) return String_Lists.List renames String_To_String_List;

   function RHS_To_RHS_List (Item : in RHS_Type) return RHS_Lists.List;
   function "+" (Item : in RHS_Type) return RHS_Lists.List renames RHS_To_RHS_List;

   function "+" (List : in RHS_Lists.List; Item : in RHS_Type) return RHS_Lists.List;

   Verbosity : Integer := 0;

   procedure Put_Command_Line (Comment_Prefix : in String);
   --  Put command line to current output

end Wisi;
