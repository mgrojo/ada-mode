--  generated parser support file.
--  command line: wisi-generate.exe  --generate PACKRAT_GEN ADA ../../wisi/test/empty_production_3.wy
--

with WisiToken.Lexer.re2c;
with empty_production_3_re2c_c;
with Empty_Production_3_Actions; use Empty_Production_3_Actions;
with WisiToken.Parse.Packrat.Generated;
package body Empty_Production_3_Packrat_Gen_Main is

   package Lexer is new WisiToken.Lexer.re2c
     (empty_production_3_re2c_c.New_Lexer,
      empty_production_3_re2c_c.Free_Lexer,
      empty_production_3_re2c_c.Reset_Lexer,
      empty_production_3_re2c_c.Next_Token);

   use WisiToken;
   use WisiToken.Parse.Packrat;
   use WisiToken.Parse.Packrat.Generated;
   function Parse_wisitoken_accept
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_compilation_unit
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_mode
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_name
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;
   function Parse_parameter_specification
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type;

   function Parse_wisitoken_accept
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Pos_0_2  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (4)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (4)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (4, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  4.0: wisitoken_accept <= compilation_unit Wisi_EOI
      Pos := Last_Pos;
      Memo_0_1 := Parse_compilation_unit (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      if Parser.Terminals (Pos + 1).ID = 3 then
         Pos := Pos + 1;
         Pos_0_2 := Pos;
         Parser.Derivs (4).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (4, 0),
                Action          => null,
                Children        =>
                 (Memo_0_1.Result,
                  Tree_Index (Pos_0_2)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      Parser.Derivs (4).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (4)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (4)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (4)(Start_Pos);
   end Parse_wisitoken_accept;

   function Parse_compilation_unit
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Memo_0_1 : Memo_Entry;
      Memo_0_2 : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (5)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (5)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (5, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  5.0: compilation_unit <= parameter_specification parameter_specification
      Pos := Last_Pos;
      Memo_0_1 := Parse_parameter_specification (Parser, Pos);
      case Result_States'(Memo_0_1.State) is
      when Success =>
         Pos := Memo_0_1.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      Memo_0_2 := Parse_parameter_specification (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
         Parser.Derivs (5).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (5, 0),
                Action          => compilation_unit_0'Access,
                Children        =>
                 (Memo_0_1.Result,
                  Memo_0_2.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      Parser.Derivs (5).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (5)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (5)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (5)(Start_Pos);
   end Parse_compilation_unit;

   function Parse_mode
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (6)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (6)(Start_Pos);
         when Failure =>
            goto RHS_1_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (6, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  6.0: mode <= IN
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 1 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
         Parser.Derivs (6).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (6, 0),
                Action          => null,
                Children        => (1 => Tree_Index (Pos_0_1)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      --  6.1: mode <=
      Pos := Last_Pos;
      Parser.Derivs (6).Replace_Element
        (Start_Pos,
         (State              => Success,
          Result             => Parser.Tree.Add_Nonterm
            (Production      => (6, 1),
             Action          => null,
             Children        => (1 .. 0 => Syntax_Trees.Invalid_Node_Index),
             Default_Virtual => False),
          Last_Token      => Pos));
      goto Succeed;
      <<RHS_1_Fail>>

      Parser.Derivs (6).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (6)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (6)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (6)(Start_Pos);
   end Parse_mode;

   function Parse_name
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (7)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (7)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (7, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  7.0: name <= IDENTIFIER
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 2 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
         Parser.Derivs (7).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (7, 0),
                Action          => null,
                Children        => (1 => Tree_Index (Pos_0_1)),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      else
         goto RHS_0_Fail;
      end if;
      <<RHS_0_Fail>>

      Parser.Derivs (7).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (7)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (7)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (7)(Start_Pos);
   end Parse_name;

   function Parse_parameter_specification
     (Parser : in out Generated.Parser; Last_Pos : in Base_Token_Index) return Result_Type
   is
      Descriptor : WisiToken.Descriptor renames Parser.Trace.Descriptor.all;
      Start_Pos  : constant Token_Index := Last_Pos + 1; --  first token in current nonterm
      Pos        : Base_Token_Index := Last_Pos; --  last token parsed.
      Pos_0_1  : Token_Index;
      Memo_0_2 : Memo_Entry;
      Memo_0_3 : Memo_Entry;
   begin
      if Pos = Parser.Terminals.Last_Index then
         return (State => Failure);
      end if;
      declare
         Memo : Memo_Entry renames Parser.Derivs (8)(Start_Pos);
      begin
         case Memo.State is
         when Success =>
            return Parser.Derivs (8)(Start_Pos);
         when Failure =>
            goto RHS_0_Fail;
         when No_Result =>
            if Memo.Recursive then
               raise Recursive with Image (8, Descriptor) & Token_Index'Image (Start_Pos) & ": recursive";
            end if;
            Memo.Recursive := True;
         end case;
      end;

      --  8.0: parameter_specification <= IDENTIFIER mode name
      Pos := Last_Pos;
      if Parser.Terminals (Pos + 1).ID = 2 then
         Pos := Pos + 1;
         Pos_0_1 := Pos;
      else
         goto RHS_0_Fail;
      end if;
      Memo_0_2 := Parse_mode (Parser, Pos);
      case Result_States'(Memo_0_2.State) is
      when Success =>
         Pos := Memo_0_2.Last_Token;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      Memo_0_3 := Parse_name (Parser, Pos);
      case Result_States'(Memo_0_3.State) is
      when Success =>
         Pos := Memo_0_3.Last_Token;
         Parser.Derivs (8).Replace_Element
           (Start_Pos,
            (State              => Success,
             Result             => Parser.Tree.Add_Nonterm
               (Production      => (8, 0),
                Action          => null,
                Children        =>
                 (Tree_Index (Pos_0_1),
                  Memo_0_2.Result,
                  Memo_0_3.Result),
                Default_Virtual => False),
             Last_Token      => Pos));
         goto Succeed;
      when Failure =>
         goto RHS_0_Fail;
      end case;
      <<RHS_0_Fail>>

      Parser.Derivs (8).Replace_Element (Start_Pos, (State => Failure));
      return Parser.Derivs (8)(Start_Pos);

      <<Succeed>>
      if WisiToken.Trace_Parse > Detail then
         Parser.Trace.Put_Line
           (Parser.Tree.Image
             (Parser.Derivs (8)(Start_Pos).Result, Descriptor, Include_Children => True));
      end if;
      return Parser.Derivs (8)(Start_Pos);
   end Parse_parameter_specification;

   function Parse_wisitoken_accept_1
     (Parser : in out WisiToken.Parse.Base_Parser'Class; Last_Pos : in Base_Token_Index) return Result_Type
   is begin
      return Parse_wisitoken_accept (Generated.Parser (Parser), Last_Pos);
   end Parse_wisitoken_accept_1;

   function Create_Parser
     (Trace     : not null access WisiToken.Trace'Class;
      User_Data : in     WisiToken.Syntax_Trees.User_Data_Access)
     return WisiToken.Parse.Base_Parser'Class
   is begin
      return Parser : WisiToken.Parse.Packrat.Generated.Parser do
         Parser.Trace := Trace;
         Parser.Lexer := Lexer.New_Lexer (Trace);
         Parser.User_Data := User_Data;
         Parser.Parse_WisiToken_Accept := Parse_wisitoken_accept_1'Access;
      end return;
   end Create_Parser;

end Empty_Production_3_Packrat_Gen_Main;
