--  generated parser support file.
--  command line: wisi-generate.exe -v 1 --output_language Ada_Emacs --lexer re2c --interface process
--  ../wisi/test/subprograms.wy
--

--  Copyright (C) 2013, 2017, 2018 Stephen Leake.  All Rights Reserved.

--  This program is free software; you can redistribute it and/or
--  modify it under the terms of the GNU General Public License as
--  published by the Free Software Foundation; either version 3, or (at
--  your option) any later version.
--
--  This software is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--  General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

with WisiToken.Wisi_Runtime; use WisiToken.Wisi_Runtime;
with WisiToken.Wisi_Runtime.Subprograms; use WisiToken.Wisi_Runtime.Subprograms;
package body Subprograms_Process_Actions is

   use WisiToken.Semantic_Checks;
   use all type Motion_Param_Array;

   procedure block_1
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         Statement_Action (Parse_Data, Tree, Nonterm, Tokens, ((3, Motion), (4, Motion)));
      when Face =>
         null;
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, 0))), (False, (Simple, (Int, Subp_Indent))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, Subp_Indent))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, 0)))));
      end case;
   end block_1;

   procedure loop_statement_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         null;
      when Face =>
         Face_Remove_Action (Parse_Data, Tree, Nonterm, Tokens, (1 => 4));
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, -Subp_Indent))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, Subp_Indent - Subp_Indent_Broken))), (False, (Simple, (Int, Subp_Indent))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, 0)))));
      end case;
   end loop_statement_0;

   procedure name_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         null;
      when Face =>
         Face_Mark_Action (Parse_Data, Tree, Nonterm, Tokens, (1 => (1, Suffix)));
      when Indent =>
         null;
      end case;
   end name_0;

   function name_0_check
    (Lexer   : access constant WisiToken.Lexer.Instance'Class;
     Nonterm : in out WisiToken.Recover_Token;
     Tokens  : in     WisiToken.Recover_Token_Array)
    return WisiToken.Semantic_Checks.Check_Status
   is
      pragma Unreferenced (Lexer);
   begin
      return Propagate_Name (Nonterm, Tokens, 1);
   end name_0_check;

   procedure name_1
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         null;
      when Face =>
         Face_Mark_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, Prefix), (3, Suffix)));
      when Indent =>
         null;
      end case;
   end name_1;

   function name_1_check
    (Lexer   : access constant WisiToken.Lexer.Instance'Class;
     Nonterm : in out WisiToken.Recover_Token;
     Tokens  : in     WisiToken.Recover_Token_Array)
    return WisiToken.Semantic_Checks.Check_Status
   is
      pragma Unreferenced (Lexer);
   begin
      return Merge_Names (Nonterm, Tokens, 1, 3);
   end name_1_check;

   procedure parameter_list_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         Statement_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, Misc), (2, Misc)));
      when Face =>
         null;
      when Indent =>
         null;
      end case;
   end parameter_list_0;

   procedure parameter_list_2
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         Statement_Action (Parse_Data, Tree, Nonterm, Tokens, (1 => (2, Misc)));
      when Face =>
         null;
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, 0))), (False, (Simple, (Anchored_0, 1, 1))), (False, (Simple, (Anchored_0, 1, 0)))));
      end case;
   end parameter_list_2;

   procedure subprogram_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         Statement_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, Statement_Start), (2, Name), (3, Misc), (4, Motion), (5, Statement_End)));
         Containing_Action (Parse_Data, Tree, Nonterm, Tokens, 1, 2);
         Containing_Action (Parse_Data, Tree, Nonterm, Tokens, 1, 4);
         Motion_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, Empty_IDs) & (4, 5 & 11) & (5, Empty_IDs)));
      when Face =>
         Face_Apply_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, 3, 0), (2, 1, 2)));
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, 0))), (True, (Simple, (Int, Subp_Indent_Broken)), (Simple, (Int, Subp_Indent_Broken))), (False, (Simple, (Language, Function_1'Access, +2 * Subp_Indent_Broken))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, 0)))));
      end case;
   end subprogram_0;

   procedure subprogram_1
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         Statement_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, Statement_Start), (2, Name), (6, Statement_End)));
         Containing_Action (Parse_Data, Tree, Nonterm, Tokens, 1, 2);
      when Face =>
         Face_Apply_Action (Parse_Data, Tree, Nonterm, Tokens, ((1, 3, 0), (2, 1, 2)));
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, 0))), (False, (Simple, (Int, Subp_Indent_Broken))), (False, (Simple, (Int, Subp_Indent_Broken))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, 0))), (False, (Simple, (Int, 0)))));
      end case;
   end subprogram_1;

   procedure subtype_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         null;
      when Face =>
         Face_Apply_Action (Parse_Data, Tree, Nonterm, Tokens, (1 => (1, 1, 2)));
      when Indent =>
         null;
      end case;
   end subtype_0;

   procedure use_clause_0
    (User_Data : in out WisiToken.Syntax_Trees.User_Data_Type'Class;
     Tree      : in out WisiToken.Syntax_Trees.Tree;
     Nonterm   : in     WisiToken.Syntax_Trees.Valid_Node_Index;
     Tokens    : in     WisiToken.Syntax_Trees.Valid_Node_Index_Array)
   is
      Parse_Data : WisiToken.Wisi_Runtime.Parse_Data_Type renames WisiToken.Wisi_Runtime.Parse_Data_Type (User_Data);
   begin
      case Parse_Data.Post_Parse_Action is
      when Navigate =>
         null;
      when Face =>
         Face_Apply_List_Action (Parse_Data, Tree, Nonterm, Tokens, (1 => (2, 1, 2)));
      when Indent =>
         Indent_Action_0 (Parse_Data, Tree, Nonterm, Tokens, ((False, (Simple, (Int, 0))), (False, (Simple, (Int, Subp_Indent_Broken))), (False, (Simple, (Int, 0)))));
      end case;
   end use_clause_0;

end Subprograms_Process_Actions;
