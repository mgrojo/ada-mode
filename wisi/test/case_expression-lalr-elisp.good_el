;;; case_expression-lalr-elisp.el --- Generated parser support file  -*- lexical-binding:t -*-
;;; with command line: wisi-generate.exe ../../wisi/test/case_expression.wy LALR_LR1 Elisp

;; Copyright (C) 2013, 2015, 2017 Stephen Leake.  All Rights Reserved.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;  requires added by wisi-generate

(require 'wisi)
(require 'semantic/lex)
(require 'wisi-compile)

(defconst case_expression-lalr-elisp-keyword-table
  (semantic-lex-make-keyword-table
   '(
    ("range" . RANGE)
    ("when" . WHEN)
    )
   nil)
  "Table of language keywords.")

(defconst case_expression-lalr-elisp-token-table
  (semantic-lex-make-type-table
   '(
     ("punctuation"
      (DOT_DOT . "..")
      (EQUAL_GREATER . "=>")
      (TICK . "'")
     )
     ("number"
      (NUMBER_LITERAL . wisi-number-p)
     )
     ("symbol"
      (IDENTIFIER . "[a-zA-Z][0-9a-zA-Z_]*")
     )
    )
   nil)
  "Table of language tokens.")

(defconst case_expression-lalr-elisp-parse-table
   (wisi-compile-grammar
   '((DOT_DOT EQUAL_GREATER TICK NUMBER_LITERAL IDENTIFIER RANGE WHEN )
     ((case_expression
       ((WHEN discrete_choice EQUAL_GREATER factor )
        (setq wisi-test-success t)))
      (choice_expression
       ((choice_relation )))
      (choice_relation
       ((factor_list )))
      (discrete_choice
       ((choice_expression ))
       ((range_nt )))
      (factor
       ((IDENTIFIER ))
       ((NUMBER_LITERAL )))
      (factor_list
       ((factor )))
      (range_nt
       ((IDENTIFIER TICK RANGE ))
       ((factor_list DOT_DOT factor_list ))))
     [((default . error) (WHEN .  1))
      ((default . error) (NUMBER_LITERAL .  3) (IDENTIFIER .  4))
      ((default . error) (Wisi_EOI . accept))
      ((default . error) (DOT_DOT . (factor . 1)) (EQUAL_GREATER . (factor . 1)) (Wisi_EOI . (factor . 1)))
      ((default . error) (DOT_DOT . (factor . 0)) (EQUAL_GREATER . (factor . 0)) (TICK .  13))
      ((default . error) (EQUAL_GREATER . (discrete_choice . 0)))
      ((default . error) (EQUAL_GREATER . (choice_expression . 0)))
      ((default . error) (EQUAL_GREATER .  12))
      ((default . error) (DOT_DOT . (factor_list . 0)) (EQUAL_GREATER . (factor_list . 0)))
      ((default . error) (DOT_DOT .  11) (EQUAL_GREATER . (choice_relation . 0)))
      ((default . error) (EQUAL_GREATER . (discrete_choice . 1)))
      ((default . error) (NUMBER_LITERAL .  3) (IDENTIFIER .  15))
      ((default . error) (NUMBER_LITERAL .  3) (IDENTIFIER .  15))
      ((default . error) (RANGE .  14))
      ((default . error) (EQUAL_GREATER . (range_nt . 0)))
      ((default . error) (EQUAL_GREATER . (factor . 0)) (Wisi_EOI . (factor . 0)))
      ((default . error) (Wisi_EOI . (case_expression . 0)))
      ((default . error) (EQUAL_GREATER . (range_nt . 1)))]
     [((case_expression . 2))
      ((choice_expression . 5)(choice_relation . 6)(discrete_choice . 7)(factor . 8)(factor_list . 9)(range_nt . 10))
      nil
      nil
      nil
      nil
      nil
      nil
      nil
      nil
      nil
      ((factor . 8)(factor_list . 17))
      ((factor . 16))
      nil
      nil
      nil
      nil
      nil]))
  "Parser table.")

(provide 'case_expression-lalr-elisp)

;; end of file
