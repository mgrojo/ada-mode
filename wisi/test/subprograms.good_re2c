// -*- mode: C -*- generated by WisiToken Wisi from ../wisi/test/subprograms.wy
//  with command line: wisi-generate.exe -v 1 --output_language Ada_Emacs --lexer re2c --interface process
//  ../wisi/test/subprograms.wy
//

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct wisi_lexer
{
   unsigned char* buffer;           // input text, in utf-8 encoding
   unsigned char* buffer_last;      // last byte in buffer
   unsigned char* cursor;           // current byte
   unsigned char* byte_token_start; // byte position at start of current token
   size_t         char_pos;         // character position of current character
   size_t         char_token_start; // character position at start of current token
   unsigned char* marker;           // saved cursor
   size_t         marker_pos;       // saved character position
   unsigned char* context;          // saved cursor
   size_t         context_pos;      // saved character position
   int            verbosity;

} wisi_lexer;

#define YYCTYPE unsigned char

#define NO_ERROR 0
#define ERROR_unrecognized_character 1
wisi_lexer* subprograms_new_lexer
   (unsigned char* input, size_t length, int verbosity)
{
   wisi_lexer* result  = malloc (sizeof (wisi_lexer));
   result->buffer      = input;
   result->buffer_last = input + length - 1;
   result->cursor      = input;
   result->char_pos    = 1;
   result->verbosity   = verbosity;
   return result;
}

void
subprograms_free_lexer(wisi_lexer** lexer)
{
   free(*lexer);
   *lexer = 0;
}

void
subprograms_reset_lexer(wisi_lexer* lexer)
{
   lexer->cursor   = lexer->buffer;
   lexer->char_pos = 1;
}

static void debug(wisi_lexer* lexer, int state, unsigned char ch)
{
   if (lexer->verbosity > 0)
      {
      if (ch < ' ')
         printf ("lexer: %d, 0x%x\n", state, ch);
      else
         printf ("lexer: %d, '%c' 0x%x\n", state, ch, ch);
      }
}
#define YYDEBUG(state, ch) debug(lexer, state, ch)
#define YYCURSOR lexer->cursor

#define YYPEEK() (lexer->cursor <= lexer->buffer_last) ? *lexer->cursor : 4

#define DO_COUNT ((*lexer->cursor & 0xC0) != 0xC0) && (*lexer->cursor != 0x0D)

static void skip(wisi_lexer* lexer)
{
   if (lexer->cursor <= lexer->buffer_last) ++lexer->cursor;
   if (lexer->cursor <= lexer->buffer_last)
      if (DO_COUNT) ++lexer->char_pos;
}
#define YYSKIP() skip(lexer)
#define YYBACKUP() lexer->marker = lexer->cursor; lexer->marker_pos = lexer->char_pos
#define YYRESTORE() lexer->cursor = lexer->marker; lexer->char_pos = lexer->marker_pos
#define YYBACKUPCTX() lexer->context = lexer->cursor; lexer->context_pos = lexer->char_pos
#define YYRESTORECTX() lexer->cursor = lexer->context; lexer->char_pos = lexer->context_pos

int subprograms_next_token
  (wisi_lexer* lexer,
   int* id,
   size_t* byte_position,
   size_t* byte_length,
   size_t* char_position,
   size_t* char_length)
{
   int status = NO_ERROR;
   *id = 0;
   if (lexer->cursor > lexer->buffer_last)
   {
      *id       =  19;
      *byte_position = lexer->buffer_last - lexer->buffer;
      *byte_length   = 0;
      *char_position = lexer->char_token_start;
      *char_length   = 0;
      return status;
   }

   lexer->byte_token_start = lexer->cursor;
   if (DO_COUNT)
      lexer->char_token_start = lexer->char_pos;
   else
      lexer->char_token_start = lexer->char_pos + 1;

   while (*id == 0 && status == 0)
   {
/*!re2c
      re2c:yyfill:enable   = 0;

      WHITESPACE = [ \t];
      NEW_LINE = [\n];
      COMMENT = "--"[^\n]*;
      BEGIN = "begin";
      END = "end";
      EXCEPTION = "exception";
      FOR = "for";
      FUNCTION = "function";
      IN = "in";
      LOOP = "loop";
      PROCEDURE = "procedure";
      WHEN = "when";
      USE = "use";
      LEFT_PAREN = "(";
      RIGHT_PAREN = ")";
      COMMA = ",";
      DOT = ".";
      SEMICOLON = ";";
      SYMBOL = [a-zA-Z][0-9a-zA-Z_]*;

      WHITESPACE { lexer->byte_token_start = lexer->cursor;
          lexer->char_token_start = lexer->char_pos; continue; }
      NEW_LINE {*id =  1; continue;}
      COMMENT {*id =  2; continue;}
      BEGIN {*id =  3; continue;}
      END {*id =  4; continue;}
      EXCEPTION {*id =  5; continue;}
      FOR {*id =  6; continue;}
      FUNCTION {*id =  7; continue;}
      IN {*id =  8; continue;}
      LOOP {*id =  9; continue;}
      PROCEDURE {*id =  10; continue;}
      WHEN {*id =  11; continue;}
      USE {*id =  12; continue;}
      LEFT_PAREN {*id =  13; continue;}
      RIGHT_PAREN {*id =  14; continue;}
      COMMA {*id =  15; continue;}
      DOT {*id =  16; continue;}
      SEMICOLON {*id =  17; continue;}
      SYMBOL {*id =  18; continue;}

      [\x04] {*id =  19; continue;}
      * {status = ERROR_unrecognized_character; continue;}
*/
      }
   *byte_position = lexer->byte_token_start - lexer->buffer + 1;
   *byte_length   = lexer->cursor - lexer->byte_token_start;
   *char_position = lexer->char_token_start;
   if (DO_COUNT)
      *char_length = lexer->char_pos - lexer->char_token_start;
   else
      *char_length = lexer->char_pos - lexer->char_token_start + 1;
   return status;
   }
