--  All input texts from test_mckenzie_recover.adb, except the really pathological ones.
--  Useful for testing lalr vs lr1 recovery.

procedure Proc_1 is begin if A = 2 then end; end;

procedure Proc is begin Block_1: begin end; if A = 2 then end Block_2; end if; end Proc;

procedure Water is begin loop begin D; if A then if B then end if; exit when C; end; end loop; end Water;

procedure Debug is begin A;

procedure Debug is begin procedure Put_Top_10 is begin end Put_Top_10; begin end Debug;

procedure Check_1 is end begin end Check_1;

function Find_Path return Path is begin return Result : Path (1 .. Result_Length) end Find_Path;

procedure McKenzie_Recover is function Check (Data : McKenzie_Data) is begin end Check; begin end;

procedure Foo is begin for I in 1 To Result_Length loop end loop; end Foo;

procedure Test_CASE_1 is begin case I is when 1 => A; end;

procedure Test_CASE_2 is begin case I is when 1 => A; end Test_CASE_2;

procedure Test_IF is begin if A then B; end;

procedure Test_LOOP is begin for I in A loop B; end;

procedure Patterns is Ada.Containers.Indefinite_Doubly_Linked_Lists (Pattern);

procedure One is begin if  and B then C; end if; end;

procedure Journal_To_TSV is procedure Process_Text_File
is begin exception if then end if; end Process_Text_File; begin begin end; end Journal_To_TSV;

procedure Remove is begin loop A := B; loop; end Remove;

procedure Remove is begin A := "B"; A := "C" & at";
end Remove;

package body P is procedure Remove is begin A := B; exception end; end P; procedure Q;

package body P is procedure Remove is begin A := B; exception end; A := B; end Remove; end P; procedure Q;

package body P is procedure Remove is begin A := B; end; A := B; end Remove; end P; procedure Q;

package body P is procedure Remove is begin A := B; end; end P; procedure Q;

package body P is package body Remove is A : Integer; end; end P; procedure Q;

procedure Proc_1 is procedure Proc_2 is begin null; end; begin null; end Proc_1;

package body Debug is procedure Find_First is begin begin Match (Middle_Initial_Pat); end Find_First;

procedure Swap_Names is begin end Swap_Names; begin end Debug;

package body Debug is procedure A is end Debug;

procedure Journal_To_TSV is procedure Process_CSV_File is procedure To_Month is begin
begin end Process_CSV_File; begin end Journal_To_TSV;

procedure Journal_To_TSV is procedure Process_CSV_File is procedure To_Month is
procedure A is begin begin end Process_CSV_File; begin end Journal_To_TSV;

procedure Journal_To_TSV is procedure Process_CSV_File is begin begin
end Process_CSV_File; begin end Journal_To_TSV;

package body Pack_1 is procedure Proc_1 is procedure Proc_A is begin case B is when 1 => a;
begin end Proc_1; end Pack_1;

procedure Ada_Mode.Interactive_2 is procedure Proc_2 is begin null; begin null; end Ada_Mode.Interactive_2;

procedure Ada_Mode.Recover_6 is begin declare name : int; begin null; end Ada_Mode.Recover_6;

procedure Slow_Recover_2 is begin if 0 /= Input (Context, Name end Slow_Recover_2;

package body Debug is function Function_Access_1 (A_Param : Float) return Float is begin
type Wait_Return is (Read_Success,); end Debug;

procedure Handle_Search is begin if Is_Empty then return "text/html"; else 
Response := "</table>"</body></html>";
end if; end Handle_Search;

procedure Handle_Search is begin if Is_Empty then return ""text/html""; else
Response := "</table></body></html>;
end if; end Handle_Search;

procedure Handle_Search is begin if Is_Empty then return ""text/html""; else
Response := "</table>" & </body></html>";
end if; end Handle_Search;

procedure Quote_Unquote is begin Put_Line (Test_File, "8" & Tab & "nine");
Put_Line (ten" & Tab & " eleven"); Close (Test_File); end Quote_Unquote;
