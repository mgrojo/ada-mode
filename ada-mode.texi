\input texinfo  @c -*-texinfo-*-
@setfilename ../../info/ada-mode
@settitle Ada Mode

@copying
Copyright @copyright{} 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
2007, 2008, 2009, 2010, 2011, 2012, 2013  Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory Emacs editing modes
@direntry
* Ada mode: (ada-mode).         Emacs mode for editing and navigating Ada code.
@end direntry

@titlepage
@sp 10
@title{Ada Mode}
@sp 2
@subtitle An Emacs major mode for programming in Ada
@subtitle Ada Mode Version 4.01
@sp 2
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top, Overview, (dir), (dir)

@ifnottex
@insertcopying
@end ifnottex

@menu
* Overview::
* Installation::                Installing Ada mode on your system
* Customization::               Setting up Ada mode to your taste
* Compiling Executing::         Working with your application within Emacs
* Project files::               Describing the organization of your project
* Moving Through Ada Code::     Moving easily through Ada sources
* Identifier completion::       Finishing words automatically
* Indentation::                 Indenting your code automatically as you type
* Statement skeletons::
* Aligning code::
* Automatic Casing::            Adjusting the case of words automatically
* Comment Handling::            Reformatting comments easily
* GNU Free Documentation License::  The license for this documentation.
* Index::
@end menu

@node Overview, Installation, Top, Top
@chapter Overview

The Emacs mode for programming in Ada helps the user in reading
existing code and facilitates writing new code.

When the Gnu Ada compiler GNAT is used, the cross-reference
information output by the compiler is used to provide powerful code
navigation (jump to definition, find all uses, etc).

When you open a file with a file extension of @file{.ads} or
@file{.adb}, Emacs will automatically load and activate Ada
mode.

Ada mode works without any customization, if you are using the GNAT
compiler (@url{https://libre2.adacore.com/}) and the GNAT default
naming convention.

You must customize a few things if you are using a different compiler
or file naming convention;
@c FIXME: @xref{Other compiler},
@xref{Non-standard file names}.

In addition, you may want to customize the indentation,
capitalization, and other things; @xref{Other customization}.

Finally, for large Ada projects, you will want to set up an Emacs
Ada mode project file for each project; @xref{Project files}. Note
that these are different from the GNAT project files used by gnatmake
and other GNAT commands.

@xref{Running Debuggers Under Emacs,,Running Debuggers Under Emacs,emacs,Emacs User Guide}, for general
information on debugging.

@node Installation, Customization, Overview, Top
@chapter Installation

Ada mode is part of the standard Emacs distribution; if you use that,
no files need to be installed.

Ada mode is also available as a separate distribution, from the Emacs
Ada mode website
@uref{http://stephe-leake.org/emacs/ada-mode/emacs-ada-mode.html}. The
separate distribution may be more recent.

For installing the separate distribution, see the @file{README} file
in the distribution.

To see what version of Ada mode you have installed, do @kbd{M-x
ada-mode-version}.

@node Customization, Compiling Executing, Installation, Top
@chapter Customizing Ada mode

Here we assume you are familiar with setting variables in Emacs,
either thru 'customize' or in elisp (in your @file{.emacs} file). For
a basic introduction to customize, elisp, and Emacs in general, see
the tutorial (@key{C-h t}).

@menu
* Non-standard file names::
* Other customization::
@end menu

@node Non-standard file names, Other customization, Customization, Customization
@section Non-standard file names

By default, Ada mode is configured to use the GNAT file naming
convention, where file names are a simple modification of the Ada
names, and the extension for specs and bodies are
@samp{.ads} and @samp{.adb}, respectively.

Emacs uses the file extension to enable Ada mode; Ada mode uses the
file extentions to allow moving from a package body to the
corresponding spec and back.

Emacs and Ada mode support ways to use alternative file extensions for
specs and bodies.

For instance, if your spec and bodies files are called
@file{@var{unit}_s.ada} and @file{@var{unit}_b.ada}, respectively, you
can add the following to your @file{.emacs} file:

@example
;; Tell Ada mode about spec and body extensions
(ada-add-extensions "_s.ada" "_b.ada")

;; Tell Emacs to use Ada mode for those extensions
(add-to-list 'auto-mode-alist '("\\.ada\\'" . ada-mode))
@end example

You can define additional extensions:

@example
(ada-add-extensions ".ads" "_b.ada")
(ada-add-extensions ".ads" ".body")
@end example

This means that whenever Ada mode looks for the body for a file
whose extension is @file{.ads}, it will take the first available file
that ends with either @file{.adb}, @file{_b.ada} or
@file{.body}.

Simililarly, if Ada mode is looking for a spec, it will look for
@file{.ads} or @file{_s.ada}.

If the filename excluding the extension is not derived from the Ada
name following the GNAT convention, you need to provide an alternate
function for @code{ada-file-name-from-ada-name}. Doing that is beyond
the scope of this manual; see the current definitions in
@file{ada-mode.el} and @file{ada-gnat.el} for examples.

@node Other customization,  , Non-standard file names, Customization
@section Other customization

All user-settable Ada mode variables can be set via the menu
@samp{Ada | Customize}.  Click on the @samp{Help} button there for help
on using customize.

To modify a specific variable, you can directly call the function
@code{customize-variable}; just type @kbd{M-x customize-variable
@key{RET} @var{variable-name} @key{RET}}).

Alternately, you can specify variable settings in the Emacs
configuration file, @file{~/.emacs}. This file is coded in Emacs lisp,
and the syntax to set a variable is the following:
@example
(setq variable-name value)
@end example

Some general Emacs settings that are useful for Ada files:
@table @code
@item delete-trailing-whitespace
Deletes space, tab at end of line and blank lines at end of buffer.
@item untabify
Deletes tab characters that have crept into the file.
@item indent-tabs-mode
Don't insert tab characters when indenting.
@item copyright-update
Updates the copyright date in the file header comment, to the current year.
@end table

The above can all be set by the following code in your
@file{~/.emacs}. Note that these are functions that are added to
@code{before-save-hook}; they run just before a buffer is written to disk.
@example
(setq-default indent-tabs-mode nil)
(add-hook 'ada-mode-hook
   (lambda ()
    (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
    (add-hook 'before-save-hook 'copyright-update nil t)
    (add-hook 'before-save-hook
              (lambda () (untabify (point-min) (point-max)))
               nil t)))
@end example

@node Compiling Executing, Project files, Customization, Top
@chapter Compiling Executing

Ada mode currently assumes you use @code{make} to compile and run
programs, so it has no direct support for those operations.

@menu
* Compiler errors::
@end menu

@node Compiler errors,  , Compiling Executing, Compiling Executing
@section Compiler errors

Running @code{make} places compilation errors in a separate buffer named
@code{*compilation*}.

Each line in this buffer will become active: you can simply click on
it with the middle button of the mouse, or move point to it and press
@key{RET}. Emacs will then display the relevant source file and put
point on the line and column where the error was found.

You can also press the @kbd{C-x `} key (@code{next-error}), and Emacs
will jump to the first error. If you press that key again, it will
move you to the second error, and so on.

Some error messages also include references to other files. These
references are accessed via @key{C-c `}.

@node Project files, Moving Through Ada Code, Compiling Executing, Top
@chapter Project files

An Emacs Ada mode project file specifies what directories hold sources
for your project, and allows you to customize the compilation commands
and other things on a per-project basis.

The default file extension for Ada mode project files is
@file{*.adp}. You can use a different extension by adding it to
@code{ada-prj-parser-alist}.

Note that Ada mode project files @file{*.adp} are different than GNAT
compiler project files @samp{*.gpr}. However, Emacs Ada mode can use a
GNAT project file to specify the project directories. If no
other customization is needed, a GNAT project file can be used without
an Emacs Ada mode project file.

@menu
* Project File Overview::
* Project file variables::
@end menu

@node Project File Overview, Project file variables, Project files, Project files
@section Project File Overview

Project files have a simple syntax; they may be edited directly. Each
line specifies a project variable name and its value, separated by
``='' (spaces not allowed):
@example
src_dir=/Projects/my_project/src_1
src_dir=/Projects/my_project/src_2
@end example

Some variables (like @code{src_dir}) are lists; multiple occurrences
are concatenated.

There must be no space between the variable name and ``='', and no
trailing spaces.

The current project file is given by the lisp variable
@code{ada-prj-default-project-file}.

To set the project file, use the menu command @samp{Ada | Set Project
...}, or the elisp functions @code{ada-parse-prj-file,
ada-select-prj-file}. The latter can be added to a Makefile:

@example
# Local Variables:
# eval: (ada-parse-prj-file "ada-mode.prj")
# eval: (ada-select-prj-file ada-mode.prj")
# End:
@end example

You specify either a GNAT project file or an Emacs Ada mode project
file; if the file extension is @code{.gpr}, the file is treated as a
GNAT project file. Any other extension is treated as an Emacs Ada mode
project file.

After a project file is parsed, you can make it current again with
just @code{ada-select-prj-file}, or by selecting it from the menu.

@node Project file variables,  , Project File Overview, Project files
@section Project file variables

Some project file variables can also be defined in elisp variables.

To set a project variable that is a list, specify each element of the
list on a separate line in the project file.

Process environment variables can be referenced using the
normal @code{$var} syntax.

Most project variables have defaults that can be changed by setting
elisp variables; the table below identifies the lisp variable for each
project variable. Elisp variables corresponding to project variables
that are lists are elisp lists.

In general, project variables are evaluated when referenced in
Emacs Ada mode commands. Relative file paths are expanded to
absolute relative to the directory containing the project file.

Ada mode defines some project variables; others are defined by the
compiler.

Here is the list of variables valid for all compilers. In the default
values, the current directory @code{"."} is the directory containing
the project file.

@table @asis
@c These are the names that appear in the .adp file, which are the
@c same as the symbols used with ada-prj-get
@c
@c defined in ada-mode.el ada-prj-pars-file-1; alphabetical order
@c defaults defined in ada-mode.el ada-prj-default

@item @code{casing}         [default: @code{nil}]
List of files containing casing exceptions.
@c FIXME: @xref{Automatic casing}.

Lisp variable: @code{ada-case-exception-file}.

@item @code{src_dir}        [default: @code{"."}]
A list of directories to search for source files.

@end table

The following variables are valid with the GNAT compiler:

@table @asis
@c defined in ada-gnat.el ada-gnat-prj-parse-emacs-file; alphabetical order
@item @code{ada_project_path}   [default: @code{""}]
@c ada-prj-get 'prj_dir, 'proc_env
A list of directories to search for GNAT project files.

If set, the @code{ADA_PROJECT_PATH} process environment variable is
set to this value in the child process that runs GNAT tools. If not
set, @code{ADA_PROJECT_PATH} in the child process is inherited from
the Emacs process.

If you have the @code{ADA_PROJECT_PATH} environment variable set in
the Emacs process correctly for all of your projects, you do not need
to set this project variable.

@item @code{gpr_file}   [default: @code{""}]
The GNAT project file.

If set, the source and project directories specified in the GNAT
project file are appended to @code{src_dir} and
@code{ada_project_path}. This allows specifying Ada source directories
with a GNAT project file, and other source directories with the Emacs
project file.

@end table

@c @node Compiling Examples, Moving Through Ada Code, Project files, Top
@c @chapter Compiling Examples
@c FIXME: need something here

@node Moving Through Ada Code, Identifier completion, Project files, Top
@chapter Moving Through Ada Code

There are several commands to navigate through Ada code. All
these functions are available through the Ada menu and keybindings.

Some of these commands rely on facilities provided by the compiler;
the standard Emacs Ada mode only supports the GNAT compiler, but
others can be added.

@table @kbd
@item C-c C-d
@findex ada-goto-declaration
Move from any use of an identifier to its declaration, for from a declaration to
its body.

@item C-c M-d
@findex ada-goto-declaration-parent
Move from a child type declaration to the parent type declaration.

@item C-c C-n
@findex ada-next-statement-keyword
Move to the next keyword in the current statement.

For example, if point is on @samp{if}, move to @samp{then}.

@item C-c C-p
@findex ada-prev-statement-keyword
Move to the previous keyword in the current statement.

For example, if point is on @samp{then}, move to @samp{if}.

@item C-c C-o
@findex ada-find-other-file
Switch between corresponding spec and body. There are several special cases:
    @itemize @bullet
    @item
    If the region is active, it is assumed to contain an Ada package
    name; position point on the corresponding package declaration.

    @item
    If point is in the start line of a top level child package
    declaration (but not package body), or a child subprogram spec or
    body, position point on the corresponding parent package
    declaration.

    @item
    If point is in the start line of a top level separate body,
    position point on the corresponding separate stub declaration.

    @item
    If point is in a subprogram, position point on the corresponding
    declaration or body in the other file.

    @end itemize

@item C-c C-r
@findex ada-show-references
Show all references to the identifier surrounding point. Use
@kbd{C-x `} (@code{next-error}) to visit each reference (as for
compilation errors).

@item C-c C-x
@findex ada-show-overriding
Show all declarations that override the primitive procedure at
point. Use @kbd{C-x `} (@code{next-error}) to visit each reference (as
for compilation errors).

@end table

@node Identifier completion, Indentation, Moving Through Ada Code, Top
@chapter Identifier completion

Emacs provides a general way of completing identifiers: @kbd{M-/}
(bound to @code{dabbrev-expand}). This is an easy way to type faster:
you just have to type the first few letters of an identifier, and then
loop through all the possible completions.

@kbd{M-/} works by parsing all open Ada files for possible
completions.

For instance, if the words @samp{my_identifier} and @samp{my_subprogram}
are the only words starting with @samp{my} in any of the open Ada files,
then you will have this scenario:

@example
You type:  my@kbd{M-/}
Emacs inserts:  @samp{my_identifier}
If you press @kbd{M-/} once again, Emacs replaces @samp{my_identifier} with
@samp{my_subprogram}.
Pressing @kbd{M-/} once more will bring you back to @samp{my_identifier}.
@end example

This is a very fast way to do completion, and the casing of words will
also be respected.

@node Indentation, Statement skeletons, Identifier completion, Top
@chapter Indentation

Ada mode comes with a full set of rules for automatic indentation. You
can also configure the indentation, via the following variables:

@table @asis
@item @code{ada-indent}                  (default value: 3)
Number of columns for default indentation.

@item @code{ada-indent-broken}           (default value: 2)
Number of columns to indent the continuation of a broken line.

@item @code{ada-indent-comment-col-0}  (default value: nil)
If non-nil, comments currently starting in column 0 are left in column
0.  Otherwise, they are indented with previous comments or code.

@item @code{ada-indent-label}            (default value: -3)
Number of columns to indent a label.

@item @code{ada-indent-record-rel-type}  (default value: 3)
Indentation for @code{record} relative to @code{type} or @code{use}.

@item @code{ada-indent-renames}           (default value: 2)
Indentation for @code{renames} relative to the matching subprogram keyword.

If the subprogram has parameters then if @code{ada-indent-renames} is
zero or less the indentation is abs @code{ada-indent-renames} relative
to the open parenthesis; if @code{ada-indent-renames} is one or more
the indentation is relative to the line containing the keyword.

If the subprogram has no parameters then @code{ada-indent-broken} the
indentation is relative to the indentation of the line containing
the keyword.

@item @code{ada-indent-return}           (default value: 0)
Indentation for @code{return} relative to the matching
 @code{function}.

If the function has parameters, then if @code{ada-indent-return} is
zero or less the indentation is abs @code{ada-indent-return} relative
to the open parenthesis; if @code{ada-indent-return} is one or more,
indentation is relative to line containing @code{function}.

If the function has no parameters, @code{ada-indent-broken} is used
relative to line containing @code{function}.

@item @code{ada-indent-use}  (default value: ada-indent-broken)
Indentation for the lines in a @code{use} statement.

@item @code{ada-indent-when}             (default value: 3)
Indentation for @code{when} relative to @code{exception}, @code{case},
or @code{or} in @code{select}.

@item @code{ada-indent-with}             (default value: ada-indent-broken)
Indentation for the lines in a @code{with} context clause.

@end table

The following keys indent portions of the text:
@table @key

@item RET
Indents the new line.

@item TAB
Indent the current line, or the current region.

@item C-c TAB
Indents the current statement or declaration.
@end table

The indentation algorithm relies on a grammar parser to identify the
syntactic role for keywords and other words in the code. If the code
is accepted by the parser, the indentation is correct. If the code is
not accepted (because it is partially complete during editing), the
indentation engine falls back to the trivial algorithm of indenting
each new line the same as the previous line.

Once enough new text has been entered to make the code acceptable to
the parser, the statement or declaration is properly indented.

For example, if you are entering this code:

@example
if A then
   B;
end if;
@end example

when you type @key{RET B}, @code{B} is indented to the same column as
@code{if}. Then when you type the final @code{;}, all three lines are
indented, putting @code{B} where it belongs.

To be more user friendly, the parser
accepts a superset of the Ada grammer. For example, the parser accepts
this code for an @code{if} statement:

@example
if then
end if;
@end example

In general, any sequence of statements, and many expressions, may be
omitted.

One way to easily insert empty statements like this is using
@ref{Statement skeletons}.

@node Statement skeletons, Aligning code, Indentation, Top
@chapter Statement skeletons

@key{C-c C-e} expands the previous one or two words into a statment
skeleton. For example, @key{if C-c C-e} expands to:

@example
if  then
elsif  then
else
end if;
@end example

All skeleton expansions are accepted by the indentation parser, so
this is a convenient way to insert statements with correct
indentation.

For named statements (packages, loops, etc), the name is taken from
the word before point, and the name of statement from the word before
that. Some expansions prompt for more information, such as
whether a spec or body is desired. For example, @key{package A_Package
C-c C-e} first prompts for ``body'' or ``spec''. If ``spec'' is
selected, the following code is inserted:

@example
package A_Package is
private
end A_Package;
@end example

Named blocks work similarly: @key{declare A_Block C-c C-e} expands
(without prompting) to:

@example
A_Block:
   declare
   begin
   exception
   end A_Block;
@end example

Note that the order of the keyword @code{declare} and the name
@code{A_Block} are reversed in the expansion; this may take some
getting used to.

@node Aligning code, Automatic Casing, Statement skeletons, Top
@chapter Aligning code

Aligning code adds space in each line so that similar parts of
successive lines are aligned vertically. For example, a sequence of
declarations:

@example
A : Integer;
Another : Float := 1.0;
More : Integer := 2;
@end example

changes to this when aligned:

@example
A       : Integer;
Another : Float   := 1.0;
More    : Integer := 2;
@end example

Alignment is invoked by @key{C-c C-a}, which aligns the sequence of
statements surrounding point, or within the selected region.

Parameter lists are also aligned:

@example
   procedure Foo
     (A : in Integer;
      Another : out Float := 1.0;
      More : in out Integer := 2);
@end example

is aligned to:

@example
   procedure Foo
     (A       : in     Integer;
      Another :    out Float   := 1.0;
      More    : in out Integer := 2);
@end example

@node Automatic Casing, Comment Handling, Aligning code, Top
@chapter Automatic Casing

Casing of identifiers, attributes and keywords is automatically
performed while typing when the variable @code{ada-auto-case} is
non-nil. Every time you type a word separator, the previous word is
automatically cased.

You can customize the automatic casing with the following variables:

@table @code
@item ada-case-keyword
Value must be one of:
@table @code
@item downcase-word
Ada keywords will be lowercase.

@item upcase-word
Ada keywords will be uppercase.
@end table

@item ada-case-strict
If non-nil, all identifiers are forced to @code{Mixed_Case}; first
letter, and letter following ``_'' are uppercase; rest are
lowercase.

If nil, the mixed case characters in identifiers are forced to upper
case, but the other characters are not modified. That allows typing
all uppercase identifiers without defining an exception.
@end table

You can define exceptions to these rules, in files specified by the
variable @code{ada-case-exception-file}. Each line in a case exception
file specifies the casing of one word or word fragment.

If the word starts with an asterisk (@code{*}), it defines the casing
of a word fragemnt (or ``substring''); part of a word between two
underscores or word boundary.

For example:

@example
DOD
*IO
GNAT
@end example

The word fragment @code{*IO} applies to any word containing ``_io'';
@code{Text_IO}, @code{Hardware_IO}, etc.

@findex ada-case-create-exception
There are two ways to add new items to this file: you can simply edit
it as you would edit any text file. Or you can position point on the
word you want to add, and select menu @samp{Ada | Casing | Create full
exception} (@kbd{C-c C-y}, @code{ada-case-create-exception}) or
@samp{Ada | Casing | Create partial exception} (@kbd{C-c C-M-y}).  The
word will be added to the current list of exceptions and
to the file.

It is sometimes useful to have multiple exception files. For
example, one could be the standard Ada acronyms, the second some
company specific exceptions, and the last one some project specific
exceptions. If you set up the variable @code{ada-case-exception-file}
as a list of files, each of them will be parsed and used in your emacs
session. When you create a new exception, you are prompted for the
file to save it in.

Other keys and menu entries are defined:

@table @kbd
@item C-c C-w
@findex ada-case-adjust-at-point
Adjust case of the word at point. With prefix arg, adjust case even if
in comment. Normally, comments are not affected by case adjust.

@item Ada | Casing | Adjust case region
Adjust case in the active region.

@item Ada | Casing | Adjust case buffer
Adjust case in the active buffer.

@end table

@node Comment Handling, GNU Free Documentation License, Automatic Casing, Top
@chapter Comment Handling

By default, comment lines get indented like Ada code. There are a few
additional functions to handle comments:

@table @kbd
@item M-;
@findex comment-dwim
If the region is active, comment or uncomment it.

If the current line is empty, start a comment.

Otherwise, add a comment at the end of the line, in a column given by
@code{comment-column}.

@item M-q
@findex fill-paragraph
Fill the current comment paragraph.
@end table

@c FIXME: key summary

@node GNU Free Documentation License, Index, Comment Handling, Top
@appendix GNU Free Documentation License
@include doclicense.texi

@node Index,  , GNU Free Documentation License, Top
@unnumbered Index

@printindex fn

@bye
