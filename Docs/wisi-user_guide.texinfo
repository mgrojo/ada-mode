\input texinfo
@c Author : Stephen Leake stephen_leake@stephe-leake.org
@c Web    : http://stephe-leake.org/ada/opentoken.html
@setfilename wisi-generate
@settitle wisi-generate User Guide

@copying
Copyright @copyright{} 2014-2015, 2017 Stephen Leake.

@quotation
Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, no Front-Cover Texts and
no Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".
@end quotation
@end copying

@dircategory Parser generators
@direntry
* wisi-generate: (wisi-generate).         Ada and Elisp parser generator
@end direntry

@titlepage
@sp 10
@title wisi-generate User Guide
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@node Top
@top Wisi User Guide

@ifnottex
@insertcopying
@end ifnottex

@menu
* Overview::
* Common grammar problems::
* Syntax::
@end menu

@node Overview
@chapter Overview

Wisi is an add-on to WisiToken, that allows using Bison-style input
files, and generates either WisiToken Ada source, or elisp source for
the elisp wisi parser.

At one point, ``wisi'' was short for ``Wisent Indentation engine'';
the Emacs 'wisi' package implements an indentation engine that used to
be based on the Emacs wisent parser. However, that parser has now been
replaced by a generalized LALR parser, so ``wisi'' is just a name.

The WisiToken grammar compiler @code{wisi-generate} reads a grammar file in
wisi syntax, and outputs a compiled grammar in elisp format; it can
then be used by wisi-parse.

Alternately, wisi-generate can output Ada code, for use with the
WisiToken parser run-time.

@node Install
WisiToken is available as source code only.

To use the Ada runtime, you will also need to install a
lexer. WisiToken supports Aflex, Quex, and re2c, and other lexers can
be added.

Aflex is available as source from the same location as WisiToken.

Quex is available from
@url{https://sourceforge.net/projects/quex/}. It requires 32 bit
characters as input; we use @code{GNATCOLL.Iconv} to convert from
other formats. That requires the @code{libiconv} library. On Linux,
use the package manager to install the appropriate development
package. On Windows, one way to get @code{libiconv} is to install
MingW32 (@url{http://www.msys2.org/}), use its package manger to install
@code{libiconv}, then copy the @code{libiconv} files to the GNAT
installation:

@example
cp d:/msys64/mingw32/include/iconv.h d:/Apps/GNAT-gpl_2016/include/
cp d:/msys64/mingw32/lib/libiconv.a  d:/Apps/GNAT-gpl_2016/lib/gcc/i686-pc-mingw32/4.9.4/
@end example

In some future version, GNAT will probably include @code{libiconv} in
the Windows install, since some of their tools require it.

re2c is avaialble from
@url{https://sourceforge.net/projects/re2c/}. WisiToken uses the
environment variable @var{RE2C_HOME} to locate re2c.

@node Common grammar problems
@chapter Common grammar problems

LALR grammars are tricky. Here we describe some common problems people
run into.

@menu
* Empty choice in list::
@end menu

@node Empty choice in list
@section Empty choice in list

Many programming languages have lists in the grammar. For example, Ada
has lists of declarations:

@example
package_body
  : PACKAGE name IS declaration_list BEGIN statement_list END SEMICOLON
  ;

declaration_list
  : declaration
  | declaration_list declaration
  ;

declaration
  : object_declaration
  | subprogram_declaration
  ;; ...
  ;
@end example

Note that the above grammar fragment does not allow an empty
declaration_list. But Ada does, so the question is how can we add that
to the grammar.

There are four choices:

@enumerate
@item
Add an empty declaration choice to declaration_list:

@example
declaration_list
  : ;; empty list
  | declaration
  | declaration_list declaration
  ;
@end example
This is now redundant; since declaration_list can be empty, the second
choice is not needed:
@example
declaration_list
  : ;; empty list
  | declaration_list declaration
  ;
@end example


@item
Add an empty declaration choice to declaration:

@example
declaration
  : ;; empty declaration
  | object_declaration
  | subprogram_declaration
  ;; ...
  ;
@end example

@item
Add another rule with the empty production:

@example
package_body
  : PACKAGE name IS declarative_part BEGIN statement_list END SEMICOLON
  ;

declarative_part
  : ;; empty
  | declaration_list
  ;

declaration_list
  : declaration
  | declaration_list declaration
  ;

declaration
  : object_declaration
  | subprogram_declaration
  ;; ...
  ;
@end example

@item
Add another choice in package_body that leaves out declaration_list:
@example
package_body
  : PACKAGE name IS declaration_list BEGIN statement_list END SEMICOLON
  | PACKAGE name IS BEGIN statement_list END SEMICOLON
  ;
@end example
@end enumerate

Choice 1 is redundant, giving parse errors at parse time.
Consider the following statements, where "<empty>" is used to indicate
an empty declaration:

1) package One is <empty> begin end ;
2) package One is package One is <empty> begin end ; begin end ;
3) package One is <empty> package One is <empty declaration> begin end ; begin end ;

In parsing 3), the second 'package' causes a shift/reduce conflict;
shift to start the nested declaration (as in 2), reduce to the empty
declaration. Both are correct according to the grammar.

Choice 2 leads to a shift/reduce conflict in the production for
package_body; implementing the wisi parser as a generalized LALR parser
allows it to handle this option.

Choice 2 is the preferred choice for Ada, since it involves the least
modifications to the original Ada grammar in the Ada reference manual.

@node Syntax
@chapter Syntax

The wisi input file syntax is the based on Wisent and Gnu bison syntax
with some additions and deletions (@pxref{Top,Bison,Overview,bison}).

The top level file structure is:
@verbatim
%{
PRE_PROLOGUE
%%
POST_PROLOGUE
%}

DECLARATIONS

%%
RULES
%%
@end verbatim

Comments are started by ``;;'' and terminated by end of line.

@menu
* Prologue::
* Declarations::
* Rules::
@end menu

@node Prologue
@section Prologue

The Prologue contains arbitrary code, copied verbatim into the
output.

For Elisp output, @code{wisi-generate} adds the necessary
@code{require} forms for the elisp lexer, parser, and wisi actions;
you only need to add add additional code if you use other
actions. Only the @code{PRE_PROLOGUE} is output; there is no need for
a @code{POST_PROLOGUE} in Elisp output.

For Ada output, the @code{PRE_PROLOGUE} section is output in the
context-clause (before the package declaration); the
@code{POST_PROLOGUE} is output after other package declarations, at
the end of the package spec.

@node Declarations
@section Declarations

The Declarations sections declares terminal tokens, conflicts, and
other parser parameters.

@menu
* Tokens::
* Other parser parameters::
* Conflicts::
@end menu

@node Tokens
@subsection Tokens
There are two types of tokens; keywords and other:

@verbatim
%keyword SEMICOLON ";"

%token <symbol> IDENTIFIER
%token <punctuation> TICK "'"
@end verbatim

``Keywords'' are reserved words in the target language; the Emacs wisi
and WisiToken lexers recognize them by the given string.

In the Emacs wisi lexer, the other token types are recognized by Emacs syntax
properties. These are the predefined token classes:

@table @code
@item <punctuation>
@verbatim
%token <punctuation> TICK "'"
@end verbatim
A string of characters that have punctuation syntax, and match the
token string.

@item <symbol>
@verbatim
%token <symbol> IDENTIFIER
@end verbatim
A string of characters that have word syntax, that match no other token.

@item <string-double>
@verbatim
%token <string-double> STRING_LITERAL
@end verbatim
A string of characters that have string syntax, with double quote delimiters.

@item <string-single>
@verbatim
%token <string-single> CHARACTER_LITERAL
@end verbatim
A string of characters that have string syntax, with single quote delimiters.

@item <number>
@verbatim
%token <number> NUMERIC_LITERAL ada-wisi-number-p ada-wisi
@end verbatim
A string of characters that have word syntax, recognized by the
function given in the third parameter. The fourth parameter is the
source file for the recognizer (included via @code{require}).

@item <whitespace>
@verbatim
%token <whitespace> WHITESPACE [ \t\n]
@end verbatim
Not used by the wisi lexer; required by the Ada lexer.

@item <line_comment>
@verbatim
%token <line_comment> COMMENT "--"[^\n]*[\n]
@end verbatim
Not used by the wisi lexer; required by the Ada lexer. The third
argument is the regular expression to recognize the entire comment.

@end table

@node Error recovery
@subsection Error recovery

@table @code
@item %mckenzie_cost_default <insert> <delete_terminal> <delete_nonterminal>
McKenzie error recovery default costs for insert and delete single
tokens; three floating point numbers. If not specified, default costs
are zero. Costs can be negative; they all add linearly.

@item %mckenzie_cost_insert <keyword> <cost>
McKenzie error recovery insert cost for a specific keyword.

@item %mckenzie_cost_delete <keyword> <cost>
McKenzie error recovery delete cost for a specific keyword.

@item %mckenzie_enqueue_limit <integer>
McKenzie error recovery limit on items enqueued; default max integer.
@c FIXME: describe mckenzie, panic more completely
@c FIXME: mckenzie special rules

@item %recover_pattern_1 <stack ID> <error ID> <expecting ID>
If enter error recovery with <stack ID> on the parser stack, error
token <error ID>, and expecting <expecting ID>, then insert <expecting
ID> <error ID> <stack ID>.

This handles the 'missing end if' problem in languages like Ada.  We
are not likely to type 'end;' when meaning 'end if;'; we are more
likely to not be done entering an 'if then else end if' statement:
@example
begin
   if A > 0 then
      C := B / A;
   else
end;
@end example
So if the parser just pushed 'end' on the parse stack, and enters error
recovery on ';' expecting 'if', it is best to insert 'if; end':
@example
begin
   if A > 0 then
      C := B / A;
   else
end if; end;
@end example

@end table

@node Other parser parameters
@subsection Other parser parameters

@table @code
@item %start
The start token for the grammar.

@item %first_parser_label
The integer used to label the first of the parallel parsers;
defaults to 0.

@item %first_state_index
The integer used to label the first of the generated parser states;
defaults to 0.

@item %interface
The interface between the parser and Emacs; one of @code{Module |
Process}.

@item %lexer
The lexer; one of @code{elisp | regexp | re2c}.

@item %keywords_case_insensitive
If present, keywords are case insensitive in the lexer.

@item %output_language
The generator output language; one of:

@table @code
@item Ada
Generates stand-alone Ada code.

@item Ada_Emacs
Generates Ada code for an Emacs module or subprocess.

@item Elisp
Generates Elisp code, for the Emacs wisi parser.

@end table

@item %parser_algorithm
One of @code{LALR | LR1}.

Parser tables produces by LR1 can be significantly larger than LALR
tables. So far there is no reason to prefer LR1 over LALR; it is
supported to allow experimenting with error recovery; that may be
better with LR1 tables.

@item %panic_recover
Specifies a nonterminal used by ``panic mode'' error recovery; may be
repeated to specify more nonterminals. Determining appropriate
panic nonterminals for a particular grammar is an art.

@item %start
The start symbol for the grammar.

@end table

@node Conflicts
@subsection Conflicts

An example conflict declaration:
@verbatim
%conflict REDUCE/REDUCE in state abstract_limited_opt, abstract_limited_synchronized_opt on token NEW
@end verbatim

The conflict description is output by wisi-generate when an undeclared
conflict is detected; it can be copied into the grammar source file.

@node Rules
@section Rules

The rules section declares the non-terminal tokens, and the associated
production rules and actions.

The syntax of rules is:

@verbatim
{non-terminal} : {token} ... [action] | {token} ... [(action)] ;
@end verbatim

Each rule gives the expansion of a non-terminal token into a list of
tokens (both terminal and non-terminal); optional productions are
separated by ``|''. Each list of tokens is followed by an ``action'',
which is output-language code enclosed in parens, that will be
executed when the production is reduced.

@node Conditional code
@section Conditional code

The elisp and Ada lexers support different regular expression syntax,
so it is sometimes necessary to include or exclude some declarations
and portions of rules based on the lexer. That is done with @code{%if
... %end if}:
@verbatim
%if lexer = elisp
...
%end if
@end verbatim

The lines between @code{%if} and @code{%end if} are ignored if
the current lexer is not the one specified in the @code{%if}
condition.

@code{%if ... %end if} cannot be nested.

@bye
