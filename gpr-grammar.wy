;;; Wisi grammar for GNAT project files
;;
;; Copyright (C) 2013 Free Software Foundation, Inc.
;;
;; Author: Stephen Leake <stephe-leake@stephe-leake.org>
;; Maintainer: Stephen Leake <stephe-leake@stephe-leake.org>
;; Created: Jan 2013
;; Keywords: syntax
;;
;; This file is part of GNU Emacs.
;;
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;
;;; Commentary:
;;
;; This is a wisi grammar file for the gpr language. It is derived
;; from the Gnat Reference Manual (GRM), with the following substitutions:
;;
;; simple_name -> IDENTIFIER
;;
;; and some simplifications. Repeating constructs are implemented with
;; extra productions. Optional constructs are implemented by repeated
;; productions
;;
;; The GRM is available as (info "(gnat_ugn)") or at
;; http://libre.adacore.com/developers/documentation-single/gnat-users-guide
;;
;; see wisi.el for discussion of using the wisi parser for an
;; indentation engine.

;;; Prologue
%{
;; Copyright (C) 2013  Free Software Foundation, Inc.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or (at
;; your option) any later version.
;;
;; This software is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
%}

;; Declarations

;; token declarations

;; punctuation
%token <punctuation> AMPERSAND "&"
%token <punctuation> COLON ":"
%token <punctuation> COLON_EQUALS ":="
%token <punctuation> COMMA ","
%token <punctuation> DOT "."
%token <punctuation> EQUAL_GREATER "=>"
%token <punctuation> QUOTE "'"
%token <punctuation> SEMICOLON ";"
%token <punctuation> VERTICAL_BAR "|"

;; gpr keywords (info "(gnat_ugn)Project File Reference")

%keyword ABSTRACT "abstract"
%keyword AGGREGATE "aggregate"
%keyword CASE "case"
%keyword CONFIGURATION "configuration"
%keyword END "end"
%keyword EXTERNAL "external"
%keyword EXTERNAL_AS_LIST "external_as_list"
%keyword FOR "for"
%keyword IS "is"
%keyword LEFT_PAREN "("
%keyword LIBRARY "library"
%keyword NULL "null"
%keyword OTHERS "others"
%keyword PACKAGE "package"
%keyword PROJECT "project"
%keyword RIGHT_PAREN ")"
%keyword STANDARD "standard"
%keyword TYPE "type"
%keyword USE "use"
%keyword WHEN "when"
%keyword WITH "with"

%token <symbol> IDENTIFIER
%token <string-double> STRING_LITERAL

%start compilation_unit

%conflict SHIFT/REDUCE in state term, identifier_opt on token RIGHT_PAREN
%conflict SHIFT/REDUCE in state attribute_declaration, declarative_items on token FOR
%conflict SHIFT/REDUCE in state attribute_declaration, simple_declarative_items on token FOR
%conflict SHIFT/REDUCE in state case_item, case_items on token WHEN
%conflict SHIFT/REDUCE in state case_statement, declarative_items on token CASE
%conflict SHIFT/REDUCE in state case_statement, simple_declarative_items on token CASE
%conflict SHIFT/REDUCE in state package_spec, declarative_items on token PACKAGE
%conflict SHIFT/REDUCE in state simple_declarative_item, declarative_items on token IDENTIFIER
%conflict SHIFT/REDUCE in state simple_declarative_item, declarative_items on token NULL
%conflict SHIFT/REDUCE in state simple_declarative_item, simple_declarative_items on token IDENTIFIER
%conflict SHIFT/REDUCE in state simple_declarative_item, simple_declarative_items on token NULL
%conflict SHIFT/REDUCE in state typed_string_declaration, declarative_items on token TYPE

%%
;; grammar rules, non-terminal alphabetical order

aggregate
  : LEFT_PAREN string_list RIGHT_PAREN
    (progn
      (wisi-statement-action [1 open-paren 3 close-paren])
      (wisi-containing-action 1 2))
  ;

attribute_declaration
  : FOR IDENTIFIER USE expression SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 statement-other 5 statement-end])
      (wisi-containing-action 3 4))
  | FOR IDENTIFIER LEFT_PAREN STRING_LITERAL RIGHT_PAREN USE expression SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 open-paren 5 close-paren 6 statement-other 8 statement-end])
      (wisi-containing-action 6 7))
  ;

;; (info "(gnat_ugn)Attributes")
attribute_prefix
  : PROJECT
  | name
  ;

attribute_reference
  : attribute_prefix QUOTE IDENTIFIER
  | attribute_prefix QUOTE IDENTIFIER LEFT_PAREN STRING_LITERAL RIGHT_PAREN
    (wisi-statement-action [4 open-paren 6 close-paren])
  ;

;; (info "(gnat_ugn)Case Statements")
case_statement
  : CASE name IS case_items END CASE SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-start 5 block-end 7 statement-end])
      (wisi-containing-action 3 4))
  ;

;; declarations allowed in a case statement are a subset of
;; declarative_items, but this simplifies the grammar.
case_item
  : WHEN discrete_choice_list EQUAL_GREATER declarative_items
    (progn
      (wisi-statement-action [1 block-middle 3 block-start])
      (wisi-containing-action 3 4))
  ;

case_items
  : ;; empty
  | case_item
  | case_items case_item
  ;

compilation_unit
  : context_clause_opt project_qualifier_opt project_declaration_opt
  ;

context_clause
  : with_clause
  | context_clause with_clause
  ;

context_clause_opt
  : ;; empty
  | context_clause
  ;

;; (info "(gnat_ugn)Declarations")
declarative_item
  : simple_declarative_item
  | typed_string_declaration
  | package_declaration
  ;

declarative_items
  : ;; empty
  | declarative_item
  | declarative_items declarative_item
  ;

discrete_choice
  : ;; empty
  | STRING_LITERAL
  | OTHERS
  ;

discrete_choice_list
  : discrete_choice
  | discrete_choice_list VERTICAL_BAR discrete_choice
  ;

;; (info "(gnat_ugn)Expressions")
expression
  : term
  | expression AMPERSAND term
  ;

external_value
  : EXTERNAL aggregate
  | EXTERNAL_AS_LIST aggregate
  ;

identifier_opt
  : ;; empty
  | IDENTIFIER
  ;

name
  : identifier_opt
  | name DOT IDENTIFIER
  ;

project_declaration_opt
  : ;; empty
  | simple_project_declaration
 ;;  | project_extension
  ;

;; (info "(gnat_ugn)Packages")
package_declaration
  : package_spec
  ;; | package_renaming
  ;; | package_extension
  ;

package_spec
  : PACKAGE identifier_opt IS simple_declarative_items END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-start 5 block-end 7 statement-end])
      (wisi-containing-action 3 4))
  ;

;; package_renaming ::==
;;   package <package_>simple_name renames <project_>simple_name.package_identifier ;
;; package_extension ::==
;;   package <package_>simple_name extends <project_>simple_name.package_identifier is
;;     {simple_declarative_item}
;;   end package_identifier ;

;; (info "(gnat_ugn)Qualified Projects")
project_qualifier_opt
  : ;; empty
  | ABSTRACT
  | STANDARD
  | AGGREGATE
  | AGGREGATE LIBRARY
  | LIBRARY
  | CONFIGURATION
  ;

;; (info "(gnat_ugn)Declarations" "*info gpr*")
simple_declarative_item
  : IDENTIFIER COLON_EQUALS expression SEMICOLON ;; variable_declaration
    (progn
      (wisi-statement-action [1 statement-start 4 statement-end])
      (wisi-containing-action 1 3))
  | IDENTIFIER COLON IDENTIFIER COLON_EQUALS expression SEMICOLON ;; typed_variable_declaration
    (progn
      (wisi-statement-action [1 statement-start 6 statement-end])
      (wisi-containing-action 1 5))
  | attribute_declaration
  | case_statement
  | NULL SEMICOLON
    (wisi-statement-action [1 statement-start 2 statement-end])
  ;

simple_declarative_items
  : ;; empty
  | simple_declarative_item
  | simple_declarative_items simple_declarative_item
  ;

simple_project_declaration
  : PROJECT identifier_opt IS declarative_items END identifier_opt SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 3 block-start 5 block-end 7 statement-end])
      (wisi-containing-action 3 4))
  ;

;; (info "(gnat_ugn)Expressions")
string_expression
  : string_primary
  ;

string_primary
  : STRING_LITERAL
  | name;; variable_name
  | external_value
  | attribute_reference
  ;

;; (info "(gnat_ugn)Expressions")
;; we merge that string_list into term, and use 'string_list' for 'string_expression {, string_expression}'
string_list
  : expression
  | string_list COMMA expression
    (progn
      (wisi-statement-action [2 list-break])
      (wisi-containing-action 2 3))
  ;

;; see string_list for info reference
;; string_variable_name covered by string_expression
term
  : string_expression
  | LEFT_PAREN RIGHT_PAREN
  | aggregate
  ;

typed_string_declaration
  : TYPE IDENTIFIER IS aggregate SEMICOLON
    (progn
      (wisi-statement-action [1 statement-start 5 statement-end])
      (wisi-containing-action 1 4))
  ;

with_clause
  : WITH string_list SEMICOLON
  ;

%%

;; Local Variables:
;; eval: (add-hook 'before-save-hook 'delete-trailing-whitespace nil t)
;; End:
;;; end of file
