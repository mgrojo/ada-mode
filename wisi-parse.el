;; Wisi parser
;;
;; An extended LALR parser, that handles shift/reduce and
;; reduce/reduce conflicts by spawning parallel parsers to follow each
;; path.

(require 'semantic/wisent)
(require 'cl)

(defstruct (wisi-parser-state
	    (:copier nil))
  active
  ;; 'shift  - need new token
  ;; 'reduce - need reduce
  ;; 'accept - parsing completed
  ;; nil     - terminated

  stack
  ;; Each stack item takes two slots: (token-symbol token-text (token-start . token-end)), state
  ;; token-text is nil for nonterminals.
  ;; this is _not_ the same as the wisent-parse stack; that leaves out token-symbol.

  sp ;; stack pointer

  pending
  ;; list of (action-symbol stack-fragment)
  )

(defun wisi-parse (automaton lexer &optional error)
  "Parse input using the automaton specified in AUTOMATON.

- AUTOMATON is the parse table generated by `wisi-compile-grammar'.

- LEXER is a function with no argument called by the parser to
  obtain the next token in input, as a list (symbol text start
  . end), where `symbol' is the terminal symbol, `text' is the
  token string, `start . end' is the range in the buffer.

- ERROR is an optional reporting function called when a parse error
  occurs.  It receives a message string to report.  It defaults to the
  function `wisent-message'."
  (let* ((actions (aref automaton 0))
	 (gotos   (aref automaton 1))
	 (parser-states ;; vector of parallel parser states
	  (vector
	   (make-wisi-parser-state
	    :active  'shift
	    :stack   (make-vector wisent-parse-max-stack-size nil);; FIXME: grow stack dynamically, save per-buffer max
	    :sp      0
	    :pending nil)))
	 (active-parser-count 1)
         (wisent-parse-error-function (or error 'wisent-message))
	 (active nil)
	 (token (funcall lexer)))

    (aset (wisi-parser-state-stack (aref parser-states 0)) 0 0) ;; Initial state

    (while (not (eq active 'accept))
      (dotimes (i (length parser-states))
	(when (wisi-parser-state-active (aref parser-states i))
	  (let* ((parser-state (aref parser-states i))
		 (result (wisi-parse-1 token parser-state (> active-parser-count 1) actions gotos)))

	     (when result
	      ;; spawn a new parser
	      (let ((j (wisi-free-parser parser-states)))
		(when (= j -1)
		  (setq parser-states (vconcat parser-states (vector nil)))
		  (setq j (1- (length parser-states))))
		(setq active-parser-count (1+ active-parser-count))
		(aset parser-states j result)))

	     (when (eq 'error (wisi-parser-state-active parser-state))
	       ;; terminate this parser
	       (setf (wisi-parser-state-active parser-state) nil)
	       (setq active-parser-count (1- active-parser-count))
	       (case active-parser-count
		 (0
		  ;; FIXME: better error handling for input syntax
		  ;; error? not clear which parser(s) should try to
		  ;; continue past error.
		  ;; FIXME: at least a better message to the user
		  (error "no parsers left"))

		 (1
		  (wisi-execute-pending (wisi-parser-state-pending
					(aref parser-states (wisi-active-parser parser-states)))))
		 (t nil)))

	     )));; end dotimes

      (setq active (wisi-parsers-active parser-states active-parser-count))
      (when (eq active t)
	(setq token (funcall lexer)))
    )))

(defun wisi-parsers-active (parser-states active-count)
  "Return:
'accept : active-count = 1, and that element of PARSER-STATES has active set to 'accept
t       : all PARSER-STATES have active set to nil or 'shift.
nil     : otherwise."
  (let ((result nil)
	(i 0)
	(shift-count 0)
	active)
    (while (and (not result)
		(< i (length parser-states)))
      (setq active (wisi-parser-state-active (aref parser-states i)))
      (cond
	((eq active 'shift) (setq shift-count (1+ shift-count)))
	((eq active 'reduce) nil)
	((eq active 'accept) (when (eq active-count 1) (setq result 'accept)))
	)
      (setq i (1+ i)))

    (if result result (= shift-count active-count))))

(defun wisi-free-parser (parser-states)
  "Return index to a non-active parser in PARSER-STATES, -1 if there is none."
  (let ((result nil)
	(i 0))
    (while (and (not result)
		(< i (length parser-states)))
      (when (not (wisi-parser-state-active (aref parser-states i)))
	(setq result i))
      (setq i (1+ i)))
    (if result result -1)))

(defun wisi-active-parser (parser-states)
  "Return index to the first active parser in PARSER-STATES."
  (let ((result nil)
	(i 0))
    (while (and (not result)
		(< i (length parser-states)))
      (when (wisi-parser-state-active (aref parser-states i))
	(setq result i))
      (setq i (1+ i)))
    (unless result
      (error "no active parsers"))
    result))

(defun wisi-execute-pending (pending)
  (while pending
    (apply 'funcall (pop pending))))

(defun wisi-parse-1 (token parser-state pendingp actions gotos)
  "Perform one shift or reduce on PARSER-STATE.
If PENDINGP, push actions onto PARSER-STATE.pending; otherwise execute them.
See `wisi-parse' for full details.
Return nil or new parser (a wisi-parse-state struct)."
  (let* ((state (aref (wisi-parser-state-stack parser-state)
		(wisi-parser-state-sp parser-state)))
	 (parse-action (wisent-parse-action (car token) (aref actions state)))
	 new-parser-state)

    (when (and (listp parse-action)
	       (listp (car parse-action)))
      ;; conflict; spawn a new parser
      (setq new-parser-state
	    (make-wisi-parser-state
	     :active  nil
	     :stack   (vconcat (wisi-parser-state-stack parser-state))
	     :sp      (wisi-parser-state-sp parser-state)
	     :pending (wisi-parser-state-pending parser-state)))

      (setf (wisi-parser-state-active new-parser-state)
	    (wisi-parse-2 (cadr parse-action) token new-parser-state gotos t))
      (setq pendingp t)
      (setq parse-action (car parse-action))
      );; when

    ;; current parser
    (setf (wisi-parser-state-active parser-state)
	  (wisi-parse-2 parse-action token parser-state pendingp gotos))

    new-parser-state))

(defun wisi-parse-2 (action token parser-state pendingp gotos)
  "Execute parser ACTION (must not be a conflict).
Return one of 'accept, 'error, 'shift 'reduce."
  (cond
   ((eq action 'accept)
    'accept)

   ((eq action 'error)
    'error)

   ((natnump action)
    ;; Shift token and new state (= action) onto stack
    (let ((stack (wisi-parser-state-stack parser-state)); reference
	  (sp (wisi-parser-state-sp parser-state))); copy
      (setq sp (+ sp 2))
      (aset stack (1- sp) token)
      (aset stack sp action)
      (setf (wisi-parser-state-sp parser-state) sp))
    'shift)

   (t
    (wisi-parse-reduce action parser-state pendingp gotos)
    'reduce)))

(defun wisi-nonterm-bounds (stack i j)
  "Return a pair (START . END), the buffer region for a nonterminal.
STACK is the parser stack.  I and J are the indices in STACK of
the first and last tokens of the nonterminal."
  (let ((start (caddr (aref stack i)))
        (end   (cdddr (aref stack j))))
    (while (and (or (not start) (not end))
		(/= i j))
      (cond
       ((not start)
	;; item i is an empty production
	(setq start (cadr (aref stack (setq i (+ i 2))))))

       ((not end)
	;; item j is an empty production
	(setq end (cddr (aref stack (setq j (- j 2))))))

       (t (setq i j))))
    (and start end (cons start end))))

(defun wisi-parse-reduce (action parser-state pendingp gotos)
  "Reduce PARSER-STATE.stack, and execute or pend ACTION."
  (let* ((stack (wisi-parser-state-stack parser-state)); reference
	 (sp (wisi-parser-state-sp parser-state)); copy
	 (token-count (nth 2 action))
	 (nonterm (nth 0 action))
	 (nonterm-region (when (> token-count 0)
			   (wisi-nonterm-bounds stack (- sp (* 2 (1- token-count)) 1) (1- sp))))
	 (post-reduce-state (aref stack (- sp (* 2 token-count))))
	 (new-state (cdr (assoc nonterm (aref gotos post-reduce-state))))
	 tokens)
    (when (not new-state)
      (error "no goto for %s %d" nonterm post-reduce-state))
    (dotimes (i token-count)
      (push (aref stack (- sp (* 2 i) 1)) tokens))
    (setq sp (+ 2 (- sp (* 2 token-count))))
    (aset stack (1- sp) (cons nonterm (cons nil nonterm-region)))
    (aset stack sp new-state)
    (setf (wisi-parser-state-sp parser-state) sp)
    (if pendingp
	(push (cons (nth 1 action) tokens) (wisi-parser-state-pending parser-state))
      (funcall (nth 1 action) tokens))
    ))

(provide 'wisi-parse)
;; end of file
